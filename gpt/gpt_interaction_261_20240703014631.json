{
  "timestamp": "2024-07-03T01:46:32.560Z",
  "mode": "initial",
  "input": "Uniform Linear Motion\n\nWe're finally starting to create physics simulation animations, and we'll begin with the simplest form of motion: uniform linear motion. Our goal is to depict a block, the floor, and the block's x-t graph and v-t graph. Here are the results: [Link to GlowScript animation]\n\nBlock's x-t Graph\n\nBlock's v-t Graph\n\nIf you open the code in Python IDLE editor, in the default state, the colors you see should be similar to the ones above. The editor automatically marks reserved words in Python that have special functions, text within quotes, comments, etc., with different colors, which facilitates reading the code. Python has two types of comments:\n\nMulti-line comments: Text between two \"\"\" or ''' lines\nSingle-line comments: Text from a # to the end of the line\nThe interpreter ignores comments when executing code. Although comments do not assist in the operation of the program, they are very important for users. Without comments, even the authors might forget what they wrote after a few days, not to mention making it understandable for other users. Therefore, it is essential to develop the habit of writing comments.\n\nI usually start by clearly writing the program's name, function, date, and author. Before setting parameters, I write:\n\nfrom vpython import *\nThis is the syntax in Python for importing libraries. By default, the physics simulation library vpython is not included, so we need to add this line of code, which means importing all functions from the vpython library. It can also be written as:\n\nimport vpython as custom_name\nIf the custom name is vp, then to use a function from vpython, you would write vp.[function_name]; if you just write import vpython, you need to write vpython.[function_name] instead. Since our focus is on animations, the first method is recommended, allowing you to reference functions in vpython simply by their names.\n\nThe entire program can be divided into three parts:\n\nParameter Settings\nDisplay Settings\nObject Motion\n\nParameter Settings\nIn the parameter settings section, I tend to assign frequently used values in the program to corresponding variables and give these variables understandable names. Although Python 3.X supports Unicode, allowing for the use of Chinese characters in variable names, it is still recommended to use English letters, numbers, and underscores for variable names, where letters are case-sensitive, and the name cannot start with a number or use reserved words. Ideally, variables should be named descriptively, e.g., size for the size of a block.\n\nIn this definition, I have variables size, L, v, t, dt, with their purposes already commented next to them. The value of the time interval dt needs to be adjusted according to actual needs because VPython calculates physical quantities like force, acceleration, velocity, displacement, etc., using numerical methods. If the time interval is too long, the resulting values will have significant errors; however, if it's too short, the duration of the entire simulation animation will be extended. The current setting of 0.01 is precise enough for this animation.\n\nDisplay Settings\nWe will use functions like canvas, box, graph, gcurve, which are explained below.\n\ncanvas\nIn VPython, a canvas is used to generate the display for animations, currently shown via a browser like Google Chrome, FireFox, or Windows Edge. In VPython 6 and earlier versions, the function was named display and would open a separate window. In this program, I've named the animation window scene. You usually adjust options such as:\n\ntitle: The title of the display, shown in the top left corner of the screen.\nwidth: The width of the display (horizontally).\nheight: The height of the display (vertically).\nx, y: The position of the top-left corner of the display within the browser window, although VPython appears to automatically adjust based on the existing object's dimensions.\ncenter: Represents the observer's position.\nbackground: Background color, numbers in the vector parenthesis represent the proportion of red, green, and blue primary colors, ranging between 0 and 1. Alternatively, already named common colors can be used.\n\nVPython 7 Supported Colors\n\nbox\nBox in VPython is used to produce a cuboid. In this program, both the cube and the floor are generated using a box. The usual options to adjust include:\n\npos: The position of the center of the cuboid, as a vector, vector(x, y, z), which can also be simplified to vec.\nlength, height, width are the lengths in the x, y, z directions, respectively, and can also be simplified to size=vec(x, y, z).\ncolor: The color of the cuboid.\n\ngraph\nGraph in VPython is used to create a plotting window. In VPython 6 and earlier versions, the function name was gdisplay. In this program, I've named two plotting windows gd and gd2, used to plot the block's x-t graph and v-t graph, respectively. The usual options to adjust are similar to those for canvas, and I've already introduced the functionalities of title, width, height, x, y. The different options used here include:\n\nxtitle: Name of the x-axis.\nytitle: Name of the y-axis.\n\ngcurve\nIn VPython, gcurve is used to plot continuous curves in a plotting window. In this program, two curves named xt and vt are displayed in gd and gd2, respectively. The usual options to adjust include:\n\ngraph: Indicates which plotting window to display.\ncolor: The color of the curve.\nAdditionally, there are gdots for only plotting data points and gvbars for plotting bar charts, although they are not used here.\n\nObject Motion\nUsing a while loop, the state of the object is updated every short interval dt. Since I want the program to stop when the block reaches the edge of the floor, the condition set in the while loop is:\n\ncube.pos.x <= 0.5*L - 0.5*size\nBelow, I explain the purpose of each line of code.\n\nrate(1000) indicates that the animation updates 1000 times per second.\ncube.pos.x += v*dt updates the position of the block. cube.pos.x reads the x-coordinate of the cube's position, adds the product of velocity v and a short time dt, and then reassigns it to the cube's x-coordinate.\nxt.plot(pos=(t, cube.pos.x)) plots the block's x-t graph, where the horizontal axis position is time t, and the vertical axis position is the block's position cube.pos.x.\nvt.plot(pos=(t, cube.v.x)) plots the block's v-t graph, where the horizontal axis position is time t, and the vertical axis position is the block's velocity cube.v.x.\nt += dt updates the time by adding dt to t, equivalent to writing t = t + dt.\n\nConclusion\nAlthough the effect of this animation is very simple, and one might imagine the motion of the object without needing animation, it is very suitable as a first animation. Any discrepancies from physical principles in the animation are easily noticeable. More physical quantities like acceleration, force, angle, etc., will be added to the animations later.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n\n(2) Radius_I is the speed of the cube. When Radius_I changes to a new value, the speed of the cube also changes to that value.",
  "output": "from vpython import *\n\n# Parameter settings\nsize, L, t, dt = 1, 10, 0, 0.01\n\n# Display settings\nscene = canvas(width=800, height=800, x=0, y=0, center=vector(0, 0, 0), background=vector(1, 1, 1))\ncube = box(pos=vector(0, 0, 0), size=vector(size, size, size), color=color.blue)\nfloor = box(pos=vector(0, -0.5*size, 0), size=vector(L, 0.01, 10*size), color=color.green)\ngd = graph(width=600, height=450, x=0, y=300, xtitle='<i>t</i> (s)', ytitle='<i>x</i> (m)', background=vector(0.5, 0.5, 0))\nxt = gcurve(graph=gd, color=color.red)\ngd2 = graph(width=600, height=450, x=0, y=0, xtitle='<i>t</i> (s)', ytitle='<i>v</i> (m/s)', background=vector(0.5, 0.5, 0))\nvt = gcurve(graph=gd2, color=color.blue)\n\n# Initialize the speed of the cube\nRadius_I = 1\n\n# Object motion\nwhile cube.pos.x <= 0.5*L - 0.5*size:\n    rate(1000)\n    cube.pos.x += Radius_I*dt\n    xt.plot(pos=(t, cube.pos.x))\n    vt.plot(pos=(t, Radius_I))\n    t += dt"
}