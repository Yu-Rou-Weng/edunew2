{
  "timestamp": "2024-07-03T02:54:14.117Z",
  "mode": "initial",
  "input": "Uniform Linear Motion\n\nWe are finally starting to create physics simulation animations, and we will begin with the simplest form: uniform linear motion. The goal is to illustrate the block, the floor, and the block's x-t (position-time) graph and v-t (velocity-time) graph. The results are as follows: GlowScript website animation link.\n\nBlock's x-t Graph\n\nBlock's v-t Graph\n\nIf you open the code with the Python IDLE editor, under default conditions, the colors should look similar to those shown above. The editor automatically highlights reserved words in Python that have special functions, text within quotes, comments, etc., in different colors, which facilitates reading the code. Python has two types of comment syntax:\n\nMulti-line comments: Text between two sets of triple quotes, \"\"\" or '''\nSingle-line comments: Text following a # to the end of the line\nThe interpreter ignores comments during code execution. Although comments do not assist in the program's operation, they are crucial for users. Without comments, even the author might forget what they were coding after a few days, let alone enabling other users to understand the code. Therefore, it's essential to develop the habit of writing comments.\n\nI usually start by clearly writing the program's name, function, date, and author. Then, before setting parameters, I write:\n\nfrom vpython import *\nThis syntax in Python is for importing libraries. By default, the library for physics simulations, vpython, is not imported, so this line is necessary to import all functions from the vpython library. Alternatively, you could write:\n\nimport vpython as custom_name\nIf custom_name is vp, then one would need to write vp.[function_name] to refer to a function in vpython; if you just write import vpython, you would need to refer to a function with vpython.[function_name]. Since our focus is on animation, the first method is recommended for easier reference to functions in vpython.\n\nThe program can roughly be divided into three parts:\n\nParameter Settings\nScene Setup\nObject Motion\n\nParameter Settings\nIn this section, I typically assign frequently used values in the program to corresponding variables with easy-to-understand names. Although Python 3.X supports Unicode, allowing Chinese characters as variable names, it is still recommended to use English letters, numbers, and underscores. Names should start with a letter, not a digit or a reserved word. Ideally, variables should have meaningful names to understand their purpose, such as naming the block size as size.\n\nVariables I have defined here include size, L, v, t, and dt, with their purposes already commented in the code. The value of dt, the time interval, should be adjusted based on actual needs. This is because VPython calculates physical quantities such as forces, acceleration, velocity, and displacement using numerical methods. If the time interval is too long, the numerical results will have significant errors; if too short, the simulation runs longer. The current setting of 0.01 is precise enough for this simulation.\n\nScene Setup\nWe will use the functions canvas, box, graph, gcurve, which are explained below.\n\ncanvas\nIn VPython, \"canvas\" refers to the display screen for animations, currently shown through browsers like Google Chrome, Firefox, or Windows Edge. In earlier versions like VPython 6, the function name was \"display,\" which would open a separate window. The canvas typically includes options for adjusting:\n\ntitle: The title of the scene, displayed at the top left of the canvas.\nwidth: The width of the canvas (horizontal direction).\nheight: The height of the canvas (vertical direction).\nx, y: The top-left corner of the canvas in the browser window, though VPython seems to automatically adjust this based on existing object dimensions.\ncenter: Represents the observer's position.\nbackground: The background color, where the numbers inside the vector parentheses represent the proportions of the primary colors red, green, and blue, ranging from 0 to 1. Predefined common colors can also be used.\n\nVPython 7 Supported Colors\n\nbox\nIn VPython, \"box\" is used to create a cuboid. In this program, both the cube and the floor are generated using box. Commonly adjusted options include:\n\npos: The position of the center of the cuboid, expressed as a vector, vector(x, y, z), which can also be simplified to vec.\nlength, height, width: The dimensions in the x, y, z directions, respectively, which can also be simplified to size=vec(x, y, z).\ncolor: The color of the cuboid.\n\ngraph\nIn VPython, \"graph\" is used to create a graphing window. In earlier versions like VPython 6, it was called \"gdisplay\". In this program, I have named two graphing windows as gd and gd2, used for plotting the block's x-t graph and v-t graph, respectively. Similar to canvas, options like title, width, height, x, and y are adjustable, with additional options:\n\nxtitle: The name of the x-axis.\nytitle: The name of the y-axis.\n\ngcurve\nIn VPython, \"gcurve\" is used to draw continuous curves in a graphing window. In this program, the curves named xt and vt are displayed in gd and gd2, respectively. Commonly adjusted options include:\n\ngraph: Indicates which graphing window the curve will appear in.\ncolor: The color of the curve.\nOther features like gdots, which only plot data points, and gvbars, used for bar graphs, are not used here.\n\nObject Motion\nThe program uses a while loop to update the object's state at intervals dt. I want the program to stop when the block reaches the edge of the floor, so the condition in the while loop is:\n\ncube.pos.x <= 0.5*L - 0.5*size\nNext, I will explain the purpose of each line of code.\n\nrate(1000) specifies that the animation updates 1000 times per second.\ncube.pos.x += v*dt updates the position of the block, where cube.pos.x reads the x-coordinate of the cube's position, adds the product of the velocity v and a small time interval dt, and reassigns this value to the x-coordinate of the cube's position.\nxt.plot(pos=(t, cube.pos.x)) plots the block's x-t graph, with the horizontal position of the line segment as time t and the vertical position as the block's position, cube.pos.x.\nvt.plot(pos=(t, cube.v.x)) plots the block's v-t graph, with the horizontal position of the line segment as time t and the vertical position as the block's speed, cube.v.x.\nt += dt updates the time by adding dt to t, equivalent to writing t = t + dt.\n\nConclusion\nAlthough the animation's effect is very simple and one could probably imagine the object's motion without it, it is precisely because of its simplicity that it is suitable as a first animation. Any discrepancies from physical principles in the animation are easily noticeable. Later, more physical quantities such as acceleration, force, and angle will be added to the animations.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n\n(2) Radius_I is the speed of the cube. When Radius_I changes to a new value, the speed of the cube also changes to that value.\n(3) Do not import packages that are not supported by VPython, such as np, math, and time.",
  "output": "from vpython import *\n\n# Parameter Settings\nsize = 0.5  # block size\nL = 10.0  # floor length\nv = 1.0  # initial speed\nt = 0  # initialize time\ndt = 0.01  # time interval\n\n# Scene Setup\nscene = canvas(title=\"Uniform Linear Motion\", width=800, height=300, center=vec(0, 0, 0), background=vec(0.5, 0.5, 0))\nfloor = box(length=L, height=0.01, width=3, color=vec(0.5, 0.5, 0.5))\ncube = box(pos=vec(0, 0, 0), size=vec(size, size, size), color=color.red, v=vec(v, 0, 0))\ngd = graph(title=\"x-t graph\", xtitle=\"t (s)\", ytitle=\"x (m)\")\nxt = gcurve(graph=gd, color=color.red)\ngd2 = graph(title=\"v-t graph\", xtitle=\"t (s)\", ytitle=\"v (m/s)\")\nvt = gcurve(graph=gd2, color=color.blue)\n\n# Object Motion\nwhile cube.pos.x <= 0.5*L - 0.5*size:\n    rate(1000)\n    cube.pos.x += cube.v.x*dt\n    xt.plot(pos=(t, cube.pos.x))\n    vt.plot(pos=(t, cube.v.x))\n    t += dt"
}