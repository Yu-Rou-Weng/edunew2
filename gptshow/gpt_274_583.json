{
  "session_id": 583,
  "log": [
    {
      "input": "## Circular Motion\n\nIf a small ball has a mass of $m$, a velocity of $v$, an angular velocity of $\\omega$, and a curvature radius of $R$ when turning, then the centripetal acceleration required for turning is\n$$\na_c = \\frac{v^2}{R} = R \\omega^2\n$$\n\nFrom Newton's second law of motion, the centripetal force is\n$$\nF_c = m a_c = m \\cdot \\frac{v^2}{R} = m \\cdot R \\omega^2\n$$\n\nIf you want to use VPython to draw the small ball performing uniform circular motion on a horizontal plane, we need to figure out how to calculate the magnitude and direction of centripetal acceleration, and only draw the uniform circular motion of the ball.\n\n## Horizontal Plane Circular Motion\n\n### Parameter Settings\n\nVariables defined here include size, v0, R, L, t, dt, and their purposes are already written in the comments of each line.\n\n### Scene Settings\n\nA new feature is used here:\n\nscene.camera.pos = vec(0, L/2, L/2)\nscene.camera.axis = vec(0, -L/2, -L/2)\ncamera.pos is used for the position of the observer, and camera.axis sets the direction the observer views the scene.\n\nThe ball moves on the xz plane, starting from the right side of the scene at a distance R, with the initial velocity in the direction of the -z axis, with a magnitude of v0.\n\narrow_v and arrow_a are arrows representing the velocity and acceleration of the ball.\n\n### Object Motion\nUse axis = ball.pos - vec(0, size, 0) to find the position vector of the ball relative to the axis of rotation.\n\nUse ball.a = -(ball.v.mag2 / R) * axis.norm() to calculate the ball\u2019s centripetal acceleration. Here mag2 is used to calculate the squared magnitude of a vector, assuming the vector\u2019s name is A, with the following syntax:\n\n\nA.mag2 = mag2(A)\nnorm() is used to calculate a unit vector, assuming the vector\u2019s name is A, with the following syntax:\n\n\nA.norm() = norm(A)\nFinally, update the ball's velocity and position, update the starting position, direction, and length of the arrows, and update the time.\n\n### Supplement: attach_arrow\nVPython provides an attach_arrow feature [5], which allows attaching an arrow to an object. The arrow's position, length, and direction change with the object\u2019s properties. If using the attach_arrow feature, you can change lines 26 to 28 to:\n\n\nball = sphere(pos=vec(R, size, 0), radius=size, color=color.red, make_trail=True, retain=100, v=vec(0, 0, -v0), a=vec(-v0**2/R, 0, 0))\narrow_v = attach_arrow(ball, \"v\", radius=0.2*size, shaftwidth=0.4*size, color=color.green)\narrow_a = attach_arrow(ball, \"a\", radius=0.2*size, shaftwidth=0.4*size, color=color.blue)\nAt the same time, delete lines 39 to 42, achieving the same animation effect without needing to update the arrows' position, length, and direction in the while loop, making the code more concise.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Speed_I as a cyber input variable, set Speed_I=10\n\n(2) Speed_I is the initial velocity of the ball. When Speed_I changes to a new value, the initial velocity of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nsize = 0.02  # radius of the ball\nL = 1.0  # length of the scene\nR = 0.3  # radius of circular motion\nSpeed_I = 10  # initial speed\nt = 0  # initial time\ndt = 0.001  # time step\n\n# Scene Settings\nscene = canvas(width=800, height=800, background=vec(0.5,0.5,0))\nscene.camera.pos = vec(0, L/2, L/2)\nscene.camera.axis = vec(0, -L/2, -L/2)\n\n# Object Settings\nball = sphere(pos=vec(R, size, 0), radius=size, color=color.red, make_trail=True, retain=100, v=vec(0, 0, -Speed_I))\narrow_v = arrow(pos=ball.pos, axis=ball.v, color=color.green)\narrow_a = arrow(pos=ball.pos, color=color.blue)\n\n# Object Motion\nwhile True:\n    rate(1000)\n    axis = ball.pos - vec(0, size, 0)\n    ball.a = -(ball.v.mag2 / R) * axis.norm()\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    arrow_v.pos = ball.pos\n    arrow_v.axis = ball.v\n    arrow_a.pos = ball.pos\n    arrow_a.axis = ball.a\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 01:43:32",
      "serial_number": 1
    }
  ]
}