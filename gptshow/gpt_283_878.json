{
  "session_id": 878,
  "log": [
    {
      "input": "# Planetary Motion\n\nProgram to be written: Planetary Motion, with customizable planet speed and distance, and ability to modify the power of r in the universal law of gravitation.\n\nKepler's laws of planetary motion consist of the following three laws:\n\n1. **First Law (Law of Orbits)**: All planets move in elliptical orbits with the sun at one of the focal points.\n\n2. **Second Law (Law of Equal Areas)**: A line segment joining a planet and the sun sweeps out equal areas during equal intervals of time. If the distance between the sun and the planet is $r$, the planet's speed is $v$, and the angle between $r$ and $v$ is $\\theta$, then the area swept by the line segment per unit time is\n$$\n\\frac{\\Delta A}{\\Delta t} = \\frac{1}{2} rv \\sin{\\theta} = \\text{constant}\n$$\n\n3. **Third Law (Law of Periods)**: For all planets orbiting the sun, the square of the orbital period $T$ is proportional to the cube of the semi-major axis of its orbit $a$\n$$\n\\frac{a^3}{T^2} = \\text{constant}\n$$\n\nThe first law is due to the gravitational interaction between the sun and the planets, proving that only elliptical orbits are stable according to the universal law of gravitation. The second law is because gravity acts through the sun, thus conserving the angular momentum of the planet relative to the sun, making the swept area equal in equal times. The third law can be derived using the law of gravitation as the centripetal force. Using real data from the solar system, these three laws can be visually demonstrated.\n\n## Parameter Settings\n\nVariables are set as G, size, sun_m, d, v0, theta, n, t, dt, with the purpose written in the comments of each line. E represents the power of 10, for example, 1E3 = 1000, and can also be replaced by e. I aim to use real data as much as possible, but when using real distances, the radius of the planet must be enlarged to be visible.\n\n## Display Settings\n\nWhen generating the sun, the last option is `emissive=True`, which by default is False. If set to True, the sun will emit light.\n\nWhen generating Earth, set the material `texture=textures.earth`, as VPython has a built-in texture of Earth, eliminating the need to find an image separately. However, since the Earth object does not have a color set, the default color of the orbit is white. If you want to change it to blue, add `trail_color=color.blue`. If you want to change the orbit radius to `0.1*size`, add `trail_radius=0.1 * size`.\n\nTo make the sun emit light, in the old version of VPython, you would write:\n\n```\nscene.lights = [local_light(pos=vec(0, 0, 0), color=color.white)]\n```\n\nBut in VPython 7, this method is not supported anymore. Instead, place a light source at the sun's position:\n\n```\nlamp = local_light(pos=vec(0,0,0), color=color.white)\n```\n\nGenerate arrows representing velocity and acceleration.\n\n## Object Motion\nCalculate the acceleration of the planet:\n\n```\nplanet.a = - G*sun.m / planet.pos.mag**n * planet.pos.norm()\n```\n\nTo be able to change the power of the distance in the universal law of gravitation, instead of using planet.pos.mag2 to calculate the square of the distance between the planet and the sun, use planet.pos.mag**n to calculate the nth power of the distance. Then update the planet's velocity and position.\n\nUpdate the arrows representing velocity and acceleration in terms of position, direction, and length. Since the distance between the planet and the sun is large, the arrows need to be scaled up to be visible.\n\n## Cyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1E10\n\n(2) Radius_I is the radius of the planet. When Radius_I changes to a new value, the radius of the planet also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nG = 6.67384E-11 # gravitational constant\nsize = 2E10     # scale factor for the visual size of the planet\nsun_m = 2E30    # mass of the sun\nd = 1.496E11    # initial distance between the planet and the sun\nv0 = 2.9783E4   # initial velocity of the planet\ntheta = 0       # initial angle between r and v\nn = 2           # the power of r in the universal law of gravitation\nt = 0           # current simulation time\ndt = 60*60*24   # time step\nRadius_I = 1E10 # radius of the planet\n\n# Create Objects\nscene = canvas(title=\"Planetary Motion\")\nsun = sphere(pos=vec(0, 0, 0), radius=2*size, color=color.yellow, emissive=True)\nplanet = sphere(pos=vec(d, 0, 0), radius=Radius_I, texture=textures.earth, make_trail=True)\nplanet.m = 6E24 # mass of the planet\nplanet.v = v0 * vec(0, cos(theta), sin(theta)) # initial velocity of the planet\nplanet.a = vec(0, 0, 0) # initial acceleration of the planet\nv_arrow = arrow(pos=planet.pos, axis=planet.v, color=color.green) # velocity arrow\na_arrow = arrow(pos=planet.pos, axis=planet.a, color=color.red)   # acceleration arrow\n\n# Lighting\nlamp = local_light(pos=vec(0,0,0), color=color.white)\n\n# Object Motion\nwhile True:\n    rate(1000)\n    planet.a = -G * sun_m / planet.pos.mag**n * planet.pos.norm() # acceleration of the planet\n    planet.v += planet.a*dt # update velocity\n    planet.pos += planet.v*dt # update position\n    v_arrow.pos = planet.pos\n    v_arrow.axis = planet.v / 2E3 # rescale for visibility\n    a_arrow.pos = planet.pos\n    a_arrow.axis = planet.a / 2E13 # rescale for visibility\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-27 14:18:54",
      "serial_number": 1
    }
  ]
}