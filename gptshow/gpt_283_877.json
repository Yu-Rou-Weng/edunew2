{
  "session_id": 877,
  "log": [
    {
      "input": "# Planetary Motion\n\nProgram to be written: Planetary Motion, custom planetary speed and distance, ability to change the power of r in the law of universal gravitation.\n\nKepler\u2019s laws of planetary motion include the following three laws:\n\n1. **First Law (The Law of Orbits)**: All planets move in elliptical orbits with the Sun at one of the foci.\n\n2. **Second Law (The Law of Equal Areas)**: The line joining a planet and the Sun sweeps out equal areas during equal intervals of time. If the distance between the Sun and the planet is $r$, the velocity of the planet is $v$, and the angle between $r$ and $v$ is $\\theta$, then the area swept by the line joining the planet and the Sun in unit time is\n$$\n\\frac{\\Delta A}{\\Delta t} = \\frac{1}{2} rv \\sin{\\theta} = \\text{constant}\n$$\n\n3. **Third Law (The Law of Periods)**: For all planets orbiting the Sun, the square of the orbital period $T$ is proportional to the cube of the semi-major axis of the orbit $a$\n$$\n\\frac{a^3}{T^2} = \\text{constant}\n$$\n\nWe know the First Law is due to only gravitational forces acting between the Sun and the stars, and according to the law of universal gravitation, only an ellipse represents a stable orbit. The Second Law is because the gravitational force passes through the Sun, thus conserving the angular momentum of the planet relative to the Sun, and hence the area swept by the line joining the planet and the Sun is equal in unit time. The Third Law can be derived using the law of gravitation as the centripetal force. By incorporating real data from the solar system planets, these three laws can be graphically represented.\n\n## Parameter Settings\n\nVariables are set as G, size, sun_m, d, v0, theta, n, t, dt, with their purposes written in the comments of each line. Here, E represents powers of ten, for example, 1E3 = 1000, and can also be replaced with e. Since I aim to use real data as much as possible, when the distance is based on real data, the radius of the planets must be enlarged, otherwise, the planets will not be visible.\n\n## Screen Setup\n\nWhen generating the Sun, the last option is `emissive=True`, which is set to False by default. If set to True, the Sun will emit light.\n\nWhen generating Earth, set the material `texture=textures.earth` as VPython has a built-in texture for Earth, so there's no need to look for an image. However, since the Earth object does not have a color set, the default color of the trajectory is white, but if you want to change it to blue, add `trail_color=color.blue`. To change the radius of the trail to `0.1*size`, add `trail_radius=0.1 * size`.\n\nTo make the Sun emit light, in the older versions of VPython, the syntax was:\n\nscene.lights = [local_light(pos=vec(0, 0, 0), color=color.white)]\nHowever, in VPython 7, this syntax is no longer supported; instead, a light source is placed at the position of the Sun:\n\nlamp = local_light(pos=vec(0,0,0), color=color.white)\nGenerating arrows representing velocity and acceleration.\n\n## Object Motion\nCalculating the acceleration of the planet:\n\nplanet.a = - G*sun.m / planet.pos.mag**n * planet.pos.norm()\nTo be able to change the power of distance in the law of universal gravitation, instead of using planet.pos.mag2 to calculate the square of the distance between the planet and the Sun, planet.pos.mag**n is used to calculate the nth power of the distance between the planet and the Sun. Then, update the planet\u2019s velocity and position.\n\nUpdate the position, direction, and length of the arrows representing velocity and acceleration. Since the distance between the planet and the Sun is very large, the arrows are enlarged to be visible.\n\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1E10 \n\n(2) Radius_I is the radius of the planet. When Radius_I changes to a new value, the radius of the planet also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# parameter settings\nG = 6.67384E-11\nsize = 1E10\nsun_m = 2E30\nd = 1.496E11\nv0 = 2*pi*d/365/24/60/60\ntheta = pi/2\nn = 2\nt = 0\ndt = 60*60*24\nRadius_I = 1E10 \n\nsun = sphere(pos=vec(0, 0, 0), radius=size, color=color.yellow, emissive=True)\nplanet = sphere(pos=vec(d, 0, 0), radius=Radius_I, color=color.blue, make_trail=True, \n                trail_type='points', interval=10, retain=50, trail_color=color.blue)\nplanet.v = vec(0, v0, 0)\nplanet.m = 6E24\nv_arrow = arrow(pos=planet.pos, axis=planet.v, shaftwidth=0.05*size, color=color.green)\np_arrow = arrow(pos=planet.pos, axis=planet.pos-sun.pos, shaftwidth=0.05*size, color=color.red)\nlamp = local_light(pos=vec(0,0,0), color=color.white)\n\n# object motion\nwhile True:\n    rate(1000)\n    planet.a = -G * sun_m / planet.pos.mag**n * planet.pos.norm()\n    planet.v += planet.a*dt\n    planet.pos += planet.v*dt\n    v_arrow.pos = planet.pos\n    v_arrow.axis = planet.v*1E-4\n    p_arrow.pos = planet.pos\n    p_arrow.axis = planet.pos - sun.pos\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-27 14:01:01",
      "serial_number": 1
    }
  ]
}