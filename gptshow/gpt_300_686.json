{
  "session_id": 686,
  "log": [
    {
      "input": "Simple Harmonic Motion Caused by Electrostatic Force (Placed on the Right Side of the Line Connecting the Centers)\n\nPreviously, we have dealt with simple harmonic motion caused by gravity in \"Gravity and Simple Harmonic Motion.\" Upon learning about electrostatic forces, we find that Coulomb's Law resembles the law of universal gravitation, suggesting that electrostatic forces should also be able to produce a similar motion pattern. Here are three different programs:\n\n19-1. Two fixed charged spheres, with a movable charged sphere placed on the right side of the midpoint of the line connecting the centers (Animation link on GlowScript website)\n19-2. Two fixed charged spheres, with a movable charged sphere placed above the perpendicular bisector (Animation link on GlowScript website)\n19-3. Modifying the charged sphere in 19-2 to a ring, with a movable charged sphere placed above the perpendicular bisector (Animation link on GlowScript website)\n\n## Program 19-1\n\n### Theoretical Derivation\n\nAs shown in the figure below, there are two point charges of $+Q$ each, fixed in position and separated by a distance of $2d$. At a position $x$ to the left of the midpoint on the line connecting their centers, there is a point charge of $+q$ with mass $m$.\n![image](https://hackmd.io/_uploads/SyxfG3TdR.png)\n\nIf the velocity of $+q$ is zero at this point, and $x \\ll d$, considering only the electrostatic forces between the objects, the resultant force on $+q$ is directed to the right and given by:\n$$\nF = k \\frac{Qq}{(d - x)^2} - k \\frac{Qq}{(d + x)^2} = kQq \\left[ \\frac{1}{(d + x)^2} - \\frac{1}{(d - x)^2} \\right]\n$$\n\n$$\n= kQq \\left[ \\frac{(d - x)^2 - (d + x)^2}{(d - x)^2 (d + x)^2} \\right]\n$$\n\n$$\n= kQq \\left[ \\frac{4dx}{d^4 (1 - \\frac{x}{d})^2 (1 + \\frac{x}{d})^2} \\right] \\approx \\frac{4kQq}{d^3} \\cdot x = Kx\n$$\n\nThus, $+q$ undergoes simple harmonic motion with a period\n$$\nT = 2\\pi \\sqrt{\\frac{m}{K}} = 2\\pi \\sqrt{\\frac{md^3}{4kQq}} = \\pi \\sqrt{\\frac{md^3}{kQq}}\n$$\n\nThe figure below, drawn with $Q = q = 2 \\times 10^4 \\, C$, illustrates the electrostatic force F as a function of distance x. From the graph, it is evident that when x is very small, $F \\propto x$, and the slope is approximately 1.5, which aligns with the theoretical value.\n\nElectrostatic Force F-Distance x Relationship Graph (0 \u2264 x \u2264 9):\n![image](https://hackmd.io/_uploads/ByZXzh6_R.png)\n\nElectrostatic Force F-Distance x Relationship Graph (0 \u2264 x \u2264 4):\n![image](https://hackmd.io/_uploads/ryXVG36_A.png)\n\nParameter Settings\nVariables such as Q, q, m, size, d, h, k, i, t, dt are set here, with their purposes noted in the respective comments.\n\nDisplay Settings\nPlace the larger spheres at (-d, 0, 0) and (d, 0, 0), and the smaller sphere at (h, 0, 0) with an initial velocity of 0 and mass m.\n\nDraw a line between the large spheres. The initial position of the small sphere should be at the right endpoint, hence the left endpoint should be at x = -h. Mark the position at the endpoint.\n\nGenerate arrows representing velocity and acceleration. To prevent the arrows from overlapping, they are drawn at distances of 1 and 2 above the small sphere.\n\nOpen the drawing window to plot the position, velocity, acceleration of the small sphere relative to time.\n\nObject Motion\nTo stop the animation after the small sphere moves back and forth five times, the condition in the while loop is set to i < 5, and use if (ball.pos.x >= h and ball.v.x >= 0) to determine if the small sphere has returned to the starting point. If it has, print the elapsed time t and the number of returns i.\n\nCalculate the net force F on the small sphere using Coulomb's Law, then compute the acceleration from F = ma, and update the velocity and position.\n\nProgram 19-1 Screenshot:\n![image](https://hackmd.io/_uploads/rJzSG3aO0.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\nQ, q, m, k = 2E-4, 2E-4, 1E-4, 9E9\nd, h = 2, 1\nRadius_I = 1\nsize, dt, t = 0.2, 0.001, 0\n\nscene = canvas(width=1000, height=600, align='left', range=3.5, background=vec(0.5, 0.5, 0))\n\ncharge1 = sphere(pos=vec(-d, 0, 0), radius=size, color=color.red)\ncharge2 = sphere(pos=vec(d, 0, 0), radius=size, color=color.red)\nball = sphere(pos=vec(h, 0, 0), radius=Radius_I, color=color.blue, v=vec(0, 0, 0), a=vec(0, 0, 0), m=m)\n\nline = curve(pos=[charge1.pos, charge2.pos], radius=0.01)\npos_end = sphere(pos=vec(-h, 0, 0), radius=0.1, color=color.black)\nv_vector = arrow(pos=ball.pos+vec(0, 1, 0), axis=vec(0, 0, 0), shaftwidth=0.05, color=color.green)\na_vector = arrow(pos=ball.pos+vec(0, 2, 0), axis=vec(0, 0, 0), shaftwidth=0.05, color=color.yellow)\n\ngd = graph(width=600, height=450, title='<b>x-t, v-t, a-t graph</b>', xtitle='<i>t</i> (s)', ytitle='blue: <i>x</i> (m), green: <i>v</i> (m/s), yellow: <i>a</i> (m/s^2)', xmin=0, xmax=5, ymin=-2, ymax=2, align='right')\nxt = gcurve(graph=gd, color=color.blue)\nvt = gcurve(graph=gd, color=color.green)\nat = gcurve(graph=gd, color=color.yellow)\n\ni = 0\nwhile i < 5:\n    rate(1000)\n    r1 = ball.pos-charge1.pos\n    r2 = ball.pos-charge2.pos\n    F = k*Q*q*(norm(r1)/mag(r1)**2-norm(r2)/mag(r2)**2)\n    ball.a = F/ball.m\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    v_vector.pos = ball.pos+vec(0, 1, 0)\n    v_vector.axis = ball.v\n    a_vector.pos = ball.pos+vec(0, 2, 0)\n    a_vector.axis = ball.a\n    xt.plot(pos=(t, ball.pos.x))\n    vt.plot(pos=(t, ball.v.x))\n    at.plot(pos=(t, ball.a.x))\n    t += dt\n    if ball.pos.x >= h and ball.v.x >= 0:\n        i += 1\n        print('t =', round(t, 2), 's')",
      "mode": "initial",
      "timestamp": "2024-07-24 09:27:07",
      "serial_number": 1
    },
    {
      "input": "Please update the following program based on this instruction: Make the small ball move back and forth between the two large balls.\n\nfrom vpython import *\n\nQ, q, m, k = 2E-4, 2E-4, 1E-4, 9E9\nd, h = 2, 1\nRadius_I = 1\nsize, dt, t = 0.2, 0.001, 0\n\nscene = canvas(width=1000, height=600, align='left', range=3.5, background=vec(0.5, 0.5, 0))\n\ncharge1 = sphere(pos=vec(-d, 0, 0), radius=size, color=color.red)\ncharge2 = sphere(pos=vec(d, 0, 0), radius=size, color=color.red)\nball = sphere(pos=vec(h, 0, 0), radius=Radius_I, color=color.blue, v=vec(0, 0, 0), a=vec(0, 0, 0), m=m)\n\nline = curve(pos=[charge1.pos, charge2.pos], radius=0.01)\npos_end = sphere(pos=vec(-h, 0, 0), radius=0.1, color=color.black)\nv_vector = arrow(pos=ball.pos+vec(0, 1, 0), axis=vec(0, 0, 0), shaftwidth=0.05, color=color.green)\na_vector = arrow(pos=ball.pos+vec(0, 2, 0), axis=vec(0, 0, 0), shaftwidth=0.05, color=color.yellow)\n\ngd = graph(width=600, height=450, title='<b>x-t, v-t, a-t graph</b>', xtitle='<i>t</i> (s)', ytitle='blue: <i>x</i> (m), green: <i>v</i> (m/s), yellow: <i>a</i> (m/s^2)', xmin=0, xmax=5, ymin=-2, ymax=2, align='right')\nxt = gcurve(graph=gd, color=color.blue)\nvt = gcurve(graph=gd, color=color.green)\nat = gcurve(graph=gd, color=color.yellow)\n\ni = 0\nwhile i < 5:\n    rate(1000)\n    r1 = ball.pos-charge1.pos\n    r2 = ball.pos-charge2.pos\n    F = k*Q*q*(norm(r1)/mag(r1)**2-norm(r2)/mag(r2)**2)\n    ball.a = F/ball.m\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    v_vector.pos = ball.pos+vec(0, 1, 0)\n    v_vector.axis = ball.v\n    a_vector.pos = ball.pos+vec(0, 2, 0)\n    a_vector.axis = ball.a\n    xt.plot(pos=(t, ball.pos.x))\n    vt.plot(pos=(t, ball.v.x))\n    at.plot(pos=(t, ball.a.x))\n    t += dt\n    if ball.pos.x >= h and ball.v.x >= 0:\n        i += 1\n        print('t =', round(t, 2), 's')",
      "output": "from vpython import *\n\nQ, q, m, k = 2E-4, 2E-4, 1E-4, 9E9\nd, h = 2, 1\nRadius_I = 1\nsize, dt, t = 0.2, 0.001, 0\n\nscene = canvas(width=1000, height=600, align='left', range=3.5, background=vec(0.5, 0.5, 0))\n\ncharge1 = sphere(pos=vec(-d, 0, 0), radius=size, color=color.red)\ncharge2 = sphere(pos=vec(d, 0, 0), radius=size, color=color.red)\nball = sphere(pos=vec(h, 0, 0), radius=Radius_I, color=color.blue, v=vec(0, 0, 0), a=vec(0, 0, 0), m=m)\n\nline = curve(pos=[charge1.pos, charge2.pos], radius=0.01)\npos_end = sphere(pos=vec(-h, 0, 0), radius=0.1, color=color.black)\nv_vector = arrow(pos=ball.pos+vec(0, 1, 0), axis=vec(0, 0, 0), shaftwidth=0.05, color=color.green)\na_vector = arrow(pos=ball.pos+vec(0, 2, 0), axis=vec(0, 0, 0), shaftwidth=0.05, color=color.yellow)\n\ngd = graph(width=600, height=450, title='<b>x-t, v-t, a-t graph</b>', xtitle='<i>t</i> (s)', ytitle='blue: <i>x</i> (m), green: <i>v</i> (m/s), yellow: <i>a</i> (m/s^2)', xmin=0, xmax=5, ymin=-2, ymax=2, align='right')\nxt = gcurve(graph=gd, color=color.blue)\nvt = gcurve(graph=gd, color=color.green)\nat = gcurve(graph=gd, color=color.yellow)\n\ni = 0\nwhile i < 5:\n    rate(1000)\n    r1 = ball.pos-charge1.pos\n    r2 = ball.pos-charge2.pos\n    if ball.pos.x>=h or ball.pos.x<=-h:\n        ball.v = -ball.v\n    F = k*Q*q*(norm(r1)/mag(r1)**2-norm(r2)/mag(r2)**2)\n    ball.a = F/ball.m\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    v_vector.pos = ball.pos+vec(0, 1, 0)\n    v_vector.axis = ball.v\n    a_vector.pos = ball.pos+vec(0, 2, 0)\n    a_vector.axis = ball.a\n    xt.plot(pos=(t, ball.pos.x))\n    vt.plot(pos=(t, ball.v.x))\n    at.plot(pos=(t, ball.a.x))\n    t += dt\n    if ball.pos.x >= h and ball.v.x >= 0:\n        i += 1\n        print('t =', round(t, 2), 's')",
      "mode": "modification",
      "timestamp": "2024-07-24 09:30:37",
      "serial_number": 2
    }
  ]
}