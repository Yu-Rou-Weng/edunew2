{
  "session_id": 697,
  "log": [
    {
      "input": "Simple Harmonic Motion Caused by Electrostatic Force (Ring, Placed Above the Vertical Line)\n\nWe have previously dealt with simple harmonic motion caused by gravity in \"Gravity and Simple Harmonic Motion.\" When we study electrostatic forces, we find that Coulomb's Law resembles the law of universal gravitation, suggesting that electrostatic forces could also produce similar motion patterns. Here are three different programs:\n\n19-3. Modify the charged sphere in 19-2 to a ring, and place the movable charged sphere above the perpendicular bisector.\n\n## Program 19-3\n\n### Theoretical Derivation\n\nAs shown in the diagram below, there is a ring with a radius $R$ and a total charge of $+Q$ uniformly distributed. If the ring is fixed and there is a point charge of $-q$ and mass $m$ at a distance $x$ from the center,\n![image](https://hackmd.io/_uploads/r1bRXhT_0.png)\n\nIf the velocity of the $-q$ point charge is zero at this point, and $x \\ll R$, only considering the electrostatic force between the objects. When calculating the resultant force on $-q$, first divide the ring into $N$ small spheres, each with a charge $\\Delta Q = \\frac{Q}{N}$. The electrostatic forces felt by $-q$ are directed along the connecting line, and there are equal and opposite forces on the other side. Therefore, the resultant force on $-q$ is directed downward, with a magnitude of\n$$\nF = \\frac{kQq x}{(R^2 + x^2)^{3/2}} \\approx \\frac{kQq x}{R^3} = Kx\n$$\n\nThus, $-q$ undergoes simple harmonic motion, with a period\n$$\nT = 2\\pi \\sqrt{\\frac{m}{K}} = 2\\pi \\sqrt{\\frac{mR^3}{kQq}}\n$$\n\nProgram 19-3 Screenshot:\n![image](https://hackmd.io/_uploads/HkxyN3pu0.png)\n\nProgramming Part\nProgram 19-3 is almost the same as 19-2, except that it first divides the ring into $N$ small spheres and then uses a for loop to calculate the electrostatic force between each segment of the ring and the movable sphere, finally calculating the resultant force on the movable sphere.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\nk = 8.99E9  # Coulomb constant\nQ = 1E-8    # Total charge of the ring\nq = -1E-11  # Charge of the moving sphere\nm = 1E-3    # Mass of the moving sphere\nR = 0.1     # Radius of the ring\nN = 100     # Number of point charges to divide the ring into\nRadius_I = 1  # Radius of the moving sphere\n\n# Create objects\nscene = canvas(width=600, height=600, align='left')\nring = ring(pos=vec(0, 0, 0), radius=R, thickness=0.005, color=color.red)\ncharges = [sphere(radius=0.005, color=color.yellow) for _ in range(N)]\nball = sphere(pos=vec(0, -R/2, 0), radius=Radius_I, color=color.blue, make_trail=True, \n              v=vec(0, 0, 0), a=vec(0, 0, 0))\n\n# Distribute charges uniformly on the ring\nfor i in range(N):\n    angle = i*2*pi/N\n    charges[i].pos = vec(R*cos(angle), R*sin(angle), 0)\n    \n# Time parameters\nt = 0\ndt = 0.001\n\nwhile True:\n    rate(1000)\n    F = vec(0, 0, 0)  # Total force on the moving charge\n    for charge in charges:  # Calculate the force from each point charge on the ring\n        r = ball.pos - charge.pos\n        F += (k*Q/N*q/mag2(r))*norm(r)\n    ball.a = F/m\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt",
      "mode": "initial",
      "timestamp": "2024-07-24 11:30:50",
      "serial_number": 1
    }
  ]
}