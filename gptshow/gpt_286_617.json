{
  "session_id": 617,
  "log": [
    {
      "input": "Program to be Written: Planetary Motion, Storing Planetary Data in a Dictionary, Generating Planets Using a Class\n\nKepler's laws of planetary motion consist of the following three laws:\n\n1. **First Law (The Law of Orbits)**: All planets move in elliptical orbits with the Sun at one of the foci.\n\n2. **Second Law (The Law of Areas)**: A line segment joining a planet and the Sun sweeps out equal areas during equal intervals of time. If the distance between the Sun and a planet is $r$, the planet's velocity is $v$, and the angle between $r$ and $v$ is $\\theta$, then the area swept by the line segment per unit time is\n$$\n\\frac{\\Delta A}{\\Delta t} = \\frac{1}{2} rv \\sin{\\theta} = \\text{constant}\n$$\n\n3. **Third Law (The Law of Periods)**: The square of the orbital period $T$ of a planet is directly proportional to the cube of the semi-major axis $a$ of its orbit\n$$\n\\frac{a^3}{T^2} = \\text{constant}\n$$\n\nThe first law is due to the gravitational interaction between the Sun and the planets, and according to the law of universal gravitation, only an ellipse is a stable orbit. The second law is because the gravitational force passes through the Sun, thus conserving the angular momentum of the planet relative to the Sun, ensuring the equal areas swept out per unit time. The third law can be derived using gravitational force as the centripetal force. With real data from the solar system planets, these three laws could be graphically represented.\n\nProgramming Part\nThis is based on programming planetary movements, storing planetary data in a dictionary, and generating planets using a class. If you want to create many similar objects in Python and customize functions within these objects, you can use a class. Class names usually start with an uppercase letter. There are two syntaxes for defining a class, one for inheriting from another class:\n\n```python\nclass Name(Source):\n    def function1(parameters):\n        return returnValue1\n\n    def function2(parameters):\n        return returnValue2\n```\n\nFor example, the custom class code in the program for planetary motion:\n\n```python\nclass Planet(sphere):\n    sun_m = mass[\"Sun\"]\n    def a(self):\n        return - G*self.sun_m / self.pos.mag2 * self.pos.norm()\n```\n\nThe class name is `Planet`, derived from `sphere`, inheriting all properties of `sphere`, allowing objects created with `Planet` to define properties like `pos`, `radius`, etc. It also defines the function `a` to calculate and return the acceleration of this planet object.\n\nIf not using inheritance, the class syntax is:\n\n```python\nclass Name:\n    def __init__(self, parameter1, parameter2, ...):\n        self.parameter1 = parameter1\n        self.parameter2 = parameter2\n        ...\n        \n    def function1(parameters):\n        return returnValue1  # This line can be omitted if there is no return value\n\n    def function2(parameters):\n        return returnValue2  # This line can be omitted if there is no return value\n```\n\nFor example, the custom class code in the program for planetary movement:\n\n```python\nclass Planet:\n    def __init__(self, pos, radius, mass, color, v):\n        self.pos = pos\n        self.radius = radius\n        self.mass = mass\n        self.color = color\n        self.v = v\n        self.a = 0\n        self.planet = sphere(pos=self.pos, radius=self.radius, mass=self.mass, \n                             color=self.color, make_trail=True, retain=365, v=self.v)\n    def update(self, dt):\n        self.dt = dt\n        self.a = -G*mass[\"Sun\"] / self.planet.pos.mag2 * self.planet.pos.norm()\n        self.v += self.a * self.dt\n        self.planet.pos += self.v * self.dt\n```\n\nWhen creating an object using `Planet`, you need to input parameters pos, radius, mass, color, and v, and use them in the custom function `__init__` to create a `sphere` object named `planet`. The custom function `update` takes the parameter `dt`, which calculates the acceleration and velocity of the `sphere` object, updating the position of `planet`. For more detailed information about classes, please refer to the article \"Custom Classes\".\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Length_I as a cyber input variable, set Length_I=10\n(2) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(3) Length_I is the length of the pendulum. When Length_I changes to a new value, the length of the pendulum also changes to that value.\n(4) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(5) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Define constants\nG = 6.67428e-11\nmass = {\"Sun\":2.0*10**30, \"Mercury\":3.3e23, \"Venus\":4.87e24, \"Earth\":5.97e24,\n        \"Mars\":0.642e24, \"Jupiter\":1898e24, \"Saturn\":568e24,\n        \"Uranus\":86.8e24, \"Neptune\":102e24}\n\ndistant = {\"Mercury\":57.9e9, \"Venus\":108.2e9, \"Earth\":149.6e9,\n           \"Mars\":227.9e9, \"Jupiter\":778.6e9, \"Saturn\":1434.5e9,\n           \"Uranus\":2872.5e9, \"Neptune\":4495.1e9}\n\nvelocity = {\"Mercury\":47.87e3, \"Venus\":35.02e3, \"Earth\":29.78e3,\n            \"Mars\":24.077e3, \"Jupiter\":13.07e3, \"Saturn\":9.69e3,\n            \"Uranus\":6.81e3, \"Neptune\":5.43e3}\n\n# Define Planet class\nclass Planet:\n    def __init__(self, name, pos, radius, mass, color):\n        self.name = name\n        self.pos = pos\n        self.radius = radius\n        self.mass = mass\n        self.color = color\n        self.v = vector(0, velocity[name], 0)\n        self.a = vector(0, 0, 0)\n        self.planet = sphere(pos=self.pos, radius=self.radius, mass=self.mass, \n                             color=self.color, make_trail=True, retain=365)\n\n    def update(self, dt):\n        self.a = -G*mass[\"Sun\"] / self.planet.pos.mag2 * self.planet.pos.norm()\n        self.v += self.a * dt\n        self.planet.pos += self.v * dt\n\n# Creating objects for each planet\nMercury = Planet(\"Mercury\", vector(distant[\"Mercury\"], 0, 0), 2.4397e6, mass[\"Mercury\"], color.red)\nVenus = Planet(\"Venus\", vector(distant[\"Venus\"], 0, 0), 6.0518e6, mass[\"Venus\"], color.yellow)\nEarth = Planet(\"Earth\", vector(distant[\"Earth\"], 0, 0), 6.371e6, mass[\"Earth\"], color.blue)\nMars = Planet(\"Mars\", vector(distant[\"Mars\"], 0, 0), 3.3895e6, mass[\"Mars\"], color.orange)\nJupiter = Planet(\"Jupiter\", vector(distant[\"Jupiter\"], 0, 0), 6.9911e7, mass[\"Jupiter\"], color.green)\nSaturn = Planet(\"Saturn\", vector(distant[\"Saturn\"], 0, 0), 5.8232e7, mass[\"Saturn\"], color.cyan)\nUranus = Planet(\"Uranus\", vector(distant[\"Uranus\"], 0, 0), 2.5362e7, mass[\"Uranus\"], color.white)\nNeptune = Planet(\"Neptune\", vector(distant[\"Neptune\"], 0, 0), 2.4622e7, mass[\"Neptune\"], color.magenta)\n\n# Creating sun object\nSun = sphere(pos=vector(0, 0, 0), radius=6.9634e8, color=color.yellow, mass=mass[\"Sun\"])\n\n# List of planets\nplanets = [Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune]\n\n# Time step\ndt = 60*60*24\n\n# Animation loop\nwhile True:\n    rate(100)  # Limit animation speed\n    for planet in planets:\n        planet.update(dt)",
      "mode": "initial",
      "timestamp": "2024-07-24 04:12:06",
      "serial_number": 1
    }
  ]
}