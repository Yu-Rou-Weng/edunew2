{
  "session_id": 721,
  "log": [
    {
      "input": "Simple Harmonic Motion Caused by Electrostatic Force (Placed Above the Perpendicular Bisector)\n\nPreviously, in our study of \"Gravity and Simple Harmonic Motion,\" we dealt with the simple harmonic motion caused by gravity. When we learn about electrostatic force, we find that Coulomb's Law is similar in form to Newton's Law of Universal Gravitation, suggesting that electrostatic force could also generate the same type of motion pattern. Here are three different scenarios:\n\n19-2. Two fixed charged spheres, with a movable charged sphere placed above the perpendicular bisector.\n\n## Scenario 19-2\n\n### Theoretical Derivation\n\nAs shown in the diagram below, there are two point charges, each with a charge of $+Q$, fixed in position at a distance of $2R$ apart. At a distance $x$ along the perpendicular bisector between them, there is a point charge with charge $-q$ and mass $m$.\n![image](https://hackmd.io/_uploads/B14gQ36dA.png)\n\nIf the point charge $-q$ has a speed of zero at this point and $x \\ll R$, considering only the electrostatic forces between the objects, the resultant force on $-q$ is directed downwards, with a magnitude given by\n$$\nF = \\frac{kQq}{R^2 + x^2} \\cdot \\frac{x}{\\sqrt{R^2 + x^2}} \\cdot 2 = \\frac{2kQq x}{(R^2 + x^2)^{3/2}}\n$$\n\n$$\n\\approx \\frac{2kQq x}{R^3} = Kx\n$$\n\nThus, $-q$ undergoes simple harmonic motion with a period of\n$$\nT = 2\\pi \\sqrt{\\frac{m}{K}} = 2\\pi \\sqrt{\\frac{mR^3}{2kQq}}\n$$\n\nBelow is a graph plotting the electrostatic force \\(F\\) against distance \\(x\\) using \\(Q=q=2 \\times 10^4 \\, C\\). From the graph, it can be observed that when \\(x\\) is very small, \\(F \\propto x\\), and the slope is approximately 0.7, consistent with the theoretical value.\n\nElectrostatic Force F vs. Distance x Graph (0 \u2264 x \u2264 100):\n![image](https://hackmd.io/_uploads/HkRXXh6O0.png)\n\nElectrostatic Force F vs. Distance x Graph (0 \u2264 x \u2264 10):\n![image](https://hackmd.io/_uploads/r1o4XnpdC.png)\n\nScreenshot of Scenario 19-2:\n![image](https://hackmd.io/_uploads/Hy7g42TOR.png)\n\nProgram Design\n\nScenario 19-2 is almost identical to 19-1, with only the differences described below.\n\nThe sphere is positioned at (0, h, 0).\n\nThe initial position of the sphere is at the upper endpoint, thus the lower endpoint should be at y = -h, and a line is drawn there to mark the position.\n\nArrows representing velocity and acceleration are drawn to the right of the sphere at distances of 1 and 2 units.\n\nThe condition to check if the sphere has returned to its starting point is modified to: if(ball.pos.y >= h and ball.v.y >= 0).\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\nscene = canvas(title='Simple Harmonic Motion', width=800, height=300, center=vector(0,-0.06,0), background=vector(0.5,0.5,0), range=0.3)\n\n# constants\nQ = 2E-6  # charge of the fixed spheres\nq = -2E-6  # charge of the moving sphere\nR = 0.2  # distance between the fixed spheres\nK = 8.99E9  # Coulomb constant\nm = 2E-3  # mass of the moving sphere\nh = 0.1  # initial height of the moving sphere\ng = vector(0, -9.8, 0)  # gravitational acceleration\nRadius_I = 0.01  # radius of the moving sphere\n\n# objects\nball = sphere(pos=vector(0, h, 0), radius=Radius_I, color=color.red)\nfixed_sphere1 = sphere(pos=vector(-R, 0, 0), radius=0.01, color=color.yellow)\nfixed_sphere2 = sphere(pos=vector(R, 0, 0), radius=0.01, color=color.yellow)\nvArrow = arrow(pos=ball.pos + vector(0.1, 0, 0), axis=vector(0,0,0), color=color.green)\naArrow = arrow(pos=ball.pos + vector(0.2, 0, 0), axis=vector(0,0,0), color=color.blue)\n\n# initial conditions\nball.v = vector(0, 0, 0)\ndt = 0.001\nt = 0\n\n# calculation loop\nwhile True:\n    rate(1000)\n    \n    # calculate the forces\n    r1 = ball.pos - fixed_sphere1.pos\n    r2 = ball.pos - fixed_sphere2.pos\n    F1 = K*Q*q*norm(r1) / mag(r1)**2\n    F2 = K*Q*q*norm(r2) / mag(r2)**2\n    F_net = F1 + F2 + m*g\n    \n    # update velocity and position\n    ball.v += F_net/m*dt\n    ball.pos += ball.v*dt\n    \n    # update arrows\n    vArrow.pos = ball.pos + vector(0.1, 0, 0)\n    vArrow.axis = ball.v / 10\n    aArrow.pos = ball.pos + vector(0.2, 0, 0)\n    aArrow.axis = F_net / m / 100\n    \n    # check if the ball has returned to the start\n    if ball.pos.y >= h and ball.v.y >= 0:\n        T = t\n        break\n    \n    t += dt\n\nprint(T)",
      "mode": "initial",
      "timestamp": "2024-07-24 13:37:30",
      "serial_number": 1
    }
  ]
}