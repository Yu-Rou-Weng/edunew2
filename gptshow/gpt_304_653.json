{
  "session_id": 653,
  "log": [
    {
      "input": "# Velocity Selector\n\nA velocity selector is a device used to filter charged particles moving at a specific velocity, with its basic structure shown in the figure below. It uses two parallel charged plates to create a downward electric field, combined with a magnetic field entering perpendicularly to the plane of the paper. If a positively charged particle enters the velocity selector from the left side at a horizontal speed \\( v \\), the particle experiences a downward electrostatic force and an upward magnetic force. When the net force equals zero, the particle progresses at a constant speed, where:\n$$\nqE = qvB \\Rightarrow v = \\frac{E}{B} = \\frac{V}{Bd}\n$$\n\nIf a barrier with only a small hole is added on the right side, only particles moving straight to the right can pass through. By altering the values of the electric and magnetic fields, the velocity of the particles passing through the device can be controlled. There are two programs included:\n\n- Program 20-1: Displays the electric field, magnetic field, parallel charged plates, and the trajectory of the particle. The particle stops when it hits the parallel charged plates.\n- Program 20-2: Based on 20-1, adds a barrier at the exit.\n\nProgram to be written: 20-1: Display the electric field, magnetic field, parallel charged plates, and the trajectory of the particle. The particle stops when it hits the parallel charged plates.\n\nVelocity Selector Structural Diagram:\n![image](https://hackmd.io/_uploads/HJlvr2auR.png)\n\n## Parameter Settings\n\nVariables are set as size, m, v0, q, V, d, L, B, E_field, B_field, t, dt, with their purposes noted in the comments of each line. To ensure smoother animation, the particle's mass is set much larger than the actual mass of a nucleus.\n\n## Display Settings\n\nGenerates an animation window, parallel charged plates, horizontal line, and charged particle.\n\nGenerates arrows representing velocity and acceleration.\n\nGenerates arrows and labels for the electric and magnetic fields. The syntax for labels is:\n\n[label_name] = label(pos=[position vector], text=\"[label content]\", xoffset=[x-direction offset], yoffset=[y-direction offset], color=[color name or RGB value], font=\"[font name]\")\nReplace the content in [] with the required parameters.\n\nOpens a drawing window, plots the position, velocity, acceleration, and time relationship of the small sphere.\n\n## Simulation of Motion\n\nTo stop the animation when the charged particle reaches the far right of the screen or hits the parallel charged plates, set the condition in the while loop as charge.pos.x < L and abs(charage.pos.y) < d/2 - p1.height - size.\n\nCalculates the net force on the charged particle, as only within the parallel charged plates are there electric and magnetic fields, set to zero outside. The mathematical expression for the net force is:\n$$\n\\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B})\n$$\nCorresponding code:\nF = q*(E_field + cross(charge.v, B_field))\nUpdates the charged particle's acceleration, velocity, and position.\n\nUpdates arrows representing velocity and acceleration, only displaying direction to avoid automatic resizing of the animation.\n\nUpdates time.\n\n## Simulation Results\n\nBelow are 5 different data combinations and their test results:\n\n1. v0 = 10, V = 1, d = 0.1, B = 1 \u21d2 Straight line motion at constant speed\n\nScreenshot:\n![image](https://hackmd.io/_uploads/r1w2B2TuC.png)\n\n2. q > 0, v0 = 20, other conditions same as combination 1 \u21d2 Upward shift\n\nScreenshot:\n![image](https://hackmd.io/_uploads/H1oaB26uC.png)\n\n3. q > 0, d = 0.2, other conditions same as combination 1 \u21d2 Upward shift\n\nScreenshot:\n![image](https://hackmd.io/_uploads/SyL1U36OC.png)\n\n4. q > 0, V = 2, other conditions same as combination 1 \u21d2 Downward shift\n\nScreenshot:\n![image](https://hackmd.io/_uploads/ByvlInp_R.png)\n\n5. q > 0, B = 5, other conditions same as combination 1 \u21d2 Upward shift\n\nScreenshot:\n![image](https://hackmd.io/_uploads/Bk1fLna_A.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nsize = 0.01                         # size of the charged particle\nm = 1E-19                           # mass of the charged particle\nv0 = 10                             # initial velocity of the charged particle\nq = 1E-19                           # charge of the charged particle\nV = 1                               # voltage applied to the parallel plates\nd = 0.1                             # distance between the parallel plates\nL = 0.5                             # length of the parallel plates\nB = 1                               # magnetic field strength\nE_field = vec(0, -V/d, 0)           # electric field\nB_field = vec(0, 0, B)              # magnetic field\nt = 0                               # initial time\ndt = 0.001                          # time step size\n\n# Display Settings\nscene = canvas(width=800, height=800, background=vec(0.5, 0.5, 0))   # animation window\np1 = box(pos=vec(-L/4, -d/4, 0), length=L/2, height=0.001, width=d/2, color=color.blue)   # lower plate\np2 = box(pos=vec(-L/4, d/4, 0), length=L/2, height=0.001, width=d/2, color=color.blue)    # upper plate\nline = curve(pos=[p1.pos, p2.pos], radius=0.001)                    # horizontal line\ncharge = sphere(pos=vec(-L/2-size, 0, 0), v=vec(v0, 0, 0), radius=size, m=m, q=q, color=color.red)   # charged particle\nv_a = arrow(pos=charge.pos, axis=charge.v, shaftwidth=0.01, color=color.green)   # velocity arrow\na_a = arrow(pos=charge.pos, axis=vec(0, 0, 0), shaftwidth=0.01, color=color.yellow)   # acceleration arrow\nE_a = arrow(pos=vec(-L/2, d/2, 0), axis=E_field, shaftwidth=0.01, color=color.magenta)   # electric field arrow\nB_a = arrow(pos=vec(-L/2, -d/2, 0), axis=B_field, shaftwidth=0.01, color=color.cyan)   # magnetic field arrow\nE_l = label(pos=E_a.pos, text='E', xoffset=-20, yoffset=-25, color=E_a.color, font='sans')   # electric field label\nB_l = label(pos=B_a.pos, text='B', xoffset=-20, yoffset=+25, color=B_a.color, font='sans')   # magnetic field label\ngd = graph(x=0, y=0, width=600, height=450, \n           xtitle='<i>t</i>', ytitle='blue: <i>x</i>, green: <i>v</i>, red: <i>a</i>', \n           foreground=color.black, background=color.white)   # graph display window\nx_t = gcurve(graph=gd, color=color.blue)   # x-t graph\nv_t = gcurve(graph=gd, color=color.green)   # v-t graph\na_t = gcurve(graph=gd, color=color.red)   # a-t graph\n\n# Simulation of Motion\nwhile charge.pos.x < L and abs(charge.pos.y) < d/2 - p1.height - size:\n    if abs(charge.pos.x) < L/2 and abs(charge.pos.y) < d/2:   # within the parallel plates\n        F = q*(E_field + cross(charge.v, B_field))   # net force\n    else:   # outside the parallel plates\n        F = vec(0, 0, 0)\n    charge.a = F/charge.m   # acceleration\n    charge.v += charge.a*dt   # velocity\n    charge.pos += charge.v*dt   # position\n    v_a.pos = a_a.pos = charge.pos   # update arrows' positions\n    v_a.axis = charge.v/abs(charge.v)*0.1   # update velocity arrow's direction\n    a_a.axis = charge.a/abs(charge.a)*0.1   # update acceleration arrow's direction\n    t += dt\n    x_t.plot(t, charge.pos.x)   # update x-t graph\n    v_t.plot(t, abs(charge.v))   # update v-t graph\n    a_t.plot(t, abs(charge.a))   # update a-t graph",
      "mode": "initial",
      "timestamp": "2024-07-24 07:12:27",
      "serial_number": 1
    }
  ]
}