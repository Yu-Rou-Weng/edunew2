{
  "session_id": 693,
  "log": [
    {
      "input": "Magnetic Field Generated by a Long Straight Current-Carrying Wire\n\nChapter 8 of elective physics, \"Magnetic Effects of Electric Current,\" introduces the Biot-Savart Law, which is used to calculate the magnetic field produced at a certain point in space by a small segment of a current-carrying wire. The equation is:\n$$\nd\\vec{B} = \\frac{\\mu_0}{4\\pi} \\frac{I d\\vec{L} \\times \\hat{r}}{r^2} \\Rightarrow dB = \\frac{\\mu_0}{4\\pi} \\frac{I dL \\sin{\\theta}}{r^2}\n$$\n\nUsing the Biot-Savart Law, one can calculate the magnitude of the magnetic field at a perpendicular distance \\(r\\) from a long straight current-carrying wire as:\n$$\nB = \\frac{\\mu_0 I}{2\\pi r}\n$$\n\nThe magnetic field magnitude at the center of a current-carrying loop with radius \\(r\\) is:\n$$\nB = \\frac{\\mu_0 I}{2r}\n$$\n\nThe magnetic field magnitude at the center of a solenoid with \\(n\\) turns per unit length carrying a current is:\n$$\nB = \\mu_0 n I\n$$\n\nMagnetic fields should be distributed in space, but the diagrams in the book are all in two dimensions, so I want to use VPython to graphically represent the magnetic field intensity and direction in space.\n\nParameter Settings\n\nVariables are set as size, n, L, d, mu, current, direct, N, and their purposes are noted in the comments. To enhance the visibility of the magnetic field arrows, a very large current value is set.\n\nDisplay Settings\nCreate an animation window and wire.\n\nCreate an empty list segs, and use a for loop to generate small spheres representing segments of the wire and fill them into the list segs. The following two methods have the same result; the first method is longer but easier to understand, while the second method is more concise but less clear.\n\nsegs = []\nfor i in range(n+1):\n    segs.append(sphere(pos=line.pos + vec(i*d, 0, 0), radius=size, color=color.cyan))\nsegs = [sphere(pos=line.pos + vec(i*d, 0, 0), radius=size, color=color.cyan) for i in range(n+1)]\nCreate an empty list locations, using a three-layer for loop to compute the positions for drawing arrows and add them to the list locations, with two similar methods as above.\n\nfields = []\nfor location in locations:\n    fields.append(arrow(pos=location, axis=vec(0, 0, 0), color=color.green))\nfields = [arrow(pos=location, axis=vec(0, 0, 0), color=color.green) for location in locations]\nCustom function magnetic, with input parameter loc specifying the position coordinates where the magnetic field is to be calculated, and segments storing the segmented wire data, using the Biot-Savart Law to calculate the magnetic field.\n\nSequentially read elements from the list locations and generate arrows at corresponding positions.\n\nUpdate the length and direction of the arrows, record the maximum magnetic field strength Bmax; arrows are colored more red as the value approaches Bmax and more green as the value approaches zero.\n\nThe image to be drawn:\n![image](https://hackmd.io/_uploads/H1fL6hp_R.png)\n(1) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import sphere, color, vec, canvas, cylinder, arrow\n\n# Parameter Settings\nsize = 0.02\nn = 50\nL = 1.0\nd = L/n\nmu = 4*3.14*1E-7\ncurrent = 1.0E5\ndirect = vec(0, 1, 0)\nN = 15\n\n# Create animation window and wire\nc = canvas(background=color.white)\nline = cylinder(pos=vec(-L/2, 0, 0), axis=vec(L, 0, 0), radius=size, color=color.red)\n\n# Generate small spheres representing segments of the wire\nsegs = [sphere(pos=line.pos + vec(i*d, 0, 0), radius=size, color=color.cyan) for i in range(n+1)]\n\n# Compute the positions for drawing arrows\nlocations = [line.pos + vec(i*d, j*d, k*d) for i in range(-N, N) for j in range(-N, N) for k in range(-N, N)]\n\n# Create arrows at corresponding positions\nfields = [arrow(pos=location, axis=vec(0, 0, 0), color=color.green) for location in locations]\n\n# Custom function magnetic\ndef magnetic(loc, segments):\n    B = vec(0, 0, 0)\n    for seg in segments:\n        r = loc - seg.pos\n        dB = (mu/4/3.14) * (current*d*direct.cross(r.norm()))/r.mag2\n        B = B + dB\n    return B\n\n# Update the length and direction of the arrows\nBmax = 0\nfor f in fields:\n    B = magnetic(f.pos, segs)\n    if B.mag > Bmax:\n        Bmax = B.mag\n    f.axis = B\n    f.length = B.mag*0.2\n    f.color = vec(1, 1-B.mag/Bmax, 1-B.mag/Bmax)",
      "mode": "initial",
      "timestamp": "2024-07-24 10:56:45",
      "serial_number": 1
    }
  ]
}