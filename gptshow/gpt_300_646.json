{
  "session_id": 646,
  "log": [
    {
      "input": "Simple Harmonic Motion Caused by Electrostatic Force (Placed to the Right of the Midpoint of the Line Connecting the Centers)\n\nPreviously, we discussed simple harmonic motion caused by gravity in \"Gravity and Simple Harmonic Motion.\" When we study electrostatic forces, we find that Coulomb's law is similar in form to Newton's law of universal gravitation. Therefore, electrostatic forces should also be able to produce a similar motion pattern. Here are 3 different scenarios:\n\n19-1. Two fixed charged spheres, with a movable charged sphere placed to the right of the midpoint on the line connecting their centers (Animation link on GlowScript website)\n19-2. Two fixed charged spheres, with a movable charged sphere placed above the perpendicular bisector (Animation link on GlowScript website)\n19-3. Modify the charged sphere in 19-2 to a ring, with a movable charged sphere placed above the perpendicular bisector (Animation link on GlowScript website)\n\n## Program 19-1\n\n### Theoretical Derivation\n\nAs shown in the figure below, there are two point charges of $+Q$, fixed in position at a distance of $2d$ apart. At a distance $x$ to the left of the midpoint on the line connecting their centers, there is a point charge of $+q$ with mass $m$.\n![image](https://hackmd.io/_uploads/SyxfG3TdR.png)\n\nIf the velocity of $+q$ is zero at this point and $x \\ll d$, considering only the electrostatic forces between the objects, then the resultant force on $+q$ is directed to the right and its magnitude is:\n$$\nF = k \\frac{Qq}{(d - x)^2} - k \\frac{Qq}{(d + x)^2} = kQq \\left[ \\frac{1}{(d + x)^2} - \\frac{1}{(d - x)^2} \\right]\n$$\n\n$$\n= kQq \\left[ \\frac{(d - x)^2 - (d + x)^2}{(d - x)^2 (d + x)^2} \\right]\n$$\n\n$$\n= kQq \\left[ \\frac{4dx}{d^4 (1 - \\frac{x}{d})^2 (1 + \\frac{x}{d})^2} \\right] \\approx \\frac{4kQq}{d^3} \\cdot x = Kx\n$$\n\nThus, $+q$ undergoes simple harmonic motion with the period:\n$$\nT = 2\\pi \\sqrt{\\frac{m}{K}} = 2\\pi \\sqrt{\\frac{md^3}{4kQq}} = \\pi \\sqrt{\\frac{md^3}{kQq}}\n$$\n\nThe following graph, drawn for $Q = q = 2 \\times 10^4 \\, C$, shows the relationship between electrostatic force F and distance x. It can be seen that when x is very small, $F \\propto x$ and the slope is approximately 1.5, which is consistent with the theoretical value.\n\nElectrostatic Force F - Distance x Relationship Graph (0 \u2264 x \u2264 9):\n![image](https://hackmd.io/_uploads/ByZXzh6_R.png)\n\nElectrostatic Force F - Distance x Relationship Graph (0 \u2264 x \u2264 4):\n![image](https://hackmd.io/_uploads/ryXVG36_A.png)\n\nParameter Settings\nVariables such as Q, q, m, size, d, h, k, i, t, dt are set, with their purposes noted in the comments.\n\nScreen Settings\nPlace the large spheres at (-d, 0, 0) and (d, 0, 0), place the small sphere at (h, 0, 0) with an initial velocity of 0 and mass m.\n\nDraw a line between the large spheres. The initial position of the small sphere is at the right endpoint, so the left endpoint should be at x = -h. Draw a line marker at the endpoint.\n\nGenerate arrows representing velocity and acceleration. To prevent the arrows from overlapping, draw them at distances of 1 and 2 above the small sphere.\n\nOpen the drawing window to plot the relationships of the small sphere's position, velocity, acceleration, and time.\n\nObject Motion\nTo stop the animation after the small sphere moves back and forth 5 times, set the condition in the while loop as i < 5, and use if(ball.pos.x >= h and ball.v.x >= 0) to determine if the small sphere has returned to the starting point. If it has, print the elapsed time t and the number of times it has returned to the starting point.\n\nUse Coulomb's law to calculate the resultant force F on the small sphere, then calculate the acceleration from F = ma, and update the velocity and position.\n\nScreenshot of Program 19-1:\n![image](https://hackmd.io/_uploads/rJzSG3aO0.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\nk = 9e9\nQ = 2e-6\nq = 2e-6\nm = 1e-3\nd = 0.1\nh = 0.01\ni = 0\nt = 0\ndt = 0.001\n\nscene = canvas(width=800, height=800, align='left')\ng1 = graph(width=600, height=450, xmax=0.2, xtitle='t', ytitle='blue:pos, green:vel, red:acc', align='right')\n\nball = sphere(pos=vector(h, 0, 0), radius=Radius_I, color=color.red)\nball.m = m\nball.v = vector(0, 0, 0)\n\nc1 = sphere(pos=vector(-d, 0, 0), radius=0.02, color=color.blue)\nc2 = sphere(pos=vector(d, 0, 0), radius=0.02, color=color.blue)\n\nline = curve(pos=[c1.pos, c2.pos], color=color.yellow)\npointer = arrow(pos=vector(-h, 0, 0), axis=vector(h, 0, 0), shaftwidth=0.01, color=color.white)\n\nv_pointer = arrow(pos=ball.pos + vector(0, 1, 0), color=color.green, shaftwidth=0.01)\na_pointer = arrow(pos=ball.pos + vector(0, 2, 0), color=color.red, shaftwidth=0.01)\n\nx_t = gcurve(graph=g1, color=color.blue)\nv_t = gcurve(graph=g1, color=color.green)\na_t = gcurve(graph=g1, color=color.red)\n\nwhile i < 5:\n    rate(1000)\n    r1 = ball.pos - c1.pos\n    r2 = ball.pos - c2.pos\n    F1 = k * Q * q * r1.hat / mag2(r1)\n    F2 = k * Q * q * r2.hat / mag2(r2)\n    F = F1 + F2\n    ball.a = F / ball.m\n    ball.v = ball.v + ball.a * dt\n    ball.pos = ball.pos + ball.v * dt\n    pointer.axis = ball.pos\n    v_pointer.pos = ball.pos + vector(0, 1, 0)\n    v_pointer.axis = ball.v / 2\n    a_pointer.pos = ball.pos + vector(0, 2, 0)\n    a_pointer.axis = ball.a / 2\n    x_t.plot(pos=(t, ball.pos.x))\n    v_t.plot(pos=(t, ball.v.x))\n    a_t.plot(pos=(t, ball.a.x))\n    if ball.pos.x >= h and ball.v.x >= 0:\n        i = i + 1\n        print(\"t = \", t, \"i = \", i)\n    t = t + dt",
      "mode": "initial",
      "timestamp": "2024-07-24 06:47:08",
      "serial_number": 1
    },
    {
      "input": "Please update the program by fixing the following error:\nRadius_I is not defined\n\nHere's the current program:\nRadius_I = 1\n# \u4ee5\u4e0a\u8b8a\u6578\u8b80\u53d6\u611f\u6e2c\u5668\u5f8c\u6703\u81ea\u52d5\u66f4\u65b0\n\n\n# \u8acb\u52ff\u4fee\u6539\u4e0a\u65b9\u7a0b\u5f0f\u78bc\n\nfreq = 120        # \u66f4\u65b0\u983b\u7387(Hz)\n\n# \u521d\u59cb\u5316\u5834\u666f\ndef scene_init():\n    global label_info\n    scene = display(width=800, height=700, center=vector(10, 15, 0), background=vector(0.5, 0.5, 0))\n    label_info = label(pos=vec(10, 20, 0), text='')\n\n# \u6bcf\u79d2\u9418\u66f4\u65b0\u986f\u793a\u6578\u64da\ndef update_info():\n    global label_info\n    label_info.text = 'Radius_I: {} \\n'.format(Radius_I)\n\nscene_init()\n\ncnt = 0\nwhile True:\n    rate(freq)\n    cnt = cnt + 1\n    if cnt % (freq // 5) == 0:\n        update_info()",
      "output": "from vpython import *\n\nk = 9e9\nQ = 2e-6\nq = 2e-6\nm = 1e-3\nd = 0.1\nh = 0.01\ni = 0\nt = 0\ndt = 0.001\nRadius_I = 1\n\nscene = canvas(width=800, height=800, align='left')\ng1 = graph(width=600, height=450, xmax=0.2, xtitle='t', ytitle='blue:pos, green:vel, red:acc', align='right')\n\nball = sphere(pos=vector(h, 0, 0), radius=Radius_I, color=color.red)\nball.m = m\nball.v = vector(0, 0, 0)\n\nc1 = sphere(pos=vector(-d, 0, 0), radius=0.02, color=color.blue)\nc2 = sphere(pos=vector(d, 0, 0), radius=0.02, color=color.blue)\n\nline = curve(pos=[c1.pos, c2.pos], color=color.yellow)\npointer = arrow(pos=vector(-h, 0, 0), axis=vector(h, 0, 0), shaftwidth=0.01, color=color.white)\n\nv_pointer = arrow(pos=ball.pos + vector(0, 1, 0), color=color.green, shaftwidth=0.01)\na_pointer = arrow(pos=ball.pos + vector(0, 2, 0), color=color.red, shaftwidth=0.01)\n\nx_t = gcurve(graph=g1, color=color.blue)\nv_t = gcurve(graph=g1, color=color.green)\na_t = gcurve(graph=g1, color=color.red)\n\nwhile i < 5:\n    rate(1000)\n    r1 = ball.pos - c1.pos\n    r2 = ball.pos - c2.pos\n    F1 = k * Q * q * r1.hat / mag2(r1)\n    F2 = k * Q * q * r2.hat / mag2(r2)\n    F = F1 + F2\n    ball.a = F / ball.m\n    ball.v = ball.v + ball.a * dt\n    ball.pos = ball.pos + ball.v * dt\n    pointer.axis = ball.pos\n    v_pointer.pos = ball.pos + vector(0, 1, 0)\n    v_pointer.axis = ball.v / 2\n    a_pointer.pos = ball.pos + vector(0, 2, 0)\n    a_pointer.axis = ball.a / 2\n    x_t.plot(pos=(t, ball.pos.x))\n    v_t.plot(pos=(t, ball.v.x))\n    a_t.plot(pos=(t, ball.a.x))\n    if ball.pos.x >= h and ball.v.x >= 0:\n        i = i + 1\n        print(\"t = \", t, \"i = \", i)\n    t = t + dt",
      "mode": "fix_error",
      "timestamp": "2024-07-24 06:47:37",
      "serial_number": 2
    },
    {
      "input": "Please update the program by fixing the following error:\nRadius_I is not defined\n\nHere's the current program:\nfrom vpython import *\n\nk = 9e9\nQ = 2e-6\nq = 2e-6\nm = 1e-3\nd = 0.1\nh = 0.01\ni = 0\nt = 0\ndt = 0.001\n\nscene = canvas(width=800, height=800, align='left')\ng1 = graph(width=600, height=450, xmax=0.2, xtitle='t', ytitle='blue:pos, green:vel, red:acc', align='right')\n\nball = sphere(pos=vector(h, 0, 0), radius=Radius_I, color=color.red)\nball.m = m\nball.v = vector(0, 0, 0)\n\nc1 = sphere(pos=vector(-d, 0, 0), radius=0.02, color=color.blue)\nc2 = sphere(pos=vector(d, 0, 0), radius=0.02, color=color.blue)\n\nline = curve(pos=[c1.pos, c2.pos], color=color.yellow)\npointer = arrow(pos=vector(-h, 0, 0), axis=vector(h, 0, 0), shaftwidth=0.01, color=color.white)\n\nv_pointer = arrow(pos=ball.pos + vector(0, 1, 0), color=color.green, shaftwidth=0.01)\na_pointer = arrow(pos=ball.pos + vector(0, 2, 0), color=color.red, shaftwidth=0.01)\n\nx_t = gcurve(graph=g1, color=color.blue)\nv_t = gcurve(graph=g1, color=color.green)\na_t = gcurve(graph=g1, color=color.red)\n\nwhile i < 5:\n    rate(1000)\n    r1 = ball.pos - c1.pos\n    r2 = ball.pos - c2.pos\n    F1 = k * Q * q * r1.hat / mag2(r1)\n    F2 = k * Q * q * r2.hat / mag2(r2)\n    F = F1 + F2\n    ball.a = F / ball.m\n    ball.v = ball.v + ball.a * dt\n    ball.pos = ball.pos + ball.v * dt\n    pointer.axis = ball.pos\n    v_pointer.pos = ball.pos + vector(0, 1, 0)\n    v_pointer.axis = ball.v / 2\n    a_pointer.pos = ball.pos + vector(0, 2, 0)\n    a_pointer.axis = ball.a / 2\n    x_t.plot(pos=(t, ball.pos.x))\n    v_t.plot(pos=(t, ball.v.x))\n    a_t.plot(pos=(t, ball.a.x))\n    if ball.pos.x >= h and ball.v.x >= 0:\n        i = i + 1\n        print(\"t = \", t, \"i = \", i)\n    t = t + dt",
      "output": "from vpython import *\n\nk = 9e9\nQ = 2e-6\nq = 2e-6\nm = 1e-3\nd = 0.1\nh = 0.01\ni = 0\nt = 0\ndt = 0.001\nRadius_I = 0.02\n\nscene = canvas(width=800, height=800, align='left')\ng1 = graph(width=600, height=450, xmax=0.2, xtitle='t', ytitle='blue:pos, green:vel, red:acc', align='right')\n\nball = sphere(pos=vector(h, 0, 0), radius=Radius_I, color=color.red)\nball.m = m\nball.v = vector(0, 0, 0)\n\nc1 = sphere(pos=vector(-d, 0, 0), radius=0.02, color=color.blue)\nc2 = sphere(pos=vector(d, 0, 0), radius=0.02, color=color.blue)\n\nline = curve(pos=[c1.pos, c2.pos], color=color.yellow)\npointer = arrow(pos=vector(-h, 0, 0), axis=vector(h, 0, 0), shaftwidth=0.01, color=color.white)\n\nv_pointer = arrow(pos=ball.pos + vector(0, 1, 0), color=color.green, shaftwidth=0.01)\na_pointer = arrow(pos=ball.pos + vector(0, 2, 0), color=color.red, shaftwidth=0.01)\n\nx_t = gcurve(graph=g1, color=color.blue)\nv_t = gcurve(graph=g1, color=color.green)\na_t = gcurve(graph=g1, color=color.red)\n\nwhile i < 5:\n    rate(1000)\n    r1 = ball.pos - c1.pos\n    r2 = ball.pos - c2.pos\n    F1 = k * Q * q * r1.hat / mag2(r1)\n    F2 = k * Q * q * r2.hat / mag2(r2)\n    F = F1 + F2\n    ball.a = F / ball.m\n    ball.v = ball.v + ball.a * dt\n    ball.pos = ball.pos + ball.v * dt\n    pointer.axis = ball.pos\n    v_pointer.pos = ball.pos + vector(0, 1, 0)\n    v_pointer.axis = ball.v / 2\n    a_pointer.pos = ball.pos + vector(0, 2, 0)\n    a_pointer.axis = ball.a / 2\n    x_t.plot(pos=(t, ball.pos.x))\n    v_t.plot(pos=(t, ball.v.x))\n    a_t.plot(pos=(t, ball.a.x))\n    if ball.pos.x >= h and ball.v.x >= 0:\n        i = i + 1\n        print(\"t = \", t, \"i = \", i)\n    t = t + dt",
      "mode": "fix_error",
      "timestamp": "2024-07-24 06:47:38",
      "serial_number": 3
    }
  ]
}