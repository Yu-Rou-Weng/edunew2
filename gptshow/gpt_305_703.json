{
  "session_id": 703,
  "log": [
    {
      "input": "# Electron Charge-to-Mass Ratio\n\nThe experimental setup for measuring the electron charge-to-mass ratio is shown below. Its appearance and velocity selector are very similar; therefore, by slightly modifying the \"Velocity Selector\" program, we can create an animation for the electron charge-to-mass ratio experiment.\n### Schematic Diagram of the Experimental Setup\n![image](https://hackmd.io/_uploads/SkTFu36OR.png)\n\n## Theoretical Analysis\n\nReferring to the diagram above, the particle has a mass $m$ and charge $q$, and enters a downward uniform electric field $E$ with a horizontal velocity $v_0$. The length of the parallel charged plates is $L$, and the distance between the right side of the parallel plates and the screen is $D$. If only considering the electrostatic force, the particle\u2019s upward acceleration in the electric field is\n$$\na = \\frac{qE}{m}\n$$\n\nThere is no external force horizontally, and it moves at a constant speed; thus, the time spent in the electric field is\n$$\nt_1 = \\frac{L}{v_0}\n$$\n\nThe upward displacement is\n$$\ny_1 = \\frac{1}{2} a t_1^2 = \\frac{1}{2} \\left( \\frac{qE}{m} \\right) \\left( \\frac{L}{v_0} \\right)^2\n$$\n\nThe upward velocity of the particle upon leaving the electric field is\n$$\nv_{y1} = a t_1 = \\frac{qEL}{mv_0}\n$$\n\nOutside the electric field where the particle is not subjected to external forces, it moves in a straight line at constant speed. The time it moves outside the electric field is\n$$\nt_2 = \\frac{D}{v_0}\n$$\n\nThe upward displacement is\n$$\ny_2 = v_{y1} t_2 = \\left( \\frac{qEL}{mv_0} \\right) \\left( \\frac{D}{v_0} \\right) = \\frac{qELD}{mv_0^2}\n$$\n\nThe total upward displacement is\n$$\ny = y_1 + y_2 = \\frac{qE}{2m} \\left( \\frac{L^2}{v_0^2} \\right) + \\frac{qELD}{mv_0^2} = \\frac{qEL(L + 2D)}{2mv_0^2}\n$$\n\nThe charge-to-mass ratio of the charged particle is\n$$\n\\frac{q}{m} = \\frac{2yv_0^2}{E L (L + 2D)}\n$$\n\nThe electric field strength can be determined by the voltage and distance between parallel charged plates, and the initial speed $v_0$ of the particle can be controlled by the velocity selector, thus all data except the charge-to-mass ratio can be measured in the experiment.\n\nParameter Setting\n\nVariables are set for size, m, v0, q, V, d, L, E_field, t, dt, and their purposes are noted in the comments of each line. To make the animation smoother, the charge and mass of the particles are intentionally set much higher.\n\nScreen Setup\nCreate an animation window, parallel charged plates, a horizontal line, and a charged particle. The parallel charged plates are located between -L < x < 0.\n\nGenerate arrows and labels representing the electric and magnetic fields.\n\nGenerate arrows representing velocity and acceleration.\n\nObject Motion\nTo stop the animation when the charged particle reaches the screen or hits the parallel charged plates, set the condition in the while loop as 0 < charge.pos.x < screen.pos.x - screen.length/2 - size or (charge.pos.x < 0 and abs(charge.pos.y) < d/2 - p1.height - size)\n(a) Function of the first set of conditions: When the particle is between the electric field and the screen, the animation continues.\n(b) Function of the second set of conditions: When the particle is in the electric field and does not hit the parallel charged plates, the animation continues.\n\nCalculate the resultant force on the charged particle; the electric field is only present between the parallel charged plates and set to zero outside.\n\nUpdate the charged particle's acceleration, velocity, and position.\n\nUpdate the arrows representing velocity and acceleration, only showing direction to avoid automatic resizing of the animation.\n\nTo draw a horizontal line when the charged particle leaves the parallel charged plates, define variables xp and xc, where xp is the particle's position at the previous moment and xc is the current position. If xp < 0 and xc > 0, it means the particle has just left the parallel charged plates; use the cylinder command to draw the parallel line.\n\nUpdate the time.\n\nSimulation Results\n\nBelow are six different data combinations and test results:\n\n1. v0 = 20, q = -2 \u00d7 10^-9, V = 1, d = 0.1 \u21d2 Hits the parallel charged plates upward\n![image](https://hackmd.io/_uploads/B1w6O2TdR.png)\n\n2. q = -1 \u00d7 10^-9, other conditions same as combination 1 \u21d2 Upward but does not hit the parallel charged plates\n![image](https://hackmd.io/_uploads/Bkoa_naOC.png)\n\n3. v0 = 25, other conditions same as combination 1 \u21d2 Upward but does not hit the parallel charged plates\n![image](https://hackmd.io/_uploads/S11AunauA.png)\n\n4. q = 2 \u00d7 10^-9, other conditions same as combination 1 \u21d2 Hits the parallel charged plates downward\n![image](https://hackmd.io/_uploads/S1NROhpO0.png)\n\n5. q = 1 \u00d7 10^-9, other conditions same as combination 1 \u21d2 Downward but does not hit the parallel charged plates\n![image](https://hackmd.io/_uploads/ryY0OnTu0.png)\n\n6. v0 = 25, q = 2 \u00d7 10^-9, other conditions same as combination 1 \u21d2 Downward but does not hit the parallel charged plates\n![image](https://hackmd.io/_uploads/rJpRO3TO0.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Setting\nsize = 0.3\nRadius_I = 1\nv0 = 20\nq = -2e-9\nm = 1e-9\nV = 1\nd = 0.1\nL = 2\nD = 1\nE_field = vector(0, -V/d, 0)\nt = 0\ndt = 1e-3\n\n# Screen Setup\nscene = canvas(width=600, height=500, center=vector((L + D) / 2, -d / 3, 0), background=color.black)\nscreen = box(pos=vector(L + D, 0, 0), size=vector(0.01, d, d), color=color.green)\np1 = box(pos=vector(-L / 2, d / 2, 0), size=vector(L, 0.01, d), color=color.blue)\np2 = box(pos=vector(-L / 2, -d / 2, 0), size=vector(L, 0.01, d), color=color.blue)\ncharge = sphere(radius=Radius_I, color=color.red, pos=vector(0, 0, 0), v=vector(v0, 0, 0), a=vector(0, q * E_field.y / m, 0))\n\n# Generate arrows and labels\nE_arrow = arrow(pos=vector(-L / 2, 0, 0), axis=vector(0, -1, 0), color=color.yellow)\nB_arrow = arrow(pos=vector(-L / 2, 0, d / 2), axis=vector(0, 0, 1), color=color.cyan)\nv_arrow = arrow(pos=charge.pos, axis=charge.v, color=color.red)\na_arrow = arrow(pos=charge.pos, axis=charge.a, color=color.white)\nE_label = label(pos=E_arrow.pos, text='E', xoffset=20, yoffset=-20, space=30, height=16, border=4, font='sans')\nB_label = label(pos=B_arrow.pos, text='B', xoffset=20, yoffset=-20, space=30, height=16, border=4, font='sans')\n\n# Object Motion\nwhile (0 < charge.pos.x < screen.pos.x - screen.length / 2 - Radius_I) or (charge.pos.x < 0 and abs(charge.pos.y) < d / 2 - p1.height - Radius_I):\n    rate(1000)\n    if charge.pos.x < 0:\n        charge.a = vector(0, q * E_field.y / m, 0)\n    else:\n        charge.a = vector(0, 0, 0)\n    charge.v += charge.a * dt\n    charge.pos += charge.v * dt\n    v_arrow.pos = charge.pos\n    v_arrow.axis = charge.v / 3\n    a_arrow.pos = charge.pos\n    a_arrow.axis = charge.a / 3\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 12:22:23",
      "serial_number": 1
    }
  ]
}