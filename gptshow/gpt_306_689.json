{
  "session_id": 689,
  "log": [
    {
      "input": "The Motion of Charged Particles in a Magnetic Field\n\nThe magnetic force acting on a charged particle in a uniform magnetic field is given by:\n$$\n\\vec{F}_B = q (\\vec{v} \\times \\vec{B}) \\Rightarrow F_B = qvB \\sin{\\theta}\n$$\nwhere $q$ is the charge of the particle, $v_0$ is the particle\u2019s velocity, and $B$ is the external magnetic field. There are three possible types of motion:\n\n- $\\theta = 0^\\circ$ or $180^\\circ$: $F_B = 0$, motion is a constant velocity in a straight line.\n- $\\theta = 90^\\circ$: $F_B = qvB$, motion is a constant speed circular motion.\n- Other angles: Helical motion, moving forward while circling.\n\nThe goal is to illustrate these three types of motion, with the animation window's viewpoint automatically adjusting to facilitate observation based on the angle between velocity and magnetic field.\n\nHelical motion diagram:\n![image](https://hackmd.io/_uploads/BkS9t3TuC.png)\n\nParameter Settings\n\nVariables such as size, m, theta, phi, v0, q, L, B_field, t, and dt are defined and initialized, with their purposes noted in the comments. To ensure smoother animation, the charge and mass of the particle are intentionally increased significantly.\n\nScreen Settings\n- Create an animation window, adjusting the viewpoint based on theta and phi. If theta == pi/2 or phi == pi/2, view from (L, L/4, L/4) towards the origin; otherwise, view from (L/4, L/4, L) towards the origin.\n- Create a charged particle and set its initial velocity.\n- Create coordinate axes and labels.\n- Create arrows and labels representing the magnetic field.\n- Create arrows for velocity and acceleration.\n\nObject Motion\n- Aiming for the particle to move only within a cubic space with side length 1.2 L, the while loop conditions are set as abs(charge.pos.x) < 0.6*L and abs(charge.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L.\n- Calculate the resultant force on the charged particle, update the particle\u2019s acceleration, velocity, and position.\n- Update the arrows representing velocity and acceleration, drawing only their directions to prevent automatic scaling of the animation.\n- Update time.\n\nSimulation Results\n\nHere are five different sets of data and their corresponding test results:\n\n1. theta = 0, phi = 0 \u21d2 Velocity has only an x-component, moving at constant velocity along the x-axis.\n![image](https://hackmd.io/_uploads/BJdk9hauA.png)\n\n2. theta = 90, phi = 0 \u21d2 Velocity lacks an x-component, performing constant speed circular motion in the yz-plane.\n![image](https://hackmd.io/_uploads/Hy31qhpOA.png)\n\n3. theta = 0, phi = 90 \u21d2 Velocity lacks an x-component, performing constant speed circular motion in the yz-plane.\n![image](https://hackmd.io/_uploads/SJfxcnpu0.png)\n\n4. theta = 80, phi = 10 \u21d2 Velocity forms an angle other than 0 or 180 degrees with the x-axis, resulting in helical motion.\n![image](https://hackmd.io/_uploads/S1wlcnadC.png)\n\n5. theta = 100, phi = 10 \u21d2 Velocity forms an angle other than 0 or 180 degrees with the x-axis, resulting in helical motion.\n![image](https://hackmd.io/_uploads/Skal5nau0.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nsize = 0.01\nm = 1E-11\nRadius_I = 1\ntheta = 0\nphi = 0\nv0 = 0.05\nq = 5E-5\nL = 1\nB_field = vec(0,0,1)\nt = 0\ndt = 0.001\n\n# Screen Settings\nscene = canvas(width=800, height=800, center=vec(0,0,0), background=vec(0.5,0.5,0))\ncharge = sphere(pos=vec(-0.5*L,0,0), radius=Radius_I*size, m=m, q=q, v=v0*vec(cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta)), a=vec(0,0,0), color=color.red)\nB_arrow = arrow(pos=vec(-0.5*L,0.5*L,-0.5*L), axis=0.8*L*B_field, shaftwidth=0.01, color=color.blue)\nB_label = label(pos=vec(-0.5*L,0.5*L,-0.5*L), text='B', xoffset=20, yoffset=-20, space=0, height=16, border=6, font='sans')\nv_arrow = arrow(pos=charge.pos, axis=0.1*charge.v, shaftwidth=0.01*L, color=color.green)\nv_label = label(pos=charge.pos+0.1*charge.v, text='v', xoffset=20, yoffset=-20, space=0, height=16, border=6, font='sans')\na_arrow = arrow(pos=charge.pos, axis=0.1*charge.a, shaftwidth=0.01*L, color=color.orange)\na_label = label(pos=charge.pos+0.1*charge.a, text='a', xoffset=20, yoffset=-20, space=0, height=16, border=6, font='sans')\n\n# Coordinate Axes and Labels\naxes = [arrow(pos=vec(-0.6*L,0,0), axis=vec(0.2*L,0,0), shaftwidth=0.01*size, color=color.black),\n        arrow(pos=vec(0,-0.6*L,0), axis=vec(0,0.2*L,0), shaftwidth=0.01*size, color=color.black),\n        arrow(pos=vec(0,0,-0.6*L), axis=vec(0,0,0.2*L), shaftwidth=0.01*size, color=color.black)]\naxes_label = [label(pos=vec(-0.4*L,0,0), text='x', xoffset=10, box=0),\n              label(pos=vec(0,-0.4*L,0), text='y', yoffset=-10, box=0),\n              label(pos=vec(0,0,-0.4*L), text='z', yoffset=-10, box=0)]\n\n# Object Motion\nwhile abs(charge.pos.x) < 0.6*L and abs(charge.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L:\n    rate(1000)\n    F = q*cross(charge.v, B_field)\n    charge.a = F/charge.m\n    charge.v += charge.a*dt\n    charge.pos += charge.v*dt\n    v_arrow.pos = charge.pos\n    v_arrow.axis = 0.1*charge.v\n    v_label.pos = charge.pos + 0.1*charge.v\n    a_arrow.pos = charge.pos\n    a_arrow.axis = 0.1*charge.a\n    a_label.pos = charge.pos + 0.1*charge.a\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 10:33:01",
      "serial_number": 1
    }
  ]
}