{
  "session_id": 627,
  "log": [
    {
      "input": "Program to be Written: Planetary Motion, Using a Dictionary to Store Planetary Data\n\nKepler's Laws of Planetary Motion consist of the following three laws:\n\n1. **First Law (The Law of Orbits)**: The orbits of planets around the sun are ellipses, with the sun at one of the focal points.\n\n2. **Second Law (The Law of Equal Areas)**: The area swept by the line connecting a planet and the sun in a unit of time is constant. If the distance between the sun and the planet is $r$, the velocity of the planet is $v$, and the angle between $r$ and $v$ is $\\theta$, then the area swept by the line in a unit of time is\n   $$\n   \\frac{\\Delta A}{\\Delta t} = \\frac{1}{2} rv \\sin{\\theta} = \\text{constant}\n   $$\n\n3. **Third Law (The Law of Periods)**: For all planets orbiting the sun, the relationship between the orbit's period $T$ and the average radius $a$ of the orbit is\n   $$\n   \\frac{a^3}{T^2} = \\text{constant}\n   $$\n\nThe first law is due to the fact that only gravitational forces act between the sun and the stars, and according to the law of universal gravitation, only ellipses are stable orbits. The second law is because gravity acts through the sun, thus conserving the angular momentum of the planet relative to the sun, which means the area swept by the line connecting the planet and the sun is constant. The third law can be derived using the law of gravitation as the centripetal force. Using real data from the solar system, these three laws can likely be illustrated.\n\nParameter Setting\n\nA dictionary in Python is a special format for storing data. Suppose a dictionary named data is defined with the syntax:\n\ndata = {\"key1\": value1, \"key2\": value2, ...}\nSingle or double quotes can be used as long as they are used in pairs. Each key corresponds to a piece of data, which can be any format, but each key must be unique and not repeated. To call the data corresponding to \"key2\", the syntax is:\n\ndata[\"key2\"]\nFor example, in the program:\n\nradius = {\"Mercury\": 2439700, \"Venus\": 6051800, \"Earth\": 6371000, \"Mars\": 3389500, \"Sun\": 696392000}\nIf you input radius[\"Sun\"], the system will output 696392000.\n\nVariables such as G, eps, t, dt are also set, and their purposes are noted in the comments.\n\nDisplay Settings\n\nWhen generating the sun, the last option is `emissive=True`, which is set to False by default, but if set to True, the sun will emit light.\n\nWhen generating Earth, set the material `texture=textures.earth`, as VPython has a built-in Earth texture, so there is no need to find an image. However, since the Earth object does not have a set color, the default color of its trail is white, but if you want to change it to blue, add `trail_color=color.blue`. To change the radius of the trail to `0.1*size`, add `trail_radius=0.1 * size`.\n\nTo make the sun emit light, in older versions of VPython, you would write:\n\nscene.lights = [local_light(pos=vec(0, 0, 0), color=color.white)]\nBut in VPython 7, this method is no longer supported, and instead, a light source is placed at the sun's position:\n\nlamp = local_light(pos=vec(0,0,0), color=color.white)\nGenerate arrows representing velocity and acceleration.\n\nThe part of the display settings is very similar to the program \"Planetary Motion\", but generating planet objects involves a slightly different approach, using a dictionary + name method to handle the data, such as setting the Earth's position at the aphelion using pos = vec(d_at_aphelion[\"Earth\"], 0, 0). This method makes the code for generating each planet virtually identical, only modifying the name of the planet to automatically find the corresponding data.\n\nObject Movement\n\nplanet.a = - G*sun.m / planet.pos.mag**n * planet.pos.norm()\nTo be able to change the exponent of distance in the law of universal gravitation, instead of using planet.pos.mag2 to calculate the square of the distance between the planet and the sun, planet.pos.mag**n is used to calculate the nth power of the distance. Then update the planet's velocity and position.\n\nUpdate the position, direction, and length of arrows representing velocity and acceleration; since the distances between the planets and the sun are very large, the arrows need to be enlarged to be visible.\n\nThe object movement part is very similar to the program \"Planetary Motion\", and since only two planets are depicted, just write the code to calculate acceleration, update velocity, and displacement for each planet once. Additionally, use an if statement to determine if the planet has returned near its starting point to calculate its period. Although this method is not very precise, it is still usable.\n(1) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\nG = 6.67408e-11 # gravitational constant\n\n# Solar system data\nmass = {\"Sun\": 1.989e30, \"Earth\": 5.972e24, \"Mars\": 0.64171e24}\nd_at_aphelion = {\"Earth\": 1.521e11, \"Mars\": 2.279e11} # Aphelion distance\nv_at_perihelion = {\"Earth\": 29.29e3, \"Mars\": 26.50e3} # Perihelion speed\n\n# Create solar system bodies\nsun = sphere(pos=vec(0, 0, 0), radius=6.9634e8, color=color.yellow, emissive=True, m=mass[\"Sun\"])\nearth = sphere(pos=vec(d_at_aphelion[\"Earth\"], 0, 0), radius=6.371e6, color=color.blue,\n               make_trail=True, trail_type='points', trail_color=color.blue, trail_radius=0.3, m=mass[\"Earth\"])\nmars = sphere(pos=vec(d_at_aphelion[\"Mars\"], 0, 0), radius=3.3895e6, color=color.red,\n              make_trail=True, trail_type='points', trail_color=color.red, trail_radius=0.3, m=mass[\"Mars\"])\n\n# Initial velocities\nearth.v = vec(0, v_at_perihelion[\"Earth\"], 0)\nmars.v = vec(0, v_at_perihelion[\"Mars\"], 0)\n\n# Create light source\nlamp = local_light(pos=vec(0,0,0), color=color.white)\n\n# Time settings\nt = 0\ndt = 60*60*24 # 1 day\n\nwhile True:\n    rate(1000)\n    for planet in [earth, mars]:\n        r = planet.pos - sun.pos\n        planet.a = -G * sun.m / mag(r)**2 * norm(r) # acceleration\n        planet.v += planet.a * dt # update velocity\n        planet.pos += planet.v * dt # update position\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 05:49:47",
      "serial_number": 1
    }
  ]
}