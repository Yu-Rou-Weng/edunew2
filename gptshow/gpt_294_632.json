{
  "session_id": 632,
  "log": [
    {
      "input": "# Three-Dimensional Elastic Collision, m1 = m2\n\nThis program primarily references the lecture notes \"VPhysics Freshman Course: Collision\" by Professor Ming-Feng Shih from the Department of Physics at National Taiwan University, but it rewrites the included code in the Python 3.X format. After completing this program, it can be used to simulate collisions between ideal gas molecules, producing a graph of molecule count versus velocity distribution. However, since the program is relatively complex, please refer to the VPython example program \"A hard-sphere gas.\"\n\nProgram to be written: Three-dimensional elastic collision, m1 = m2, both spheres have equal mass\n\n### Theoretical Derivation\n\nAssuming there are two elastic spheres of equal size in space, with masses $m_1$ and $m_2$, and initial velocities $v_1$ and $v_2$, derive the formula for their velocities after collision. The special case when the masses are equal is given by:\n\n$$\nv_1' = v_1 + \\frac{(v_2 - v_1) \\cdot (r_1 - r_2)}{|r_1 - r_2|^2} (r_1 - r_2)\n$$\n\n$$\nv_2' = v_2 + \\frac{(v_1 - v_2) \\cdot (r_2 - r_1)}{|r_2 - r_1|^2} (r_2 - r_1)\n$$\n\nProof:  \nAssuming the change in momentum during the collision for the two spheres is $\\Delta p$, then\n\n$$\n\\Delta p_1 = \\Delta p \\frac{r_1 - r_2}{|r_1 - r_2|}\n$$\n\n$$\n\\Delta p_2 = - \\Delta p_1 = \\Delta p \\frac{r_2 - r_1}{|r_2 - r_1|}\n$$\n\nThe momenta of the spheres after the collision are:\n\n$$\np_1' = p_1 + \\Delta p_1 \\Rightarrow m_1 v_1' = m_1 v_1 + \\Delta p \\frac{r_1 - r_2}{|r_1 - r_2|}\n$$\n\n$$\np_2' = p_2 + \\Delta p_2 \\Rightarrow m_2 v_2' = m_2 v_2 + \\Delta p \\frac{r_2 - r_1}{|r_2 - r_1|}\n$$\n\nSince the collision is elastic, there is no loss of kinetic energy before and after the collision:\n\n$$\n\\frac{1}{2} m_1 v_1^2 + \\frac{1}{2} m_2 v_2^2 = \\frac{1}{2} m_1 v_1'^2 + \\frac{1}{2} m_2 v_2'^2\n$$\n\nSubstituting $v_1'$ and $v_2'$ into the equation and multiplying by 2:\n\n$$\nm_1 v_1^2 + m_2 v_2^2 = m_1 \\left[ v_1 + \\Delta p \\frac{(r_1 - r_2)}{m_1 |r_1 - r_2|} \\right]^2 + m_2 \\left[ v_2 + \\Delta p \\frac{(r_2 - r_1)}{m_2 |r_2 - r_1|} \\right]^2\n$$\n\nSince $(r_1 - r_2)^2 = |r_1 - r_2|^2$, the equation simplifies to:\n\n$$\n2 \\Delta p \\frac{(v_1 - v_2) \\cdot (r_1 - r_2)}{|r_1 - r_2|} + (\\Delta p)^2 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) = 0\n$$\n\n$$\n2 \\frac{(v_1 - v_2) \\cdot (r_1 - r_2)}{|r_1 - r_2|} + \\Delta p \\frac{m_1 + m_2}{m_1 m_2} = 0\n$$\n\n$$\n\\Delta p = \\frac{2 m_1 m_2}{m_1 + m_2} \\frac{(v_2 - v_1) \\cdot (r_1 - r_2)}{|r_1 - r_2|}\n$$\n\nSubstituting into the formulas above, the velocities after collision are:\n\n$$\nv_1' = v_1 + \\frac{2 m_2}{m_1 + m_2} \\frac{(v_2 - v_1) \\cdot (r_1 - r_2)}{|r_1 - r_2|^2} (r_1 - r_2)\n$$\n\n$$\nv_2' = v_2 + \\frac{2 m_1}{m_1 + m_2} \\frac{(v_1 - v_2) \\cdot (r_2 - r_1)}{|r_2 - r_1|^2} (r_2 - r_1)\n$$\n\nScreenshot:\n![image](https://hackmd.io/_uploads/Hyuy9sTdR.png)\n\nParameter Settings\nSet variables such as the radius, mass, color, initial velocity of the sphere, screen size, time, and time interval. Refer to the variable names in the code.\n\nScreen Configuration\nThe code to generate the animation window, spheres, and drawing window has appeared many times in previous animations and will not be elaborated here.\n\nCustom Functions\nThe custom function `af_col_v` calculates the velocities after collision, using the formulas derived above in the code. It uses two vector calculations:\n\n`dot(a, b)`: calculates the dot product of vectors a and b\n`mag2(a) = a.mag2`: calculates the square of the magnitude of vector a\n\nObject Motion\nUpdates the positions of the spheres. If `mag(b1.pos - b2.pos) <= r1 + r2` and `dot((b1.pos - b2.pos), (b1.v - b2.v)) <=0` indicate a collision between b1 and b2, the velocities of b1 and b2 after the collision are calculated using the custom function `af_col_v`, and then reassigned to `b1.v` and `b2.v`.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import sphere, vector, color, dot, mag2, mag, scene, graph, gcurve, gdots, rate\n\n# Parameter Settings\nRadius_I = 1\nm1 = m2 = 1\nv1 = vector(-1, -2, -1)\nv2 = vector(1, 2, 1)\nr1 = r2 = Radius_I\nb1 = sphere(pos=vector(-10, -10, -10), radius=r1, color=color.red, v=v1, m=m1)\nb2 = sphere(pos=vector(10, 10, 10), radius=r2, color=color.blue, v=v2, m=m2)\n\n# Screen Configuration\nscene = canvas(title=\"Elastic Collision\", width=600, height=600, \n               center=vector(0, 0, 0), background=color.black)\ng = graph(title='simulation graph', width=600, height=450, \n          xtitle='t', ytitle='x', foreground=color.black, background=color.white)\ngc1 = gcurve(color=color.red, width=4, markers=True, label='b1.x')\ngc2 = gcurve(color=color.blue, width=2, markers=True, label='b2.x')\n\n# Custom Functions\ndef af_col_v(m1, m2, r1, r2, v1, v2):\n    v1f = v1 + 2*m2/(m1+m2) * dot(v2-v1, r1-r2) / mag2(r1-r2) * (r1-r2)\n    v2f = v2 + 2*m1/(m1+m2) * dot(v1-v2, r2-r1) / mag2(r2-r1) * (r2-r1)\n    return v1f, v2f\n\n# Object Motion\nt = 0\ndt = 0.001\nwhile True:\n    rate(1000)\n    b1.pos = b1.pos + b1.v*dt\n    b2.pos = b2.pos + b2.v*dt\n    if mag(b1.pos - b2.pos) <= r1 + r2 and dot((b1.pos - b2.pos), (b1.v - b2.v)) <= 0:\n        af_v1, af_v2 = af_col_v(m1, m2, b1.pos, b2.pos, b1.v, b2.v)\n        b1.v = af_v1\n        b2.v = af_v2\n    t += dt\n    gc1.plot(t, b1.pos.x)\n    gc2.plot(t, b2.pos.x)",
      "mode": "initial",
      "timestamp": "2024-07-24 06:19:14",
      "serial_number": 1
    },
    {
      "input": "Please update the following program based on this instruction: The two balls are not undergoing 3D elastic collisions as they should. Please fix it.\n\nfrom vpython import sphere, vector, color, dot, mag2, mag, scene, graph, gcurve, gdots, rate\n\n# Parameter Settings\nRadius_I = 1\nm1 = m2 = 1\nv1 = vector(-1, -2, -1)\nv2 = vector(1, 2, 1)\nr1 = r2 = Radius_I\nb1 = sphere(pos=vector(-10, -10, -10), radius=r1, color=color.red, v=v1, m=m1)\nb2 = sphere(pos=vector(10, 10, 10), radius=r2, color=color.blue, v=v2, m=m2)\n\n# Screen Configuration\nscene = canvas(title=\"Elastic Collision\", width=600, height=600, \n               center=vector(0, 0, 0), background=color.black)\ng = graph(title='simulation graph', width=600, height=450, \n          xtitle='t', ytitle='x', foreground=color.black, background=color.white)\ngc1 = gcurve(color=color.red, width=4, markers=True, label='b1.x')\ngc2 = gcurve(color=color.blue, width=2, markers=True, label='b2.x')\n\n# Custom Functions\ndef af_col_v(m1, m2, r1, r2, v1, v2):\n    v1f = v1 + 2*m2/(m1+m2) * dot(v2-v1, r1-r2) / mag2(r1-r2) * (r1-r2)\n    v2f = v2 + 2*m1/(m1+m2) * dot(v1-v2, r2-r1) / mag2(r2-r1) * (r2-r1)\n    return v1f, v2f\n\n# Object Motion\nt = 0\ndt = 0.001\nwhile True:\n    rate(1000)\n    b1.pos = b1.pos + b1.v*dt\n    b2.pos = b2.pos + b2.v*dt\n    if mag(b1.pos - b2.pos) <= r1 + r2 and dot((b1.pos - b2.pos), (b1.v - b2.v)) <= 0:\n        af_v1, af_v2 = af_col_v(m1, m2, b1.pos, b2.pos, b1.v, b2.v)\n        b1.v = af_v1\n        b2.v = af_v2\n    t += dt\n    gc1.plot(t, b1.pos.x)\n    gc2.plot(t, b2.pos.x)",
      "output": "from vpython import sphere, vector, color, dot, mag2, scene, rate, canvas, mag\n\n# Parameter Settings\nRadius_I = 1\nm1 = m2 = 1\nv1 = vector(-1, -2, -1)\nv2 = vector(1, 2, 1)\nr1 = r2 = Radius_I\nb1 = sphere(pos=vector(-10, -10, -10), radius=r1, color=color.red, v=v1, m=m1)\nb2 = sphere(pos=vector(10, 10, 10), radius=r2, color=color.blue, v=v2, m=m2)\n\n# Screen Configuration\nscene = canvas(title=\"Elastic Collision\", width=600, height=600, \n               center=vector(0, 0, 0), background=color.black)\n\n# Custom Functions\ndef af_col_v(m1, m2, r1, r2, v1, v2):\n    v1f = v1 + 2*m2/(m1+m2) * dot(v2-v1, r1-r2) / mag2(r1-r2) * (r1-r2)\n    v2f = v2 + 2*m1/(m1+m2) * dot(v1-v2, r2-r1) / mag2(r2-r1) * (r2-r1)\n    return v1f, v2f\n\n# Object Motion\nt = 0\ndt = 0.001\nwhile True:\n    rate(1000)\n    b1.pos = b1.pos + b1.v*dt\n    b2.pos = b2.pos + b2.v*dt\n    if mag(b1.pos - b2.pos) <= r1 + r2 and dot((b1.pos - b2.pos), (b1.v - b2.v)) < 0:\n        af_v1, af_v2 = af_col_v(m1, m2, b1.pos, b2.pos, b1.v, b2.v)\n        b1.v = af_v1\n        b2.v = af_v2\n    t += dt",
      "mode": "modification",
      "timestamp": "2024-07-24 06:20:14",
      "serial_number": 3
    }
  ]
}