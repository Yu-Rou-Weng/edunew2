{
  "session_id": 698,
  "log": [
    {
      "input": "Simple Harmonic Motion Caused by Electrostatic Force (Placed Above the Perpendicular Bisector)\n\nPreviously, we have discussed simple harmonic motion caused by gravity in \"Gravity and Simple Harmonic Motion.\" When we learn about electrostatic forces, we find that Coulomb's Law and the Law of Universal Gravitation have similar forms. Therefore, electrostatic forces should also be able to produce the same motion patterns. Below are three different programs:\n\n19-2. Two fixed charged spheres, with a movable charged sphere placed above the perpendicular bisector\n\n## Program 19-2\n\n### Theoretical Derivation\n\nAs shown in the figure below, there are two point charges of +Q, fixed in position and spaced 2R apart. At a point x distance above the perpendicular bisector between them, there is a point charge of -q with mass m.\n![image](https://hackmd.io/_uploads/B14gQ36dA.png)\n\nIf the -q point charge is at rest at this point, with \\( x \\ll R \\), and only considering the electrostatic force between the objects, then the resultant force on -q is directed downward, with a magnitude\n$$\nF = \\frac{kQq}{R^2 + x^2} \\cdot \\frac{x}{\\sqrt{R^2 + x^2}} \\cdot 2 = \\frac{2kQq x}{(R^2 + x^2)^{3/2}}\n$$\n\n$$\n\\approx \\frac{2kQq x}{R^3} = Kx\n$$\n\nThus -q performs simple harmonic motion with a period\n$$\nT = 2\\pi \\sqrt{\\frac{m}{K}} = 2\\pi \\sqrt{\\frac{mR^3}{2kQq}}\n$$\n\nBelow is a graph of the electrostatic force \\(F\\) versus distance \\(x\\) plotted with \\(Q=q=2 \\times 10^4 \\, C\\). From the graph, it is evident that when \\(x\\) is very small, \\(F \\propto x\\), and the slope is approximately 0.7, matching the theoretical value.\n\nElectrostatic Force F-Distance x Graph (0 \u2264 x \u2264 100):\n![image](https://hackmd.io/_uploads/HkRXXh6O0.png)\n\nElectrostatic Force F-Distance x Graph (0 \u2264 x \u2264 10):\n![image](https://hackmd.io/_uploads/r1o4XnpdC.png)\n\nProgram 19-2 Screenshot:\n![image](https://hackmd.io/_uploads/Hy7g42TOR.png)\n\nProgram Design\n\nProgram 19-2 is nearly identical to 19-1, with the following differences:\n\nPlace the sphere at (0, h, 0).\n\nThe initial position of the sphere is at the upper endpoint, so the lower endpoint should be at y = -h, with lines drawn at the endpoints to mark positions.\n\nThe arrows representing velocity and acceleration are changed to be drawn at distances of 1 and 2 to the right of the sphere.\n\nThe condition to check if the sphere has returned to the starting point is modified to: if(ball.pos.y >= h and ball.v.y >= 0).\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\nR = 0.02\nk = 8.99E9\nQ = 2E-6\nq = -2E-6\nm = 0.01\nh = 0.1\nball = sphere(pos=vector(0, h, 0), radius=0.005, color=color.red)\nball.v = vector(0, 0, 0)\nball.m = m\nwall_L = sphere(pos=vector(-R, 0, 0), radius=0.005, color=color.blue)\nwall_R = sphere(pos=vector(R, 0, 0), radius=0.005, color=color.blue)\ntop_end = sphere(pos=vector(0, h, 0), radius=0.005, color=color.green)\nlow_end = sphere(pos=vector(0, -h, 0), radius=0.005, color=color.green)\narrow_v = arrow(pos=vector(0, h, 0)+vector(0.01, 0, 0), axis=vector(0, 0, 0), color=color.yellow)\narrow_a = arrow(pos=vector(0, h, 0)+vector(0.02, 0, 0), axis=vector(0, 0, 0), color=color.white)\nt = 0\ndt = 0.0001\n\ndef F_electric(q, Q, r):\n    return k*q*Q*r.hat/(mag(r)**2)\n\nwhile True:\n    rate(10000)\n    r_L = ball.pos - wall_L.pos\n    r_R = ball.pos - wall_R.pos\n    F_net = F_electric(q, Q, r_L) + F_electric(q, Q, r_R)\n    ball.a = F_net / ball.m\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    arrow_v.pos = ball.pos + vector(0.01, 0, 0)\n    arrow_v.axis = ball.v/10\n    arrow_a.pos = ball.pos + vector(0.02, 0, 0)\n    arrow_a.axis = ball.a/10\n    t += dt\n    if (ball.pos.y >= h and ball.v.y >= 0):\n        print(\"T = \", t)\n        break",
      "mode": "initial",
      "timestamp": "2024-07-24 11:31:00",
      "serial_number": 1
    }
  ]
}