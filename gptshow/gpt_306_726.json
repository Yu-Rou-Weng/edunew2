{
  "session_id": 726,
  "log": [
    {
      "input": "**Motion of Charged Particles in a Magnetic Field**\n\nThe magnetic force $\\vec{F}_B$ on a charged particle in a uniform magnetic field is given by:\n$$\n\\vec{F}_B = q (\\vec{v} \\times \\vec{B}) \\Rightarrow F_B = qvB \\sin{\\theta}\n$$\nwhere $q$ is the charge of the particle, $v_0$ is the speed of the particle, and $B$ is the external magnetic field. There are three possible types of motion:\n\n- $\\theta = 0^\\circ$ or $180^\\circ$: $F_B = 0$, motion is uniform linear motion.\n- $\\theta = 90^\\circ$: $F_B = qvB$, motion is uniform circular motion.\n- Other angles: Helical motion, moving forward while revolving in a circle.\n\nThe goal is to visualize these three states of motion, with the animation window\u2019s viewpoint automatically adjusting based on the angle between velocity and magnetic field for optimal observation.\n\n**Helical Motion Diagram:**\n![image](https://hackmd.io/_uploads/BkS9t3TuC.png)\n\n**Parameter Settings**\n\nVariables are set as size, m, theta, phi, v0, q, L, B_field, t, dt, with their purposes commented in the code. To ensure smoother animation, the particle's charge and mass are intentionally set much larger.\n\n**Display Settings**\n- Create an animation window, adjusting the viewpoint based on theta and phi. If theta == pi/2 or phi == pi/2, the view is set from (L, L/4, L/4) towards the origin; otherwise, it is from (L/4, L/4, L) towards the origin.\n- Create the charged particle and set its initial velocity.\n- Generate coordinate axes and labels.\n- Generate arrows and labels representing the magnetic field.\n- Generate arrows representing velocity and acceleration.\n\n**Object Motion**\n- The particle is confined to move within a cubic space with side length 1.2 L, stopping when it reaches the edge, hence the conditions in the while loop are set as abs(charge.pos.x) < 0.6*L and abs(charge.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L.\n- Calculate the resultant force on the charged particle, update its acceleration, velocity, and position.\n- Update the arrows for velocity and acceleration to only show direction to avoid automatic scaling of the animation.\n- Update the time.\n\n**Simulation Results**\n\nBelow are five different parameter combinations and their results:\n\n1. theta = 0, phi = 0 \u21d2 Velocity component only in the x-direction, moving along the x-axis at constant speed.\n![image](https://hackmd.io/_uploads/BJdk9hauA.png)\n\n2. theta = 90, phi = 0 \u21d2 No velocity component in the x-direction, performing uniform circular motion on the yz plane.\n![image](https://hackmd.io/_uploads/Hy31qhpOA.png)\n\n3. theta = 0, phi = 90 \u21d2 No velocity component in the x-direction, performing uniform circular motion on the yz plane.\n![image](https://hackmd.io/_uploads/SJfxcnpu0.png)\n\n4. theta = 80, phi = 10 \u21d2 Velocity not at an angle of 0 degrees or 180 degrees to the x-axis, helical motion.\n![image](https://hackmd.io/_uploads/S1wlcnadC.png)\n\n5. theta = 100, phi = 10 \u21d2 Velocity not at an angle of 0 degrees or 180 degrees to the x-axis, helical motion.\n![image](https://hackmd.io/_uploads/Skal5nau0.png)\n\n**Cyber Input Variable Mapping Information:**\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1.\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Define and initialize parameters\nsize = 2.0\nm = 0.1\ntheta = 30 * pi / 180 \nphi = 30 * pi / 180\nv0 = 1.0\nq = 1.0\nRadius_I = 1.0\nL = 10.0\nB_field = vec(0, 0, 1)\nt = 0\ndt = 0.001\n\n# Create an animation window\nif theta == pi/2 or phi == pi/2:\n    scene = canvas(center=vec(0, 0, 0), background=vec(0, 0, 0), range=L, forward=vec(-1, -0.5, -0.5))\nelse:\n    scene = canvas(center=vec(0, 0, 0), background=vec(0, 0, 0), range=L, forward=vec(-0.5, -0.5, -1))\n\n# Create the charged particle and set its initial velocity\ncharge = sphere(radius=Radius_I, color=color.yellow)\ncharge.pos = vec(0, 0, 0)\ncharge.v = vec(v0 * sin(theta) * cos(phi), v0 * sin(theta) * sin(phi), v0 * cos(theta))\ncharge.a = vec(0, 0, 0)\n\n# Generate coordinate axes and labels\nx_axis = curve(color=color.red, pos=[vec(-L, 0, 0), vec(L, 0, 0)])\nlabel_x = label(text='x', color=color.red, pos=vec(L, 0, 0), opacity=0)\ny_axis = curve(color=color.green, pos=[vec(0, -L, 0), vec(0, L, 0)])\nlabel_y = label(text='y', color=color.green, pos=vec(0, L, 0), opacity=0)\nz_axis = curve(color=color.blue, pos=[vec(0, 0, -L), vec(0, 0, L)])\nlabel_z = label(text='z', color=color.blue, pos=vec(0, 0, L), opacity=0)\n\n# Generate arrows and labels representing the magnetic field\nB_arrow = arrow(color=color.orange, pos=vec(0, 0, 0), axis=B_field, shaftwidth=0.3)\nlabel_B = label(text='B', color=color.orange, pos=vec(0, 0, L/5), opacity=0)\n\n# Generate arrows representing velocity and acceleration\nv_arrow = arrow(color=color.red, pos=charge.pos, axis=charge.v, shaftwidth=0.3)\nlabel_v = label(text='v', color=color.red, pos=charge.pos+charge.v, opacity=0)\na_arrow = arrow(color=color.magenta, pos=charge.pos, axis=charge.a, shaftwidth=0.3)\nlabel_a = label(text='a', color=color.magenta, pos=charge.pos+charge.a, opacity=0)\n\n# Object motion\nwhile abs(charge.pos.x) < 0.6*L and abs(charge.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L:\n    rate(500)\n    # Update the force, acceleration, velocity, and position\n    F = q * cross(charge.v, B_field)\n    charge.a = F / m\n    charge.v += charge.a * dt\n    charge.pos += charge.v * dt\n\n    # Update the arrows for velocity and acceleration\n    v_arrow.pos = charge.pos\n    v_arrow.axis = charge.v\n    a_arrow.pos = charge.pos\n    a_arrow.axis = charge.a\n\n    # Update the time\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 14:13:02",
      "serial_number": 1
    }
  ]
}