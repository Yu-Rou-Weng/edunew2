{
  "session_id": 786,
  "log": [
    {
      "input": "Please write a VPython code for \"Simple Harmonic Motion Caused by Electrostatic Force (Circular Ring, Placed Above the Vertical Line)\"\nWe have previously dealt with simple harmonic motion caused by gravity in \"Gravity and Simple Harmonic Motion.\" When we learn about electrostatic force, we find that Coulomb's Law is very similar to the Law of Universal Gravitation, so electrostatic force should also be able to produce the same motion pattern. Below are 3 different programs:\n\nProgram 19-3: Replace the charged sphere in Program 19-2 with a circular ring, with the movable charged sphere placed above the vertical line.\n\n## Program 19-3\n\n### Theoretical Derivation\n\nAs shown in the figure below, there is a ring with a radius of \\(R\\), and the total charge of the circular ring is \\(+Q\\), uniformly distributed. If the position of the circular ring is fixed, and at a distance \\(x\\) from the center, there is a point charge with charge \\(-q\\) and mass \\(m\\).\n![image](https://hackmd.io/_uploads/r1bRXhT_0.png)\n\nIf the velocity of \\(-q\\) is zero at this point and \\(x \\ll R\\), only consider the electrostatic force between the objects. When calculating the resultant force on \\(-q\\), you can first divide the circular ring into \\(N\\) small spheres, each with a charge of \\(\\Delta Q = \\frac{Q}{N}\\). The electrostatic force on \\(-q\\) is along the connecting line direction, and there is an equal and opposite force on the other side, thus the resultant force direction on \\(-q\\) is downwards, with a magnitude of\n$$\nF = \\frac{kQq x}{(R^2 + x^2)^{3/2}} \\approx \\frac{kQq x}{R^3} = Kx\n$$\n\nThus, \\(-q\\) undergoes simple harmonic motion, with a period of\n$$\nT = 2\\pi \\sqrt{\\frac{m}{K}} = 2\\pi \\sqrt{\\frac{mR^3}{kQq}}\n$$\n\nScreenshot of Program 19-3:\n![image](https://hackmd.io/_uploads/HkxyN3pu0.png)\n\nProgramming Part\nProgram 19-3 is almost the same as 19-2, the difference being that the circular ring is first divided into \\(N\\) small spheres, and then a for loop is used to calculate the electrostatic force between each segment of the ring and the movable sphere, finally calculating the resultant force on the movable sphere.\n\nIn position (0, 0, 0), there is a three-dimensional circular ring with a radius of 10, and a small sphere with a radius of 0.3 is released at position (0, 3, 0) and begins to undergo simple harmonic motion caused by the electrostatic force with the circular ring. The sphere can only move between (0, 3, 0) and (0, -3, 0). At (0, 3, 0) and (0, -3, 0), there are two 5 cm horizontal white lines respectively.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# constants\nk = 9e9\nN = 20\nR = 10\nQ = 5e-3\nq = 1e-6\nm = 1e-3\nRadius = 0.3\nRadius_I = 1\n\n# create a scene\nscene = canvas(width=600, height=600, align='left')\nscene.range = 2 * R\n\n# create the circular ring\nring = []\ndq = Q / N\ndtheta = 2 * pi / N\nfor i in range(N):\n    theta = i * dtheta\n    ring.append(sphere(radius=Radius, pos=vec(R * cos(theta), R * sin(theta), 0), q=dq))\n\n# create the movable sphere\nball = sphere(radius=Radius_I, pos=vec(0, 3, 0), v=vec(0, 0, 0), m=m, q=-q)\n\n# create two horizontal lines\nline1 = cylinder(radius=0.05, pos=vec(-R, 3, 0), axis=vec(2 * R, 0, 0))\nline2 = cylinder(radius=0.05, pos=vec(-R, -3, 0), axis=vec(2 * R, 0, 0))\n\n# time parameters\ndt = 0.001\nt = 0\n\n# main loop\nwhile True:\n    rate(1000)\n    F = vec(0, 0, 0)\n    for i in range(N):\n        r = ball.pos - ring[i].pos\n        F += k * ball.q * ring[i].q / r.mag2 * r.norm()\n    ball.v += F / ball.m * dt\n    ball.pos += ball.v * dt",
      "mode": "initial",
      "timestamp": "2024-07-25 21:31:20",
      "serial_number": 1
    },
    {
      "input": "Please update the following program based on this instruction: The small ball can only move vertically between (0, 3, 0) and (0, -3, 0).\n\nfrom vpython import *\n\n# constants\nk = 9e9\nN = 20\nR = 10\nQ = 5e-3\nq = 1e-6\nm = 1e-3\nRadius = 0.3\nRadius_I = 1\n\n# create a scene\nscene = canvas(width=600, height=600, align='left')\nscene.range = 2 * R\n\n# create the circular ring\nring = []\ndq = Q / N\ndtheta = 2 * pi / N\nfor i in range(N):\n    theta = i * dtheta\n    ring.append(sphere(radius=Radius, pos=vec(R * cos(theta), R * sin(theta), 0), q=dq))\n\n# create the movable sphere\nball = sphere(radius=Radius_I, pos=vec(0, 3, 0), v=vec(0, 0, 0), m=m, q=-q)\n\n# create two horizontal lines\nline1 = cylinder(radius=0.05, pos=vec(-R, 3, 0), axis=vec(2 * R, 0, 0))\nline2 = cylinder(radius=0.05, pos=vec(-R, -3, 0), axis=vec(2 * R, 0, 0))\n\n# time parameters\ndt = 0.001\nt = 0\n\n# main loop\nwhile True:\n    rate(1000)\n    F = vec(0, 0, 0)\n    for i in range(N):\n        r = ball.pos - ring[i].pos\n        F += k * ball.q * ring[i].q / r.mag2 * r.norm()\n    ball.v += F / ball.m * dt\n    ball.pos += ball.v * dt",
      "output": "from vpython import *\n\n# constants\nk = 9e9\nN = 20\nR = 10\nQ = 5e-3\nq = 1e-6\nm = 1e-3\nRadius = 0.3\nRadius_I = 1\n\n# create a scene\nscene = canvas(width=600, height=600, align='left')\nscene.range = 2 * R\n\n# create the circular ring\nring = []\ndq = Q / N\ndtheta = 2 * pi / N\nfor i in range(N):\n    theta = i * dtheta\n    ring.append(sphere(radius=Radius, pos=vec(R * cos(theta), R * sin(theta), 0), q=dq))\n\n# create the movable sphere\nball = sphere(radius=Radius_I, pos=vec(0, 3, 0), v=vec(0, 0, 0), m=m, q=-q)\n\n# create two horizontal lines\nline1 = cylinder(radius=0.05, pos=vec(-R, 3, 0), axis=vec(2 * R, 0, 0))\nline2 = cylinder(radius=0.05, pos=vec(-R, -3, 0), axis=vec(2 * R, 0, 0))\n\n# time parameters\ndt = 0.001\nt = 0\n\n# main loop\nwhile True:\n    rate(1000)\n    F = vec(0, 0, 0)\n    for i in range(N):\n        r = ball.pos - ring[i].pos\n        F += k * ball.q * ring[i].q / r.mag2 * r.norm()\n    ball.v += F / ball.m * dt\n    ball.pos += ball.v * dt\n    if ball.pos.y > 3:\n        ball.pos.y = 3\n        ball.v.y = 0\n    elif ball.pos.y < -3:\n        ball.pos.y = -3\n        ball.v.y = 0",
      "mode": "modification",
      "timestamp": "2024-07-25 21:32:08",
      "serial_number": 2
    },
    {
      "input": "Please update the following program based on this instruction: The small ball can only move vertically between (0, 3, 0) and (0, -3, 0).\n\nfrom vpython import *\n\n# constants\nk = 9e9\nN = 20\nR = 10\nQ = 5e-3\nq = 1e-6\nm = 1e-3\nRadius = 0.3\nRadius_I = 1\n\n# create a scene\nscene = canvas(width=600, height=600, align='left')\nscene.range = 2 * R\n\n# create the circular ring\nring = []\ndq = Q / N\ndtheta = 2 * pi / N\nfor i in range(N):\n    theta = i * dtheta\n    ring.append(sphere(radius=Radius, pos=vec(R * cos(theta), R * sin(theta), 0), q=dq))\n\n# create the movable sphere\nball = sphere(radius=Radius_I, pos=vec(0, 3, 0), v=vec(0, 0, 0), m=m, q=-q)\n\n# create two horizontal lines\nline1 = cylinder(radius=0.05, pos=vec(-R, 3, 0), axis=vec(2 * R, 0, 0))\nline2 = cylinder(radius=0.05, pos=vec(-R, -3, 0), axis=vec(2 * R, 0, 0))\n\n# time parameters\ndt = 0.001\nt = 0\n\n# main loop\nwhile True:\n    rate(1000)\n    F = vec(0, 0, 0)\n    for i in range(N):\n        r = ball.pos - ring[i].pos\n        F += k * ball.q * ring[i].q / r.mag2 * r.norm()\n    ball.v += F / ball.m * dt\n    ball.pos += ball.v * dt",
      "output": "from vpython import *\n\n# constants\nk = 9e9\nN = 20\nR = 10\nQ = 5e-3\nq = 1e-6\nm = 1e-3\nRadius = 0.3\nRadius_I = 1\n\n# create a scene\nscene = canvas(width=600, height=600, align='left')\nscene.range = 2 * R\n\n# create the circular ring\nring = []\ndq = Q / N\ndtheta = 2 * pi / N\nfor i in range(N):\n    theta = i * dtheta\n    ring.append(sphere(radius=Radius, pos=vec(R * cos(theta), R * sin(theta), 0), q=dq))\n\n# create the movable sphere\nball = sphere(radius=Radius_I, pos=vec(0, 3, 0), v=vec(0, 0, 0), m=m, q=-q)\n\n# create two horizontal lines\nline1 = cylinder(radius=0.05, pos=vec(-R, 3, 0), axis=vec(2 * R, 0, 0))\nline2 = cylinder(radius=0.05, pos=vec(-R, -3, 0), axis=vec(2 * R, 0, 0))\n\n# time parameters\ndt = 0.001\nt = 0\n\n# main loop\nwhile True:\n    rate(1000)\n    F = vec(0, 0, 0)\n    for i in range(N):\n        r = ball.pos - ring[i].pos\n        F += k * ball.q * ring[i].q / r.mag2 * r.norm()\n    ball.v += F / ball.m * dt\n    ball.pos += ball.v * dt\n    if ball.pos.y > 3:\n        ball.pos.y = 3\n        ball.v.y = 0\n    elif ball.pos.y < -3:\n        ball.pos.y = -3\n        ball.v.y = 0",
      "mode": "modification",
      "timestamp": "2024-07-25 21:35:19",
      "serial_number": 3
    }
  ]
}