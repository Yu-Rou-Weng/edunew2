{
  "session_id": 607,
  "log": [
    {
      "input": "Simple Harmonic Motion Caused by Gravity, Circular Ring, Initial Velocity Zero, Starting from Endpoint\n\nThis is a guaranteed yet abstract topic that appears in the second year of high school curriculum:\n\nIn outer space, there are two planets each with mass $M$. The planets have uniform mass distribution and are fixed in place, with a distance of $2d$ between them. On the perpendicular bisector at a distance $x$ from the midpoint, there is a mass point of mass $m$. Assuming the mass point was initially at rest and only considering the effect of gravity, what is the period of motion of $m$ when $x \\ll d$?\n\n## Analysis:\n\nFirst, draw a force diagram for $m$, then the resultant force on $m$ is\n$$\nF_x = -2 \\frac{GMmx}{(d^2 + x^2)^{3/2}} \\approx -2 \\frac{GMm}{d^3} x = -kx\n$$\n\n$$\nT = 2\\pi \\sqrt{\\frac{m}{k}} = 2\\pi \\sqrt{\\frac{d^3}{2GM}}\n$$\n\n### Force Diagram for m\n\n### Relationship Between Resultant Force on m and Distance x (0 \u2264 x \u2264 100)\n\n### Relationship Between Resultant Force on m and Distance x (0 \u2264 x \u2264 8)\n\nThere is typically an advanced version of this problem where the two mass $m$ planets are replaced by a uniformly distributed mass, total mass $m$, and radius $r$ circular ring. If the other conditions remain the same, then the resultant force on $m$ and the period of motion are:\n\n$$\nF_x = - \\frac{GMmx}{(r^2 + x^2)^{3/2}} \\approx - \\frac{GMm}{r^3} x = -kx\n$$\n\n$$\nT = 2\\pi \\sqrt{\\frac{m}{k}} = 2\\pi \\sqrt{\\frac{r^3}{GM}}\n$$\n\n### Diagram of m and M Circular Ring\n\nThe goal this time is to illustrate these two problems.\n\n## Parameter Settings\n\nVariables such as size, m, M, d, h, G, v0, i, t, dt are defined and initialized, with their purposes noted in the comments of each line.\n\n## Screen Setup\n\nSince VPython by default views from the +z axis towards the origin, with the right side of the screen as the +x direction, and the top as the +y direction, the original problem of m moving in the x-axis direction is modified to move in the y-axis direction in the animation.\n\nCreate planets s1, s2 and a small ball, and set the initial position of the ball to (0, h, 0), with initial velocity 0. If you want to try starting the ball from different distances later, just modify the h parameter in the settings.\n\nDraw a line between the planets, which represents the equilibrium point; the starting height is at the top endpoint, so the bottom endpoint should be at y = -h.\n\nGenerate arrows representing velocity and acceleration. To prevent the arrows from overlapping, draw them at distances of 1 and 2 to the right of the ball.\n\nOpen the drawing window, and chart the ball's position, velocity, acceleration, and time.\n\n## Object Motion\n\nTo ensure that the animation runs back and forth 5 times, set the condition in the while loop as i < 5, and use `if(ball.pos.y > h)` to determine if the ball has returned to the starting point, if so, print the elapsed time t and the number of returns i.\n\nCalculate the resultant force F on the ball using the law of universal gravitation, then calculate the ball's acceleration from F = ma, and update velocity and position.\n\n### Program to be written: Simple Harmonic Motion Caused by Gravity, Circular Ring, Initial Velocity Zero, Starting from Endpoint\n\nProgram design part\n\nThis program is based on the program: Simple Harmonic Motion Caused by Gravity, Initial Velocity Zero, Starting from Endpoint, with the following differences:\n\nIn the screen setup part, s1 and s2 are changed to a circular ring, and the ring is divided into N small balls, each with mass M/N. Use a for loop to evenly place the N small balls on the ring, storing the data in a list named stars.\n\nIn the object motion part, use a for loop to take one ball at a time from the stars list and name it star, calculate the gravitational force f between star and the mass m ball, then calculate the resultant force F on ball by F += f.\n(1) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nM = 1E10  # mass of each planet\nm = 1  # mass of the small ball\nd = 1E2  # distance between two planets\nh = d/100  # starting height of the ball\nG = 1  # gravitational constant\ndt = 0.001  # time step\nN = 100  # number of stars in the ring\nR = d/2  # radius of the ring\nstars = []  # list to store the stars\n\n# Screen Setup\nscene = canvas(width=600, height=600, range=d/2, background=vec(0.5, 0.5, 0))\n\n# Create circular ring of stars\nfor i in range(N):\n    theta = 2 * pi * i / N\n    stars.append(sphere(pos=vec(R*cos(theta), 0, R*sin(theta)), radius=h/3, color=color.green, m=M/N))\n\nball = sphere(pos=vec(0, h, 0), v=vec(0, 0, 0), radius=h/3, color=color.red, m=m, make_trail=True)  # small ball\nline = curve(vec(0, -h, 0), vec(0, h, 0), color=color.yellow)  # line between planets\n\n# Object Motion\nt = 0  # initial time\ni = 0  # counter for number of returns\nwhile i < 5:\n    rate(1000)\n    F = vec(0, 0, 0)  # resultant force on the ball\n    for star in stars:  # calculate the force from each star\n        r = star.pos - ball.pos\n        F += G * star.m * ball.m * r.norm() / mag2(r)\n    ball.v += F * dt / ball.m  # update velocity\n    ball.pos += ball.v * dt  # update position\n    t += dt\n    if ball.pos.y > h:  # check if the ball has returned to the starting point\n        print('t =', round(t, 2), 's')\n        i += 1",
      "mode": "initial",
      "timestamp": "2024-07-24 03:38:32",
      "serial_number": 1
    }
  ]
}