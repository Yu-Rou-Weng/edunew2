{
  "session_id": 706,
  "log": [
    {
      "input": "# Electron Charge-to-Mass Ratio\n\nThe experimental setup for measuring the electron charge-to-mass ratio is shown below. It looks very similar to the velocity selector, so by slightly modifying the velocity selector program, we can create an animation for the electron charge-to-mass ratio experiment.\n\n### Schematic Diagram of the Experimental Setup\n![image](https://hackmd.io/_uploads/SkTFu36OR.png)\n\n## Theoretical Analysis\n\nRefer to the diagram above, where the particle mass is $m$, charge is $q$, and it enters a downward uniform electric field $E$ with a horizontal velocity $v_0$. The length of the parallel charged plates is $L$, and the distance between the right side of the charged plates and the screen is $D$. Considering only the electrostatic force, the acceleration of the particle upwards in the electric field is\n$$\na = \\frac{qE}{m}\n$$\n\nThere is no external force in the horizontal direction, thus it moves at a constant speed, and the time spent in the electric field is\n$$\nt_1 = \\frac{L}{v_0}\n$$\n\nThe upward displacement is\n$$\ny_1 = \\frac{1}{2} a t_1^2 = \\frac{1}{2} \\left( \\frac{qE}{m} \\right) \\left( \\frac{L}{v_0} \\right)^2\n$$\n\nThe upward velocity of the particle upon leaving the electric field is\n$$\nv_{y1} = a t_1 = \\frac{qEL}{mv_0}\n$$\n\nOutside the electric field, the particle is not subjected to external forces and moves in a straight line at constant speed. The time spent moving outside the electric field is\n$$\nt_2 = \\frac{D}{v_0}\n$$\n\nThe upward displacement is\n$$\ny_2 = v_{y1} t_2 = \\left( \\frac{qEL}{mv_0} \\right) \\left( \\frac{D}{v_0} \\right) = \\frac{qELD}{mv_0^2}\n$$\n\nThe total upward displacement is\n$$\ny = y_1 + y_2 = \\frac{qE}{2m} \\left( \\frac{L^2}{v_0^2} \\right) + \\frac{qELD}{mv_0^2} = \\frac{qEL(L + 2D)}{2mv_0^2}\n$$\n\nThe charge-to-mass ratio of the charged particle is\n$$\n\\frac{q}{m} = \\frac{2yv_0^2}{E L (L + 2D)}\n$$\n\nThe value of the electric field can be determined by the voltage and distance between the parallel charged plates, and the initial velocity $v_0$ can be controlled by the velocity selector. Therefore, all data except for the charge-to-mass ratio are measurable in the experiment.\n\n### Setting Parameters\n\nVariables such as size, m, v0, q, V, d, L, E_field, t, dt are defined and initialized with their purposes commented in the respective lines. To make the animation smoother, the particle\u2019s charge and mass are intentionally set much larger.\n\n### Screen Setup\nCreates an animation window, parallel charged plates, a horizontal line, and a charged particle. The parallel charged plates are located between -L < x < 0.\n\nGenerates arrows and labels representing the electric and magnetic fields.\n\nGenerates arrows representing velocity and acceleration.\n\n### Object Motion\nTo stop the animation when the charged particle reaches the screen or hits the parallel charged plates, conditions in the while loop are set as 0 < charge.pos.x < screen.pos.x - screen.length/2 - size or (charge.pos.x < 0 and abs(charge.pos.y) < d/2 - p1.height - size)\n(a) Function of the first set of conditions: The animation continues while the particle is between the electric field and the screen.\n(b) Function of the second set of conditions: The animation continues while the particle is in the electric field and hasn't collided with the parallel charged plates.\n\nCalculates the net force on the charged particle, which is zero outside the parallel charged plates.\n\nUpdates the charged particle\u2019s acceleration, velocity, and position.\n\nUpdates the arrows representing velocity and acceleration, only displaying direction to avoid automatic scaling of the animation.\n\nDefines variables xp and xc to draw a horizontal line when the charged particle leaves the parallel charged plates, where xp is the particle's position at the previous moment and xc is the particle's current position. If xp < 0 and xc > 0, it indicates the particle just left the charged plates, and a cylinder command is used to draw a parallel line.\n\nUpdates time.\n\n### Simulation Results\n\nHere are six different sets of data and their test results:\n\n1. v0 = 20, q = -2 \u00d7 10-9, V = 1, d = 0.1 \u21d2 Hits the parallel charged plates upwards\n![image](https://hackmd.io/_uploads/B1w6O2TdR.png)\n\n2. q = -1 \u00d7 10-9, other conditions same as set 1 \u21d2 Moves upwards but does not hit the parallel charged plates\n![image](https://hackmd.io/_uploads/Bkoa_naOC.png)\n\n3. v0 = 25, other conditions same as set 1 \u21d2 Moves upwards but does not hit the parallel charged plates\n![image](https://hackmd.io/_uploads/S11AunauA.png)\n\n4. q = 2 \u00d7 10-9, other conditions same as set 1 \u21d2 Hits the parallel charged plates downwards\n![image](https://hackmd.io/_uploads/S1NROhpO0.png)\n\n5. q = 1 \u00d7 10-9, other conditions same as set 1 \u21d2 Moves downwards but does not hit the parallel charged plates\n![image](https://hackmd.io/_uploads/ryY0OnTu0.png)\n\n6. v0 = 25, q = 2 \u00d7 10-9, other conditions same as set 1 \u21d2 Moves downwards but does not hit the parallel charged plates\n![image](https://hackmd.io/_uploads/rJpRO3TO0.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# setting parameters\nsize = 0.01\nm = 0.1\nv0 = 20\nq = -2E-9\nV = 1\nd = 0.1\nL = 0.5\nE_field = V/d\nt = 0\ndt = 0.001\ny = 0\n\n# screen setup\nscene = canvas(width=800, height=800, center=vector(0.5*L, 0, 0), background=vector(0.5, 0.5, 0))\np1 = box(pos=vector(-L/2, d/2, 0), length=L, height=0.005, width=d, color=color.blue, opacity=0.3)\np2 = box(pos=vector(-L/2, -d/2, 0), length=L, height=0.005, width=d, color=color.blue, opacity=0.3)\nscreen = box(pos=vector(L+0.1, 0, 0), length=0.005, height=2*d, width=d, color=color.green, opacity=0.3)\ncharge = sphere(pos=vector(0, 0, 0), v=vector(v0, 0, 0), radius=size, m=m, q=q, color=color.red)\nv_a = arrow(pos=charge.pos, axis=charge.v, shaftwidth=0.8*size, color=color.yellow)\na_a = arrow(pos=charge.pos, axis=vector(0, 0, 0), shaftwidth=0.8*size, color=color.cyan)\nE_a = arrow(pos=vector(-L/2, 0, 0), axis=vector(0, -1, 0), length=d/3, shaftwidth=0.8*size, color=color.green)\nE_l = label(pos=E_a.pos, text='E', xoffset=-20, yoffset=+15, space=30, height=16, border=4, font='sans')\n\n# object motion\nwhile ((charge.pos.x < screen.pos.x - screen.length/2 - size) or (charge.pos.x < 0 and abs(charge.pos.y) < d/2 - p1.height - size)):\n    rate(1000)\n    if charge.pos.x < 0:\n        F = charge.q*vector(0, -E_field, 0)\n    else:\n        F = vector(0, 0, 0)\n    charge.a = F/charge.m\n    charge.v += charge.a*dt\n    xp = charge.pos.x\n    charge.pos += charge.v*dt\n    xc = charge.pos.x\n    v_a.pos = charge.pos\n    v_a.axis = charge.v\n    a_a.pos = charge.pos\n    a_a.axis = charge.a\n    if xp < 0 and xc > 0:\n        cylinder(pos=charge.pos, axis=vector(0, 0, -d/2), radius=0.5*size, color=color.black)\n        y = charge.pos.y\n    t += dt\n\n# simulation results\nq_m_ratio = 2*y*v0**2/(E_field*L*(L+2*(L+0.1)))\nprint(\"q/m ratio is\", q_m_ratio)",
      "mode": "initial",
      "timestamp": "2024-07-24 12:34:36",
      "serial_number": 1
    }
  ]
}