{
  "session_id": 593,
  "log": [
    {
      "input": "Simple Harmonic Motion with Damping\n\nOn a horizontal smooth surface, there is a block of mass $m$, connected to a wall on the left by a spring with a spring constant $k$. If the block is pulled to the right by a distance $R$ and then released from rest, the relationship between the resultant force on the block and its acceleration is given by:\n$$\nF = -kx = ma \\Rightarrow -kx = m \\frac{d^2 x}{d t^2}\n$$\n\nThis type of motion is called Simple Harmonic Motion (S.H.M.), and from the equation above we can derive:\n$$\nx(t) = R \\cos(\\omega t + \\phi)\n$$\n$$\nv(t) = -\\omega R \\sin(\\omega t + \\phi)\n$$\n$$\na(t) = -\\omega^2 R \\cos(\\omega t + \\phi)\n$$\n\nIn the equations above, $\\omega$ is the angular frequency:\n$$\n\\omega = \\sqrt{\\frac{k}{m}}\n$$\n\nThe period is:\n$$\nT = 2\\pi \\sqrt{\\frac{m}{k}}\n$$\n\nTheoretically, by setting up the relationship between the restoring force of the spring and the block's displacement from the equilibrium position in VPython, we should be able to simulate the process and period of simple harmonic motion. The goal is to write a program for simple harmonic motion considering damping.\n\n### Theoretical Calculation\n\nAssuming the damping force experienced by the block is\n$f = -bv$,\nfrom Newton's second law we have:\n$$\nma + bv + kx = 0\n$$\n$$\nm \\frac{d^2 x}{d t^2} + b \\frac{d x}{d t} + kx = 0\n$$\n\nThere are three cases:\n\n1. $b^2 > 4mk$ Overdamped\n2. $b^2 = 4mk$ Critically Damped\n3. $b^2 < 4mk$ Underdamped\n\n## Programming Part\n\nThe program for simple harmonic motion with damping is similar to that for simple harmonic motion, with two differences.\n\nWhen calculating the resultant force on the block, it should be changed to:\n\nF = -k * (spring.axis - vec(L0, 0, 0)) - b * block.v\nSince the block will not return to the starting point, to determine if the block has completed a period, we use its velocity. If the block's velocity was initially to the right and then to the left, it indicates that the block has completed a period.\n\nvc = block.v.x\nif vp > 0 and vc < 0:\n    i += 1\n    print(i, t)\nvp = vc\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Amplification_I as a cyber input variable, set Amplification_I=5\n(2) Amplification_I is the amplification of the block. When Amplification_I changes to a new value, the amplification of the block also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\nm = 1\nk = 20\nb = 0.5\n\n# Initial conditions\nR = 0.5\nT = 2 * pi * sqrt(m / k)\n\n# Vpython objects\nfloor = box(pos=vec(0, -0.005, 0), size=vec(1, 0.01, 0.2), color=color.green)\nblock = box(pos=vec(R, 0, 0), size=vec(0.1, 0.02, 0.02), color=color.red, v=vec(0, 0, 0), m=m)\nspring = helix(pos=vec(-0.5, 0, 0), axis=block.pos + vec(0.05, 0, 0), radius=0.01, coils=20, constant=k)\n\n# Time parameters\nt = 0\ndt = 0.001\nvc = block.v.x\nvp = block.v.x\ni = 0\nAmplification_I = 5\n\nwhile True:\n    rate(1000)\n    F = -k * (spring.axis - vec(R, 0, 0)) - b * block.v\n    block.v += F / block.m * dt\n    block.pos += block.v * dt\n    spring.axis = block.pos + vec(0.05, 0, 0)\n    t += dt\n    vc = block.v.x\n    if vp > 0 and vc < 0:\n        i += 1\n        print(i, t)\n    vp = vc\n    block.size.x = Amplification_I * block.size.x",
      "mode": "initial",
      "timestamp": "2024-07-24 02:36:53",
      "serial_number": 1
    }
  ]
}