{
  "session_id": 734,
  "log": [
    {
      "input": "# Planetary Motion\n\nProgram to be written: Planetary motion, custom planet velocity and distance, ability to change the power of r in the law of universal gravitation\n\nKepler\u2019s laws of planetary motion consist of the following three laws:\n\n1. **First Law (Law of Orbits)**: All planets move in elliptical orbits with the Sun at one focus.\n\n2. **Second Law (Law of Equal Areas)**: The line that connects a planet to the Sun sweeps out equal areas during equal intervals of time. If the distance between the Sun and the planet is $r$, the planet's velocity is $v$, and the angle between $r$ and $v$ is $\\theta$, then the area swept out per unit time is\n   $$\n   \\frac{\\Delta A}{\\Delta t} = \\frac{1}{2} rv \\sin{\\theta} = \\text{constant}\n   $$\n\n3. **Third Law (Law of Periods)**: For all planets orbiting the Sun, the square of the orbital period $T$ is proportional to the cube of the semi-major axis of its orbit $a$\n   $$\n   \\frac{a^3}{T^2} = \\text{constant}\n   $$\n\nThe first law is due to the fact that only gravitational forces act between the Sun and the stars, which can be proven by the law of universal gravitation to show that only ellipses are stable orbits. The second law is because the gravitational force passes through the Sun, thus conserving the angular momentum of the planet relative to the Sun, making the swept area equal in unit time. The third law can be derived using the law of gravitation as the centripetal force. If combined with the actual data of the solar system planets, these three laws could be graphically represented.\n\n## Parameter Settings\n\nThe variables are set as G, size, sun_m, d, v0, theta, n, t, dt, with their purposes commented in the respective lines. E represents the power of 10, for example, 1E3 = 1000, and can also be replaced with e. As much as I hope to use real data, when using real distances, the planet's radius must be enlarged, otherwise the planets would not be visible.\n\n## Display Settings\n\nWhen generating the Sun, the last option is `emissive=True`, which by default is False. If set to True, the Sun will emit light.\n\nWhen generating Earth, set the material `texture=textures.earth` because VPython has a built-in texture for Earth, so there's no need to find another image. However, since the Earth object does not have a set color, the default color of its trail is white. To change it to blue, add `trail_color=color.blue`. To change the trail radius to `0.1*size`, add `trail_radius=0.1 * size`.\n\nTo make the Sun emit light, in older versions of VPython, you would write:\n\nscene.lights = [local_light(pos=vec(0, 0, 0), color=color.white)]\nHowever, in VPython 7, this is not supported anymore, instead, place a light source at the Sun's location\n\nlamp = local_light(pos=vec(0,0,0), color=color.white)\nGenerate arrows representing velocity and acceleration.\n\n## Object Motion\nCalculate the acceleration of the planet\n\nplanet.a = - G*sun.m / planet.pos.mag**n * planet.pos.norm()\nTo be able to change the power of the distance in the law of universal gravitation, instead of using planet.pos.mag2 to calculate the square of the distance between the planet and the Sun, planet.pos.mag**n is used to calculate the nth power of the distance. Then update the planet's velocity and position.\n\nUpdate the arrows representing velocity and acceleration in position, direction, and length. Since the distance between the planet and the Sun is very large, arrows need to be enlarged to be visible.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1E10 \n\n(2) Radius_I is the radius of the planet. When Radius_I changes to a new value, the radius of the planet also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Set up the screen\nscene = canvas(width=800, height=800, background=vec(0.5,0.5,0))\n\n# Set constants\nG = 6.6743015E-11\nsize = 1E10\nsun_m = 2E30\nd = 1.496E11\nv0 = 3E4\ntheta = 0\nn = 2\nt = 0\ndt = 10000\nRadius_I = 1E10\n\n# Set up the objects\nsun = sphere(pos=vec(0, 0, 0), radius=2E10, color=color.yellow, emissive=True, mass=sun_m)\nplanet = sphere(pos=vec(d, 0, 0), radius=Radius_I, color=color.blue, make_trail=True, trail_type=\"points\", \n                trail_color=color.blue, trail_radius=0.1*size, velocity=v0*vec(0, cos(theta), sin(theta)), \n                mass=6E24, a=vec(0, 0, 0))\n\n# Set up the light\nlamp = local_light(pos=vec(0,0,0), color=color.white)\n\n# Set up the arrows\narrow_v = arrow(pos=planet.pos, axis=planet.velocity/1E4, shaftwidth=0.5*size, color=color.green)\narrow_a = arrow(pos=planet.pos, axis=planet.a/1E12, shaftwidth=0.5*size, color=color.red)\n\n# Define the motion\ndef motion():\n    planet.a = - G*sun.mass / planet.pos.mag**n * planet.pos.norm()\n    planet.velocity += planet.a * dt\n    planet.pos += planet.velocity * dt\n    arrow_v.pos = planet.pos\n    arrow_v.axis = planet.velocity / 1E4\n    arrow_a.pos = planet.pos\n    arrow_a.axis = planet.a / 1E12\n    return\n\n# Run the simulation\nwhile True:\n    rate(1000, motion)\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 18:09:48",
      "serial_number": 1
    }
  ]
}