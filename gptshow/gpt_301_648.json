{
  "session_id": 648,
  "log": [
    {
      "input": "Simple Harmonic Motion Caused by Electrostatic Force (Placed Above the Perpendicular Bisector)\n\nPreviously, we have dealt with simple harmonic motion caused by gravity in \"Gravity and Simple Harmonic Motion\". When we learn about electrostatic force, we find that Coulomb's Law resembles the law of universal gravitation, suggesting that electrostatic force could also generate a similar motion pattern. Below are 3 different setups:\n\n19-1. Two fixed charged spheres, a movable charged sphere placed to the right of the line connecting their centers.\n19-2. Two fixed charged spheres, a movable charged sphere placed above the perpendicular bisector.\n19-3. Modify the charged sphere in 19-2 to a ring, with the movable charged sphere placed above the perpendicular bisector.\n\n## Program 19-2\n\n### Theoretical Derivation\n\nAs shown in the figure below, there are two point charges of $+Q$ each, fixed in position at a distance of $2R$ apart. At a distance $x$ along the perpendicular bisector between them, there is a point charge of $-q$ with mass $m$.\n![image](https://hackmd.io/_uploads/B14gQ36dA.png)\n\nIf the velocity of the $-q$ point charge is zero at this position, and $x \\ll R$, considering only the electrostatic force between the objects, the resultant force on $-q$ is directed downwards with a magnitude of\n$$\nF = \\frac{kQq}{R^2 + x^2} \\cdot \\frac{x}{\\sqrt{R^2 + x^2}} \\cdot 2 = \\frac{2kQq x}{(R^2 + x^2)^{3/2}}\n$$\n\n$$\n\\approx \\frac{2kQq x}{R^3} = Kx\n$$\n\nThus, $-q$ undergoes simple harmonic motion with a period\n$$\nT = 2\\pi \\sqrt{\\frac{m}{K}} = 2\\pi \\sqrt{\\frac{mR^3}{2kQq}}\n$$\n\nThe graph below, plotted with \\(Q=q=2 \\times 10^4 \\, C\\), shows the relationship between the electrostatic force \\(F\\) and distance \\(x\\). The graph indicates that when \\(x\\) is very small, \\(F \\propto x\\), and the slope is approximately 0.7, which is consistent with the theoretical value.\n\nElectrostatic Force \\(F\\) vs. Distance \\(x\\) Graph (0 \u2264 x \u2264 100):\n![image](https://hackmd.io/_uploads/HkRXXh6O0.png)\n\nElectrostatic Force \\(F\\) vs. Distance \\(x\\) Graph (0 \u2264 x \u2264 10):\n![image](https://hackmd.io/_uploads/r1o4XnpdC.png)\n\n### Program Design\n\nProgram 19-2 is almost identical to 19-1, with only the following differences discussed:\n\nPlace the sphere at (0, h, 0).\n\nThe initial position of the sphere is at the upper endpoint, so the lower endpoint should be at y = -h, with a line drawn at the endpoint to mark the position.\n\nThe arrows representing velocity and acceleration are drawn to the right of the sphere at distances 1 and 2, respectively.\n\nThe condition to check if the sphere returns to the starting point is modified to if(ball.pos.y >= h and ball.v.y >= 0).\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\nQ = 2e-6\nq = -2e-6\nk = 8.99e9\nm = 1e-3\nR = 0.05\nh = 0.1\nRadius_I = 1\n\n# Objects\nscene = canvas(width=800, height=800, background=vector(0.5,0.5,0), align='left')\nball = sphere(pos=vector(0,h,0), radius=Radius_I, color=color.red, make_trail=True)\nball.v = vector(0,0,0)\nball.m = m\ncylinder(pos=vector(-R,0,0), axis=vector(2*R,0,0), radius=0.005)\nring(pos=vector(0,-h,0), axis=vector(0,0,1), radius=0.01)\nring(pos=vector(0,h,0), axis=vector(0,0,1), radius=0.01)\narrows = arrow(pos=vector(1,h,0), axis=vector(0,0,0), color=color.green)\narrows2 = arrow(pos=vector(2,h,0), axis=vector(0,0,0), color=color.blue)\n\n# Calculation\nt = 0\ndt = 0.0001\nwhile True:\n    rate(10000)\n    F = -2*k*Q*q*ball.pos/(mag(ball.pos)**3)\n    ball.a = F/ball.m\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    if ball.pos.y >= h and ball.v.y >= 0:\n        print(\"T = \", t)\n        t = 0\n    arrows.pos = vector(1, ball.pos.y, 0)\n    arrows.axis = ball.v/3\n    arrows2.pos = vector(2, ball.pos.y, 0)\n    arrows2.axis = ball.a/3\n    t += dt\n",
      "mode": "initial",
      "timestamp": "2024-07-24 06:50:28",
      "serial_number": 1
    },
    {
      "input": "Please update the following program based on this instruction: Enlarge all objects in the animation.\n\nfrom vpython import *\n\n# Constants\nQ = 2e-6\nq = -2e-6\nk = 8.99e9\nm = 1e-3\nR = 0.05\nh = 0.1\nRadius_I = 1\n\n# Objects\nscene = canvas(width=800, height=800, background=vector(0.5,0.5,0), align='left')\nball = sphere(pos=vector(0,h,0), radius=Radius_I, color=color.red, make_trail=True)\nball.v = vector(0,0,0)\nball.m = m\ncylinder(pos=vector(-R,0,0), axis=vector(2*R,0,0), radius=0.005)\nring(pos=vector(0,-h,0), axis=vector(0,0,1), radius=0.01)\nring(pos=vector(0,h,0), axis=vector(0,0,1), radius=0.01)\narrows = arrow(pos=vector(1,h,0), axis=vector(0,0,0), color=color.green)\narrows2 = arrow(pos=vector(2,h,0), axis=vector(0,0,0), color=color.blue)\n\n# Calculation\nt = 0\ndt = 0.0001\nwhile True:\n    rate(10000)\n    F = -2*k*Q*q*ball.pos/(mag(ball.pos)**3)\n    ball.a = F/ball.m\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    if ball.pos.y >= h and ball.v.y >= 0:\n        print(\"T = \", t)\n        t = 0\n    arrows.pos = vector(1, ball.pos.y, 0)\n    arrows.axis = ball.v/3\n    arrows2.pos = vector(2, ball.pos.y, 0)\n    arrows2.axis = ball.a/3\n    t += dt\n",
      "output": "from vpython import *\n\n# Constants\nQ = 2e-6\nq = -2e-6\nk = 8.99e9\nm = 1e-3\nR = 0.05\nh = 0.1\nRadius_I = 2 # Increased radius\n\n# Objects\nscene = canvas(width=800, height=800, background=vector(0.5,0.5,0), align='left')\nball = sphere(pos=vector(0,h,0), radius=Radius_I, color=color.red, make_trail=True)\nball.v = vector(0,0,0)\nball.m = m\ncylinder(pos=vector(-R,0,0), axis=vector(2*R,0,0), radius=0.01) # Increased radius\nring(pos=vector(0,-h,0), axis=vector(0,0,1), radius=0.02) # Increased radius\nring(pos=vector(0,h,0), axis=vector(0,0,1), radius=0.02) # Increased radius\narrows = arrow(pos=vector(1,h,0), axis=vector(0,0,0), color=color.green, shaftwidth=0.01) # Increased shaftwidth\narrows2 = arrow(pos=vector(2,h,0), axis=vector(0,0,0), color=color.blue, shaftwidth=0.01) # Increased shaftwidth\n\n# Calculation\nt = 0\ndt = 0.0001\nwhile True:\n    rate(10000)\n    F = -2*k*Q*q*ball.pos/(mag(ball.pos)**3)\n    ball.a = F/ball.m\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    if ball.pos.y >= h and ball.v.y >= 0:\n        print(\"T = \", t)\n        t = 0\n    arrows.pos = vector(1, ball.pos.y, 0)\n    arrows.axis = ball.v/3\n    arrows2.pos = vector(2, ball.pos.y, 0)\n    arrows2.axis = ball.a/3\n    t += dt",
      "mode": "modification",
      "timestamp": "2024-07-24 06:52:40",
      "serial_number": 8
    }
  ]
}