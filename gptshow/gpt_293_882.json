{
  "session_id": 882,
  "log": [
    {
      "input": "Please write a VPython program for \"Free Fall Three Ball Collision\"\n\nFormula for velocity in one-dimensional elastic collision:\n\nAssume two particles have masses \\( m_1 \\) and \\( m_2 \\), and their velocities before collision are \\( v_1 \\) and \\( v_2 \\) respectively. The velocities after the collision are \\( v_1' \\) and \\( v_2' \\), given by:\n\n\\[ v_1' = \\frac{m_1 - m_2}{m_1 + m_2} v_1 + \\frac{2m_2}{m_1 + m_2} v_2 \\]\n\n\\[ v_2' = \\frac{2m_1}{m_1 + m_2} v_1 + \\frac{m_2 - m_1}{m_1 + m_2} v_2 \\]\n\nWhere:\n- \\( v_1' \\) is the velocity of the object with mass \\( m_1 \\) after collision\n- \\( v_2' \\) is the velocity of the object with mass \\( m_2 \\) after collision\n- \\( v_1 \\) is the velocity of the object with mass \\( m_1 \\) before collision\n- \\( v_2 \\) is the velocity of the object with mass \\( m_2 \\) before collision\n\nThere are three balls: one is red, one is green, and another is blue. Please create a wooden floor with a side length of 50. The red ball has a mass of 3 and a radius of 3; the green ball has a mass of 2 and a radius of 2; the blue ball has a mass of 1 and a radius of 1. These three balls are vertically stacked, with the green ball on top of the red and the blue ball on top of the green. Release them from a height of 15 above the ground; the balls will start moving downward due to gravitational acceleration. The balls will follow the rules of one-dimensional elastic collision. The green ball will only bounce between the red ball and the blue ball after colliding with the red ball, and the blue ball will only bounce above the green ball after colliding with it. If the red ball hits the ground, it will bounce. If the red ball and the green ball collide, plug the mass of the red ball, the y-direction velocity of the red ball, the mass of the green ball, and the y-direction velocity of the green ball into the one-dimensional elastic collision formula, calculate the velocity after the collision, and reassign it to the y-direction velocities of the red and green balls. If the green ball and the blue ball collide, plug the mass of the green ball, the y-direction velocity of the green ball, the mass of the blue ball, and the y-direction velocity of the blue ball into the one-dimensional elastic collision formula, calculate the velocity after the collision, and reassign it to the y-direction velocities of the green and blue balls. As the red and green balls below are heavier than the blue ball, the rebound height of the blue ball will far exceed its original ground height.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy, and time.\n(4) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Initialize Variables\ng = 9.8\nmass = [3, 2, 1]\nR = [3, 2, 1]\nRadius_I = 1\nh = 15\n\n# Define balls and floor\nball = [sphere(radius=Radius_I*R[i], color=vector(1/(i+1), 1/(i+1), 1/(i+1)), make_trail=False) for i in range(3)]\nfloor = box(length=50, height=0.01, width=50, color=vector(0.4, 0.4, 0.5))\n\n# Set initial positions and velocities\nfor i in range(3):\n    ball[i].m = mass[i]\n    ball[i].v = vector(0, 0, 0)\n    ball[i].pos = vector(0, h - sum([2*Radius_I*R[j] for j in range(i)]), 0)\n\n# Animation loop\ndt = 0.001\nwhile True:\n    rate(1000)\n    for i in range(3):\n        ball[i].v += vector(0, -g*ball[i].m*dt, 0)\n        ball[i].pos += ball[i].v*dt\n\n    # Collision and bouncing\n    for i in range(2, -1, -1):\n        if i > 0 and ball[i].pos.y - Radius_I*R[i] <= ball[i-1].pos.y + Radius_I*R[i-1]:\n            v1prime = ((ball[i-1].m - ball[i].m)*ball[i-1].v + 2*ball[i].m*ball[i].v)/(ball[i].m + ball[i-1].m)\n            v2prime = ((ball[i].m - ball[i-1].m)*ball[i].v + 2*ball[i-1].m*ball[i-1].v)/(ball[i].m + ball[i-1].m)\n            ball[i-1].v.y = v1prime.y\n            ball[i].v.y = v2prime.y\n            ball[i].pos.y = ball[i-1].pos.y + Radius_I*(R[i-1] + R[i])\n        if ball[i].pos.y - Radius_I*R[i] < floor.pos.y + 0.5*floor.height:\n            ball[i].v.y = -ball[i].v.y\n            ball[i].pos.y = floor.pos.y + 0.5*floor.height + Radius_I*R[i]",
      "mode": "initial",
      "timestamp": "2024-07-29 16:16:15",
      "serial_number": 1
    }
  ]
}