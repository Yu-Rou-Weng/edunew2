{
  "session_id": 850,
  "log": [
    {
      "input": "Please write a \"Wood Block Spring System Elastic Collision\" VPython animation.\n\n# One-Dimensional Elastic Collision\n\nAssume there are two wood blocks on a horizontal smooth table, with masses $m_1$ and $m_2$, and velocities $v_1$ and $v_2$, respectively. After the collision, the velocities of the blocks change to $v_1'$ and $v_2'$. Since the collision process is free from external forces, the momentum of the system is conserved:\n$$\nm_1 v_1 + m_2 v_2 = m_1 v_1' + m_2 v_2' \\Rightarrow m_1 (v_1 - v_1') = m_2 (v_2' - v_2) \\quad (1)\n$$\n\nIf there is no loss of energy during the collision, then the total kinetic energy of the blocks before and after the collision remains equal:\n$$\n\\frac{1}{2} m_1 v_1^2 + \\frac{1}{2} m_2 v_2^2 = \\frac{1}{2} m_1 v_1'^2 + \\frac{1}{2} m_2 v_2'^2\n$$\n$$\nm_1 (v_1^2 - v_1'^2) = m_2 (v_2'^2 - v_2^2)\n$$\n$$\nm_1 (v_1 + v_1') (v_1 - v_1') = m_2 (v_2' + v_2) (v_2' - v_2) \\quad (2)\n$$\n\nDividing equation (2) by equation (1) gives:\n$$\nv_1 + v_1' = v_2' + v_2 \\Rightarrow\n\\begin{cases}\nv_1' = v_2' + v_2 - v_1 \\quad (3) \\\\\nv_2' = v_1 + v_1' - v_2 \\quad (4)\n\\end{cases}\n$$\n\nSubstituting equation (4) into equation (1) yields:\n$$\nm_1 (v_1 - v_1') = m_2 [(v_1 + v_1' - v_2) - v_2]\n$$\n$$\n(m_1 + m_2) v_1' = (m_1 - m_2) v_1 + 2 m_2 v_2 \\Rightarrow v_1' = \\frac{m_1 - m_2}{m_1 + m_2} v_1 + \\frac{2 m_2}{m_1 + m_2} v_2\n$$\n\nSubstituting equation (3) into equation (1) yields:\n$$\nm_1 [v_1 - (v_2' + v_2 - v_1)] = m_2 (v_2' - v_2)\n$$\n$$\n(m_1 + m_2) v_2' = 2 m_1 v_1 + (m_2 - m_1) v_2 \\Rightarrow v_2' = \\frac{2 m_1}{m_1 + m_2} v_1 + \\frac{m_2 - m_1}{m_1 + m_2} v_2\n$$\n\nWrite a program: directly use the post-collision velocity formulas.\n\n![image](https://hackmd.io/_uploads/S1x8VjadA.png)\n\n![image](https://hackmd.io/_uploads/H14w4jpOC.png)\nScreenshot of the one-dimensional elastic collision program.\n\nParameter Settings\n\nHere, variables are set for the blocks' width, mass, initial velocity, color, x-axis range, time, and time interval. The time interval dt is set to 0.0005 because setting it to 0.001 resulted in larger calculation errors for block energy, hence a smaller value was chosen. A 3 cm white spring is attached to the side where the green and red blocks collide as a buffer. There will be a floor.\n\nScreen Settings\nCode for generating the animation window, floor, blocks, and drawing window has appeared many times in previous animations and will not be repeated here.\n\nCustom Function\nLines 36 to 39 in the code define a function named af_col_v, which takes parameters (m1, m2, v1, v2) and returns the post-collision velocities v1_prime, v2_prime. This function is called at line 58 in the code:\n\nb1.v.x, b2.v.x = af_col_v(m1, m2, b1.v.x, b2.v.x)\nSince the return values are two, the program assigns the first return value to b1.v.x and the second to b2.v.x.\n\nObject Movement\nThe animation stops when a block reaches the edge, so the condition for the while loop is set to:\n\nb2.pos.x <= xmax - d2/2 and b1.pos.x >= xmin + d1/2\nIf the distance between the centers of the two blocks is less than (d1 + d2) / 2, it indicates a collision between the blocks, and the custom function af_col_v is called to calculate the post-collision velocity.\n\nThe blocks' positions are updated.\n\nBoth the red and green blocks have a width of 0.1. After the red block hits the spring, the green block will undergo the aforementioned wood block spring system elastic collision.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Speed_I as a cyber input variable, set Speed_I=1\n(2) Speed_I is the Initial velocity of b1. When Speed_I changes to a new value, Initial velocity of b1 also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# constants and data\ntable_length = 2\nb1_m, b2_m = 0.2, 0.2\nb1_v0, b2_v0 = 1, 0\nb1_d, b2_d = 0.1, 0.1\nb1_color, b2_color = color.red, color.green\nb1_x0, b2_x0 = -0.5, 0.5\n\n# scene\nscene = canvas(width=600, height=300, background=color.white, align=\"left\", range=1.3, center=vec(0, -0.3, 0))\nfloor = box(pos=vec(0,-0.6,0), size=vec(table_length, 0.05, 0.8), color=color.yellow)\nb1 = box(pos=vec(b1_x0, -0.5, 0), size=vec(b1_d, 0.05, 0.05), color=b1_color)\nb2 = box(pos=vec(b2_x0, -0.5, 0), size=vec(b2_d, 0.05, 0.05), color=b2_color)\nb1.v, b2.v = vec(b1_v0,0,0), vec(b2_v0,0,0)\n\n# graph\ngd = graph(width=600, height=300, align='right', xtitle='<i>t</i> (s)', ytitle='green: <i>p</i> (kg*m/s), blue: <i>K</i> (J)')\nk1_curve = gcurve(color=color.blue)\nk2_curve = gcurve(color=color.blue)\np1_curve = gcurve(color=color.green)\np2_curve = gcurve(color=color.green)\n\ndef af_col_v(m1, m2, v1, v2):\n    v1_prime = (m1 - m2) / (m1 + m2) * v1 + 2 * m2 / (m1 + m2) * v2\n    v2_prime = 2 * m1 / (m1 + m2) * v1 - (m1 - m2) / (m1 + m2) * v2\n    return v1_prime, v2_prime\n\nt = 0\ndt = 0.0005\nwhile True:\n    rate(1000)\n    if b2.pos.x <= table_length/2 - b2_d/2 and b1.pos.x >= -table_length/2 + b1_d/2:\n        b2.pos.x += b2.v.x * dt\n        b1.pos.x += b1.v.x * dt\n        if abs(b2.pos.x - b1.pos.x) <= (b1_d + b2_d) / 2:\n            b1.v.x, b2.v.x = af_col_v(b1_m, b2_m, b1.v.x, b2.v.x)\n        k1_curve.plot(pos=(t, b1_m * b1.v.x**2 / 2))\n        k2_curve.plot(pos=(t, b2_m * b2.v.x**2 / 2))\n        p1_curve.plot(pos=(t, b1_m * b1.v.x))\n        p2_curve.plot(pos=(t, b2_m * b2.v.x))\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-26 11:58:53",
      "serial_number": 1
    },
    {
      "input": "Please update the following program based on this instruction: The right side of the green block should be tied with a 3 cm spring.\n\nfrom vpython import *\n\n# constants and data\ntable_length = 2\nb1_m, b2_m = 0.2, 0.2\nb1_v0, b2_v0 = 1, 0\nb1_d, b2_d = 0.1, 0.1\nb1_color, b2_color = color.red, color.green\nb1_x0, b2_x0 = -0.5, 0.5\n\n# scene\nscene = canvas(width=600, height=300, background=color.white, align=\"left\", range=1.3, center=vec(0, -0.3, 0))\nfloor = box(pos=vec(0,-0.6,0), size=vec(table_length, 0.05, 0.8), color=color.yellow)\nb1 = box(pos=vec(b1_x0, -0.5, 0), size=vec(b1_d, 0.05, 0.05), color=b1_color)\nb2 = box(pos=vec(b2_x0, -0.5, 0), size=vec(b2_d, 0.05, 0.05), color=b2_color)\nb1.v, b2.v = vec(b1_v0,0,0), vec(b2_v0,0,0)\n\n# graph\ngd = graph(width=600, height=300, align='right', xtitle='<i>t</i> (s)', ytitle='green: <i>p</i> (kg*m/s), blue: <i>K</i> (J)')\nk1_curve = gcurve(color=color.blue)\nk2_curve = gcurve(color=color.blue)\np1_curve = gcurve(color=color.green)\np2_curve = gcurve(color=color.green)\n\ndef af_col_v(m1, m2, v1, v2):\n    v1_prime = (m1 - m2) / (m1 + m2) * v1 + 2 * m2 / (m1 + m2) * v2\n    v2_prime = 2 * m1 / (m1 + m2) * v1 - (m1 - m2) / (m1 + m2) * v2\n    return v1_prime, v2_prime\n\nt = 0\ndt = 0.0005\nwhile True:\n    rate(1000)\n    if b2.pos.x <= table_length/2 - b2_d/2 and b1.pos.x >= -table_length/2 + b1_d/2:\n        b2.pos.x += b2.v.x * dt\n        b1.pos.x += b1.v.x * dt\n        if abs(b2.pos.x - b1.pos.x) <= (b1_d + b2_d) / 2:\n            b1.v.x, b2.v.x = af_col_v(b1_m, b2_m, b1.v.x, b2.v.x)\n        k1_curve.plot(pos=(t, b1_m * b1.v.x**2 / 2))\n        k2_curve.plot(pos=(t, b2_m * b2.v.x**2 / 2))\n        p1_curve.plot(pos=(t, b1_m * b1.v.x))\n        p2_curve.plot(pos=(t, b2_m * b2.v.x))\n    t += dt",
      "output": "from vpython import *\n\n# constants and data\ntable_length = 2\nb1_m, b2_m = 0.2, 0.2\nb1_v0, b2_v0 = 1, 0\nb1_d, b2_d = 0.1, 0.1\nb1_color, b2_color = color.red, color.green\nb1_x0, b2_x0 = -0.5, 0.5\n\n# scene\nscene = canvas(width=600, height=300, background=color.white, align=\"left\", range=1.3, center=vec(0, -0.3, 0))\nfloor = box(pos=vec(0,-0.6,0), size=vec(table_length, 0.05, 0.8), color=color.yellow)\nb1 = box(pos=vec(b1_x0, -0.5, 0), size=vec(b1_d, 0.05, 0.05), color=b1_color)\nb2 = box(pos=vec(b2_x0, -0.5, 0), size=vec(b2_d, 0.05, 0.05), color=b2_color)\nb1.v, b2.v = vec(b1_v0,0,0), vec(b2_v0,0,0)\n\n# Spring\nspring = helix(pos=b2.pos, axis=b2.pos, radius=0.02, coils=20, color=color.orange)\nspring.pos = b2.pos\nspring.axis = vec(0.03, 0, 0)\n\n# graph\ngd = graph(width=600, height=300, align='right', xtitle='<i>t</i> (s)', ytitle='green: <i>p</i> (kg*m/s), blue: <i>K</i> (J)')\nk1_curve = gcurve(color=color.blue)\nk2_curve = gcurve(color=color.blue)\np1_curve = gcurve(color=color.green)\np2_curve = gcurve(color=color.green)\n\ndef af_col_v(m1, m2, v1, v2):\n    v1_prime = (m1 - m2) / (m1 + m2) * v1 + 2 * m2 / (m1 + m2) * v2\n    v2_prime = 2 * m1 / (m1 + m2) * v1 - (m1 - m2) / (m1 + m2) * v2\n    return v1_prime, v2_prime\n\nt = 0\ndt = 0.0005\nwhile True:\n    rate(1000)\n    if b2.pos.x <= table_length/2 - b2_d/2 and b1.pos.x >= -table_length/2 + b1_d/2:\n        b2.pos.x += b2.v.x * dt\n        b1.pos.x += b1.v.x * dt\n        spring.pos = b2.pos\n        spring.axis = vec(0.03, 0, 0)\n        if abs(b2.pos.x - b1.pos.x) <= (b1_d + b2_d) / 2:\n            b1.v.x, b2.v.x = af_col_v(b1_m, b2_m, b1.v.x, b2.v.x)\n        k1_curve.plot(pos=(t, b1_m * b1.v.x**2 / 2))\n        k2_curve.plot(pos=(t, b2_m * b2.v.x**2 / 2))\n        p1_curve.plot(pos=(t, b1_m * b1.v.x))\n        p2_curve.plot(pos=(t, b2_m * b2.v.x))\n    t += dt",
      "mode": "modification",
      "timestamp": "2024-07-26 12:01:13",
      "serial_number": 2
    }
  ]
}