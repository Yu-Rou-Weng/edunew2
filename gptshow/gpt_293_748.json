{
  "session_id": 748,
  "log": [
    {
      "input": "Please write a Vpython program for \"Free Fall Three Ball Collision\"\n\nOne-dimensional Elastic Collision Velocity Formula\n\nAssume two point masses have masses \\( m_1 \\) and \\( m_2 \\), and their velocities before collision are \\( v_1 \\) and \\( v_2 \\), respectively. The velocities after collision are \\( v_1' \\) and \\( v_2' \\), given by:\n\n\\[ v_1' = \\frac{m_1 - m_2}{m_1 + m_2} v_1 + \\frac{2m_2}{m_1 + m_2} v_2 \\]\n\n\\[ v_2' = \\frac{2m_1}{m_1 + m_2} v_1 + \\frac{m_2 - m_1}{m_1 + m_2} v_2 \\]\n\nWhere:\n- \\( v_1' \\) is the velocity of the object with mass \\( m_1 \\) after the collision\n- \\( v_2' \\) is the velocity of the object with mass \\( m_2 \\) after the collision\n- \\( v_1 \\) is the velocity of the object with mass \\( m_1 \\) before the collision\n- \\( v_2 \\) is the velocity of the object with mass \\( m_2 \\) before the collision\n\nThere are three balls, one is red, one is green, and another is blue. Please draw a wooden floor with a side length of 50. The red ball has a mass of 3 and a radius of 3, the green ball has a mass of 2 and a radius of 2, and the blue ball has a mass of 1 and a radius of 1. The three balls are stacked vertically with the green ball on top of the red ball, and the blue ball on top of the green ball. The green ball's bounce range is only between the red and blue balls, and the blue ball's bounce range is only above the green ball. Release the three stacked balls from a height of 15 above the floor, and the balls will start accelerating downward due to gravity. The three balls will adhere to the one-dimensional elastic collision. If the red ball hits the ground, it will bounce back. If the red and green balls collide, the mass of the red ball, the velocity of the red ball in the y direction, the mass of the green ball, and the velocity of the green ball in the y direction are substituted into the one-dimensional elastic collision formula to calculate the post-collision velocity, then reassign it to the red ball's y-direction velocity and the green ball's y-direction velocity. If the green ball and the blue ball collide, the mass of the green ball, the velocity of the green ball in the y direction, the mass of the blue ball, and the velocity of the blue ball in the y direction are substituted into the one-dimensional elastic collision formula to calculate the post-collision velocity, then reassign it to the green ball's y-direction velocity and the blue ball's y-direction velocity. Since the balls below: red and green are heavier than the blue, the bounce height of the blue ball will far exceed the original height from the ground.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\ng = 9.8\nsize = [3, 2, 1]\nm = [3, 2, 1]\nh = 15\ndt = 0.001\n\n# Objects\nfloor = box(length=50, height=0.01, width=50, color=color.black)\n\nRadius_I = 1  # Cyber input variable\n\nballs = [sphere(radius=size[0]*Radius_I, color=color.red, m=m[0], v=vector(0,0,0), pos=vector(0, size[0]*Radius_I, 0)),\n          sphere(radius=size[1]*Radius_I, color=color.green, m=m[1], v=vector(0,0,0), pos=vector(0, 2*size[0]*Radius_I+size[1]*Radius_I, 0)),\n          sphere(radius=size[2]*Radius_I, color=color.blue, m=m[2], v=vector(0,0,0), pos=vector(0, 2*size[0]*Radius_I+2*size[1]*Radius_I+size[2]*Radius_I, 0))]\n\n# Simulation\nwhile True:\n    rate(1/dt)\n    for i in range(3):\n        balls[i].pos += balls[i].v*dt\n        if i == 0 and balls[i].pos.y < size[i]*Radius_I:\n            balls[i].v.y = abs(balls[i].v.y)\n        elif i > 0 and balls[i].pos.y < balls[i-1].pos.y + size[i-1]*Radius_I + size[i]*Radius_I:\n            v1prime = ((balls[i-1].m - balls[i].m) / (balls[i-1].m + balls[i].m)) * balls[i-1].v.y + (2*balls[i].m / (balls[i-1].m + balls[i].m)) * balls[i].v.y\n            v2prime = (2*balls[i-1].m / (balls[i-1].m + balls[i].m)) * balls[i-1].v.y + ((balls[i].m - balls[i-1].m) / (balls[i-1].m + balls[i].m)) * balls[i].v.y\n            balls[i-1].v.y = v1prime\n            balls[i].v.y = v2prime\n        else:\n            balls[i].v.y -= g*dt",
      "mode": "initial",
      "timestamp": "2024-07-25 18:34:33",
      "serial_number": 1
    }
  ]
}