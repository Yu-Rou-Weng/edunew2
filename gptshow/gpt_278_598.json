{
  "session_id": 598,
  "log": [
    {
      "input": "Simple Harmonic Motion with Damping\n\nOn a horizontal, smooth tabletop, there is a block of mass $m$ attached to a wall on the left side by a spring with a spring constant $k$. If the block is pulled to the right by a distance $R$ and then released from rest, the relationship between the net force on the block and its acceleration is given by\n$$\nF = -kx = ma \\Rightarrow -kx = m \\frac{d^2 x}{d t^2}\n$$\nAt this point, the motion of the block is known as simple harmonic motion (S.H.M.), and from the above equation, we can derive\n$$\nx(t) = R \\cos(\\omega t + \\phi)\n$$\n$$\nv(t) = -\\omega R \\sin(\\omega t + \\phi)\n$$\n$$\na(t) = -\\omega^2 R \\cos(\\omega t + \\phi)\n$$\nwhere $\\omega$ is the angular frequency\n$$\n\\omega = \\sqrt{\\frac{k}{m}}\n$$\nand the period is\n$$\nT = 2\\pi \\sqrt{\\frac{m}{k}}\n$$\nTheoretically, by setting up the relationship between the restoring force of the spring and the block's displacement from the equilibrium position in VPython, we should be able to simulate the process and period of simple harmonic motion. The goal is to write a program for simple harmonic motion considering damping.\n\n### Theoretical Calculations [6]\n\nAssuming the block experiences a damping force\n$f = -bv$,\nfrom Newton's second law, we can derive\n$$\nma + bv + kx = 0\n$$\n$$\nm \\frac{d^2 x}{d t^2} + b \\frac{d x}{d t} + kx = 0\n$$\nThere are three scenarios:\n\n1. $b^2 > 4mk$ (overdamped)\n2. $b^2 = 4mk$ (critical damping)\n3. $b^2 < 4mk$ (underdamped)\n\n## Parameter Settings\n\nVariables defined here include m, size, R, k, L0, i, t, dt, with their purposes already commented in the script.\n\n## Display Settings\n\nSince we want the block's center to be on the x-axis, the floor is moved down to y = -(size+0.1)/2.\nTo allow the block to oscillate back and forth between $-R \\leq x \\leq R$, the wall is moved to the left to x = -L0.\nSince the block's position is centered, and the spring is connected to the left of the block, we need to place the block at size/2 to the right of the spring's endpoint.\nTo draw the spring, a new object called helix (spiral) is used, with adjustable options including:\n- Position (pos), based on the endpoint of the helix.\n- Radius (radius)\n- Axis (axis), starting from the position, formatted as a vector.\n- Thickness (thickness), the radius of the line itself, default is radius/20.\n- Color (color)\n\n## Object Motion\n\nFirst, calculate and update the spring's axis and length using `spring.axis = block.pos - spring.pos - vector(size/2, 0, 0)`, then calculate the spring's elongation and restoring force with `F = -k * (spring.axis - vector(L0, 0, 0))`.\nTo determine if the block returns to the starting point, various methods can be used; I use `block.pos.x > R + size/2` and check if the block's velocity direction is to the right, incrementing the count i by 1 and printing the time whenever the block returns to the starting point.\n\n## Program Design\n\nThe program for simple harmonic motion with damping is similar to that of simple harmonic motion, with two main differences:\n- The net force on the block is calculated as:\nF = -k * (spring.axis - vec(L0, 0, 0)) - b * block.v\n- Since the block does not return to the starting point, we use velocity to determine if a period has passed. If the block's velocity was initially to the right and later to the left, it indicates that the block has completed one period.\n\nvc = block.v.x\nif vp > 0 and vc < 0:\n    i += 1\n    print(i, t)\nvp = vc\n\n### Cyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Amplification_I as a cyber input variable, set Amplification_I=5\n(2) Amplification_I is the amplification of the block. When Amplification_I changes to a new value, the amplification of the block also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nm = 0.1  # block's mass\nsize = 0.02  # block's size\nR = 0.3  # initial displacement\nk = 10  # spring constant\nL0 = R + size/2  # spring's natural length\nomega = sqrt(k/m)  # angular frequency\nb = 0.5*m*omega  # damping coefficient\ni = 0  # period counter\nt = 0  # time\ndt = 0.001  # time interval\nvp = omega*R  # block's initial velocity\n\n# Display Settings\nscene = canvas(width=800, height=600, align='left')\nblock = box(pos=vector(R+size/2, 0, 0), size=vector(size, size, size), color=color.red)\nfloor = box(pos=vector(0, -(size+0.1)/2, 0), size=vector(1.5, 0.1, 0.8), color=color.green)\nwall = box(pos=vector(-L0, 0, 0), size=vector(0.01, 0.5, 0.5), color=color.blue)\nspring = helix(radius=0.02, thickness=0.01)\nspring.pos = wall.pos\nspring.axis = block.pos - spring.pos - vector(size/2, 0, 0)\n\n# Object Motion\nblock.v = vector(vp, 0, 0)\nwhile True:\n    rate(1/dt)\n    spring.axis = block.pos - spring.pos - vector(size/2, 0, 0)\n    F = -k * (spring.axis - vector(L0, 0, 0)) - b * block.v\n    block.a = F/m\n    block.v += block.a*dt\n    block.pos += block.v*dt\n    t += dt\n    # check if a period has passed\n    vc = block.v.x\n    if vp > 0 and vc < 0:\n        i += 1\n        print(i, t)\n    vp = vc",
      "mode": "initial",
      "timestamp": "2024-07-24 02:53:16",
      "serial_number": 1
    }
  ]
}