{
  "session_id": 886,
  "log": [
    {
      "input": "Stacked Wooden Blocks in a Completely Inelastic Collision\n\nThis is a problem that might appear in the basic physics course 2B, covering chapters on conservation of momentum, work and energy, and collisions. The problem is described as follows:\n\nWooden block A has a mass of 2m and wooden block B has a mass of m. The two blocks are stacked on top of each other, with no friction between block A and the tabletop, and block A has an initial velocity v. The coefficient of kinetic friction between the two blocks is \u03bck. Assuming the length of A is sufficient, A and B eventually move forward at the same velocity. The questions are: (1) What is the final velocity of blocks A and B? (2) How long does it take for their velocities to equalize?\n\nThere are two versions of the problem. In the first version, as depicted in the image, block B initially rests on the extreme right side of block A and is initially at rest, while block A moves to the right. In the second version, block B starts on the extreme left side of block A with an initial velocity to the right, while block A is initially at rest. The objective here is to write a program for simulating completely inelastic collisions between stacked wooden blocks.\n\nParameter Settings\nVariables are set for the block's length, width, height, mass, initial velocity, color, x-axis range, gravitational acceleration, coefficient of kinetic friction, time, and time interval. The time interval dt is set to 0.0005 because a setting of 0.001 results in greater computational error, hence a smaller value is chosen.\n\nScreen Setup\nMost of the functionalities have been used in previous animations and only the special parts need explanation: the initial position of b2 is determined by v1 and v2. If v2 >= v1, b2's initial position should be on the left side of b1; otherwise, immediately after the animation starts, b2 would fly out of b1. Conversely, if v2 < v1, b2's initial position should be on the right side of b1. Therefore, the following two lines of code are used to calculate b2\u2019s initial position:\n\nif(v2 >= v1): bx = xmin + d2/2\nelse: bx = xmin + d1 - d2/2\n\nObject Motion\nThe animation repeats until one of the following scenarios occurs:\n- b1 reaches the edge of the screen.\n- b2 reaches the edge of b1.\n\nTherefore, the condition in the while loop is set as:\n((b1.pos.x <= xmax - d1/2) and (b2.pos.x + d2/2 <= b1.pos.x + d1/2 + 0.001)\n\nAn additional 0.001 is added to the second condition to prevent the animation from stopping right after it starts when v1 > v2.\n\nDirection of the kinetic friction force between b1 and b2 depends on their velocities at the time, with three possible scenarios:\n- When b2.v.x > b1.v.x, the kinetic friction force acts to the right on b1 and to the left on b2.\n- When b2.v.x < b1.v.x, it acts to the left on b1 and to the right on b2.\n- When b2.v.x = b1.v.x, the kinetic friction force is zero.\n\nLines 60 to 71 of the code use if \u2026 elif \u2026 else statements to determine the magnitude and direction of the kinetic friction force. The else part can actually be omitted since b1.v.x and b2.v.x are both floating-point numbers, and it is nearly impossible for them to be equal.\n\nTo record the time it takes for b1 and b2 to reach the same velocity, lines 73 to 75 are used. Since b1.v.x and b2.v.x are unlikely to be exactly equal, the condition is set as abs(b2.v.x - b1.v.x) < 0.0005. This condition also includes i == 0 to ensure that it records only the first instance when the velocities are nearly equal, and sets i = 1 after executing the if code so it does not execute a second time.\n\nCalculate the acceleration of the blocks, update velocity and position, calculate the kinetic energy of the blocks.\n\nFinally, the final velocities of the blocks and the time it takes for b1 and b2 to reach the same velocity are printed.\n\nCyber Input Variable Mapping Information:\n(1) Define and initialize a variable named Friction_I as a cyber input variable, set Friction_I=0.1\n(2) Friction_I is the Coefficient of friction. When Friction_I changes to a new value, the Coefficient of friction also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameters\nm1 = 2\nm2 = 1\ng = 9.8\nv1 = 2\nv2 = 1\nFriction_I = 0.1\nd1 = 1\nd2 = 0.5\ndt = 0.0005\nt = 0\n\n# Visual objects\nfloor = box(pos=vector(0, -0.01, 0), size=vector(3, 0.02, d1), color=color.green)\nb1 = box(pos=vector(-0.5, d1/2, 0), size=vector(1, d1, d1), color=color.red)\nb2 = box(pos=vector(0.5, d1 + d2/2, 0), size=vector(1, d2, d2), color=color.blue)\n\n# Initial conditions\nb1.v = vector(v1, 0, 0)\nb2.v = vector(v2, 0, 0)\ni = 0\n\nwhile True:\n    rate(1000)\n    if abs(b2.v.x - b1.v.x) < 0.0005 and i == 0:\n        t_eq = t\n        i = 1\n\n    if b2.v.x > b1.v.x:\n        f = Friction_I*m2*g\n        b1.v.x += f/m1*dt\n        b2.v.x -= f/m2*dt\n    elif b2.v.x < b1.v.x:\n        f = Friction_I*m2*g\n        b1.v.x -= f/m1*dt\n        b2.v.x += f/m2*dt\n\n    b1.pos += b1.v*dt\n    b2.pos += b2.v*dt\n    t += dt\n\n    if b1.pos.x > 1 - d1/2 or b2.pos.x + d2/2 > b1.pos.x + d1/2 + 0.001:\n        break\n\nprint(\"Final velocity of block 1:\", b1.v.x)\nprint(\"Final velocity of block 2:\", b2.v.x)\nprint(\"Time for velocities to equalize:\", t_eq)",
      "mode": "initial",
      "timestamp": "2024-07-31 10:41:47",
      "serial_number": 1
    }
  ]
}