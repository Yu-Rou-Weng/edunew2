{
  "session_id": 681,
  "log": [
    {
      "input": "# Vertical Circular Motion\n\n## Theoretical Analysis\n\nTo simplify the calculations, I set the center of the circle at the origin, with the small ball starting from $(0, R, 0)$ at an initial velocity of $(-v_0, 0, 0)$. The acceleration can be divided into the normal acceleration $a_n$, which is the centripetal acceleration $a_c$, and the tangential acceleration $a_t$ that changes the magnitude of the velocity. The calculation method for $a_n$ is the same as in Program 7-1 and will not be repeated here. The source of $a_t$ is the tangential component of gravitational acceleration, assuming the angle between the ball and the vertical line is $\\theta$, then $$a_t = g \\sin{\\theta}$$\n\nThe y-component of $a_t$ points downward, with a magnitude of $$a_{t,y} = a_t \\sin{\\theta} = g \\sin^2{\\theta}$$\n\nThe x-component of $a_t$ depends on its position; it points to the right in the 1st and 3rd quadrants and to the left in the 2nd and 4th quadrants, with a magnitude of\n$$\na_{t,x} = a_t \\cos{\\theta} = g \\sin{\\theta} \\cos{\\theta}\n$$\n\nIf we only want to find the period, it can be calculated using the conservation of mechanical energy. Assuming the speed of the ball at the highest point is\n$$\nv_0 = \\sqrt{ngR}\n$$\n\nFrom the conservation of mechanical energy, the relationship between any point and the highest point [9] can be written as\n$$\n\\frac{1}{2} m v^2 + m g R \\cos{\\theta} = \\frac{1}{2} m n^2 g R + m g R\n$$\n$$\nv = R \\frac{d\\theta}{dt} = \\sqrt{(n^2 + 2 - 2 \\cos{\\theta}) g R}\n$$\n$$\nT = \\int_0^T dt = 2 \\frac{R}{g} \\int_0^\\pi \\frac{d\\theta}{\\sqrt{n^2 + 2 - 2 \\cos{\\theta}}}\n$$\n\n## Parameter Settings\n\nThe variables defined here include size, R, g, v0, ratio, i, t, dt, and their purposes are already noted in the comments of each line. To reduce the error caused by the length of the time interval, dt is adjusted to 0.0001.\n\n## Screen Settings\n\nThe small ball moves in the xy-plane, starting from the top of the screen at a distance R, with the initial velocity direction towards the -x axis, and no need to adjust the observer's position and direction.\nThe axis of rotation is directed towards the +z axis.\narrow_v and arrow_a are arrows representing the velocity and acceleration of the small ball.\n\n## Custom Functions\n\nThe custom function findan, takes v and pos as parameters, both in vector format, to calculate the ball's normal acceleration an.\nThe custom function findat, takes pos as a parameter, in vector format, to calculate the ball's tangential acceleration $a_t$. The angle between the rope and the vertical line is $\\theta$, first calculating $\\sin{\\theta}$ and $\\cos{\\theta}$, and since $\\theta$ only takes acute angles, both are positive. Then calculate $a_{t,y}$ and $a_{t,x}$, and determine the sign of $a_{t,x}$ based on pos.\n\n## Object Movement\n\nThe condition for the ball to return to the starting point is that its original position xp is in the +x region, and its current position xc is in the -x region. If it returns to the starting point, the elapsed time t is printed, i is incremented by 1, and the animation stops after the ball returns to the starting point 5 times.\nDue to the small dt, the number of calculations per second is changed to 5000 to speed up the animation.\nUsing the custom functions findan and findat to calculate the ball's normal and tangential accelerations.\nUpdate the ball's velocity, position, and the starting position, direction, and length of the arrows; update time.\n\n## Data Processing\n\nIf the speed of the ball at the highest point is\n$$\nv_0 = n \\sqrt{gR}\n$$\n, substituting n from 1 to 7, the periods are found using simulation and theoretical calculations, as shown below:\n\n| n | v0 | Theoretical T | Simulated T |\n|---|----|---------------|-------------|\n| 1 | 7  | 2.8841511713977500 | 2.8838000000016613 |\n| 2 | 14 | 1.8728982530658000 | 1.8728999999998102 |\n| 3 | 21 | 1.3617223964215400 | 1.3617999999999999 |\n| 4 | 28 | 1.0602946238731300 | 1.0602999999998997 |\n| 5 | 35 | 0.8646052540953560 | 0.8645999999999211 |\n| 6 | 42 | 0.7284267507699600 | 0.7283999999999361 |\n| 7 | 49 | 0.6286255969937600 | 0.6285999999999471 |\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=0.5\n\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nR = 0.5\ng = 9.8\nv0 = -g*R**0.5\nratio = 5\ni = 0\nt = 0\ndt = 0.0001\ntheta = 0\n\n# Screen Settings\nscene = canvas(width=800, height=800, background=color.white)\nball = sphere(pos=vector(0, R, 0), radius=R/5, color=color.red)\nceiling = box(length=0.8, height=0.005, width=0.8, pos=vector(0, R+R/5, 0))\npivot = vector(0,0,0)\nrod = cylinder(pos=pivot, axis=ball.pos-pivot, radius=R/40)\narrow_v = arrow(pos=ball.pos, axis=v0*ratio*vector(-1,0,0), shaftwidth=R/4, color=color.green)\narrow_a = arrow(pos=ball.pos, axis=-g*ratio*vector(0,1,0), shaftwidth=R/4, color=color.blue)\n\n# Custom Functions\ndef findan(v, pos):\n    return mag(v)**2/R*(-pos/mag(pos))\n\ndef findat(pos):\n    s = mag(pos)\n    cosa = pos.y/s\n    sina = (s**2 - pos.y**2)**0.5/s\n    at = g*sina\n    aty = -at*cosa\n    atx = (at**2 - aty**2)**0.5\n    if pos.x>0:\n        atx = -atx\n    return vector(atx, aty, 0)\n\n# Object Movement\nwhile i<5:\n    rate(5000)\n    an = findan(vector(v0,0,0), ball.pos)\n    at = findat(ball.pos)\n    a = an + at\n    v0 += a*dt\n    ball.pos += vector(v0,0,0)*dt\n    rod.axis = ball.pos - rod.pos\n    arrow_v.pos = ball.pos\n    arrow_v.axis = v0*ratio*vector(-1,0,0)\n    arrow_a.pos = ball.pos\n    arrow_a.axis = a*ratio*vector(-1,0,0)\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 09:11:37",
      "serial_number": 1
    },
    {
      "input": "Please update the program by fixing the following error:\nCannot add a scalar and a vector.\n\nHere's the current program:\nfrom vpython import *\n\n# Parameter Settings\nR = 0.5\ng = 9.8\nv0 = -g*R**0.5\nratio = 5\ni = 0\nt = 0\ndt = 0.0001\ntheta = 0\n\n# Screen Settings\nscene = canvas(width=800, height=800, background=color.white)\nball = sphere(pos=vector(0, R, 0), radius=R/5, color=color.red)\nceiling = box(length=0.8, height=0.005, width=0.8, pos=vector(0, R+R/5, 0))\npivot = vector(0,0,0)\nrod = cylinder(pos=pivot, axis=ball.pos-pivot, radius=R/40)\narrow_v = arrow(pos=ball.pos, axis=v0*ratio*vector(-1,0,0), shaftwidth=R/4, color=color.green)\narrow_a = arrow(pos=ball.pos, axis=-g*ratio*vector(0,1,0), shaftwidth=R/4, color=color.blue)\n\n# Custom Functions\ndef findan(v, pos):\n    return mag(v)**2/R*(-pos/mag(pos))\n\ndef findat(pos):\n    s = mag(pos)\n    cosa = pos.y/s\n    sina = (s**2 - pos.y**2)**0.5/s\n    at = g*sina\n    aty = -at*cosa\n    atx = (at**2 - aty**2)**0.5\n    if pos.x>0:\n        atx = -atx\n    return vector(atx, aty, 0)\n\n# Object Movement\nwhile i<5:\n    rate(5000)\n    an = findan(vector(v0,0,0), ball.pos)\n    at = findat(ball.pos)\n    a = an + at\n    v0 += a*dt\n    ball.pos += vector(v0,0,0)*dt\n    rod.axis = ball.pos - rod.pos\n    arrow_v.pos = ball.pos\n    arrow_v.axis = v0*ratio*vector(-1,0,0)\n    arrow_a.pos = ball.pos\n    arrow_a.axis = a*ratio*vector(-1,0,0)\n    t += dt",
      "output": "from vpython import *\n\n# Parameter Settings\nR = 0.5\ng = 9.8\nv0 = vector(-g*R**0.5, 0, 0)\nratio = 5\ni = 0\nt = 0\ndt = 0.0001\ntheta = 0\n\n# Screen Settings\nscene = canvas(width=800, height=800, background=color.white)\nball = sphere(pos=vector(0, R, 0), radius=R/5, color=color.red)\nceiling = box(length=0.8, height=0.005, width=0.8, pos=vector(0, R+R/5, 0))\npivot = vector(0,0,0)\nrod = cylinder(pos=pivot, axis=ball.pos-pivot, radius=R/40)\narrow_v = arrow(pos=ball.pos, axis=v0*ratio*vec(-1,0,0), shaftwidth=R/4, color=color.green)\narrow_a = arrow(pos=ball.pos, axis=-g*ratio*vec(0,1,0), shaftwidth=R/4, color=color.blue)\n\n# Custom Functions\ndef findan(v, pos):\n    return mag(v)**2/R*(-pos/mag(pos))\n\ndef findat(pos):\n    s = mag(pos)\n    cosa = pos.y/s\n    sina = (s**2 - pos.y**2)**0.5/s\n    at = g*sina\n    aty = -at*cosa\n    atx = (at**2 - aty**2)**0.5\n    if pos.x>0:\n        atx = -atx\n    return vector(atx, aty, 0)\n\n# Object Movement\nwhile i<5:\n    rate(5000)\n    an = findan(v0, ball.pos)\n    at = findat(ball.pos)\n    a = an + at\n    v0 += a*dt\n    ball.pos += v0*dt\n    rod.axis = ball.pos - rod.pos\n    arrow_v.pos = ball.pos\n    arrow_v.axis = v0*ratio*vec(-1,0,0)\n    arrow_a.pos = ball.pos\n    arrow_a.axis = a*ratio*vec(-1,0,0)\n    t += dt",
      "mode": "fix_error",
      "timestamp": "2024-07-24 09:11:58",
      "serial_number": 2
    },
    {
      "input": "Please update the program by fixing the following error:\nCannot add a scalar and a vector.\n\nHere's the current program:\nfrom vpython import *\n\n# Parameter Settings\nR = 0.5\ng = 9.8\nv0 = -g*R**0.5\nratio = 5\ni = 0\nt = 0\ndt = 0.0001\ntheta = 0\n\n# Screen Settings\nscene = canvas(width=800, height=800, background=color.white)\nball = sphere(pos=vector(0, R, 0), radius=R/5, color=color.red)\nceiling = box(length=0.8, height=0.005, width=0.8, pos=vector(0, R+R/5, 0))\npivot = vector(0,0,0)\nrod = cylinder(pos=pivot, axis=ball.pos-pivot, radius=R/40)\narrow_v = arrow(pos=ball.pos, axis=v0*ratio*vector(-1,0,0), shaftwidth=R/4, color=color.green)\narrow_a = arrow(pos=ball.pos, axis=-g*ratio*vector(0,1,0), shaftwidth=R/4, color=color.blue)\n\n# Custom Functions\ndef findan(v, pos):\n    return mag(v)**2/R*(-pos/mag(pos))\n\ndef findat(pos):\n    s = mag(pos)\n    cosa = pos.y/s\n    sina = (s**2 - pos.y**2)**0.5/s\n    at = g*sina\n    aty = -at*cosa\n    atx = (at**2 - aty**2)**0.5\n    if pos.x>0:\n        atx = -atx\n    return vector(atx, aty, 0)\n\n# Object Movement\nwhile i<5:\n    rate(5000)\n    an = findan(vector(v0,0,0), ball.pos)\n    at = findat(ball.pos)\n    a = an + at\n    v0 += a*dt\n    ball.pos += vector(v0,0,0)*dt\n    rod.axis = ball.pos - rod.pos\n    arrow_v.pos = ball.pos\n    arrow_v.axis = v0*ratio*vector(-1,0,0)\n    arrow_a.pos = ball.pos\n    arrow_a.axis = a*ratio*vector(-1,0,0)\n    t += dt",
      "output": "from vpython import *\n\n# Parameter Settings\nR = 0.5\ng = vector(0, -9.8, 0)\nv0 = -g*R**0.5\nratio = 5\ni = 0\nt = 0\ndt = 0.0001\ntheta = 0\n\n# Screen Settings\nscene = canvas(width=800, height=800, background=color.white)\nball = sphere(pos=vector(0, R, 0), radius=R/5, color=color.red)\nceiling = box(length=0.8, height=0.005, width=0.8, pos=vector(0, R+R/5, 0))\npivot = vector(0,0,0)\nrod = cylinder(pos=pivot, axis=ball.pos-pivot, radius=R/40)\narrow_v = arrow(pos=ball.pos, axis=v0*ratio*vector(-1,0,0), shaftwidth=R/4, color=color.green)\narrow_a = arrow(pos=ball.pos, axis=-g*ratio, shaftwidth=R/4, color=color.blue)\n\n# Custom Functions\ndef findan(v, pos):\n    return mag(v)**2/R*(-pos/mag(pos))\n\ndef findat(pos):\n    s = mag(pos)\n    cosa = pos.y/s\n    sina = (s**2 - pos.y**2)**0.5/s\n    at = g*sina\n    aty = -at*cosa\n    atx = (at**2 - aty**2)**0.5\n    if pos.x>0:\n        atx = -atx\n    return vector(atx, aty, 0)\n\n# Object Movement\nwhile i<5:\n    rate(5000)\n    an = findan(vector(mag(v0),0,0), ball.pos)\n    at = findat(ball.pos)\n    a = an + at\n    v0 += a*dt\n    ball.pos += vector(mag(v0),0,0)*dt\n    rod.axis = ball.pos - rod.pos\n    arrow_v.pos = ball.pos\n    arrow_v.axis = mag(v0)*ratio*vector(-1,0,0)\n    arrow_a.pos = ball.pos\n    arrow_a.axis = a*ratio\n    t += dt",
      "mode": "fix_error",
      "timestamp": "2024-07-24 09:12:00",
      "serial_number": 3
    }
  ]
}