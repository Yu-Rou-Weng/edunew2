{
  "session_id": 812,
  "log": [
    {
      "input": "Motion of Charged Particles in a Magnetic Field\n\nThe magnetic force on a charged particle in a uniform magnetic field is given by\n$$\n\\vec{F}_B = q (\\vec{v} \\times \\vec{B}) \\Rightarrow F_B = qvB \\sin{\\theta}\n$$\nwhere $q$ is the charge of the particle, $v_0$ is the speed of the particle, and $B$ is the external magnetic field. There are three possible types of motion:\n\n- $\\theta = 0^\\circ$ or $180^\\circ$: $F_B = 0$, uniform linear motion\n- $\\theta = 90^\\circ$: $F_B = qvB$, uniform circular motion\n- Other angles: Helical motion, moving forward while circling\n\nThe objective this time is to illustrate these three states of motion, and the viewing angle of the animation window will automatically rotate to a convenient direction based on the angle between the velocity and the magnetic field.\n\nHelical motion diagram:\n![image](https://hackmd.io/_uploads/BkS9t3TuC.png)\n\nParameter Settings\n\nVariables are set for size, m, theta, phi, v0, q, L, B_field, t, dt, with their purposes noted in the comments. To ensure a smoother animation, the particle's charge and mass are intentionally increased substantially.\n\nDisplay Settings\nCreate an animation window, rotate the view according to theta and phi. If the condition (theta == pi/2 or phi == pi/2) is met, then view from (L, L/4, L/4) towards the origin; if not, then view from (L/4, L/4, L) towards the origin.\nCreate a charged particle and set its initial velocity.\nCreate coordinate axes and labels.\nCreate arrows and labels to represent the magnetic field.\nCreate arrows for velocity and acceleration.\n\nObject Motion\nSince I want the particle to move only within a cubic space with side length 1.2 L and stop at the edges, the while loop condition is set to abs(charge.pos.x) < 0.6*L and abs(charage.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L.\nCalculate the total force on the charged particle, update the particle\u2019s acceleration, velocity, and position.\nUpdate arrows representing velocity and acceleration, only showing direction to prevent the animation from automatically shrinking.\nUpdate time.\n\nSimulation Results\n\nPlease illustrate the scene in the picture:\n\n2. theta = 90, phi = 0 \u21d2 No x-component in velocity, performing uniform circular motion in the yz-plane\n![image](https://hackmd.io/_uploads/Hy31qhpOA.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameters\nsize, m = 0.02, 0.2\ntheta, phi = pi/3, pi/4\nv0, q = 1, 5e-5\nL, B_field = 1, vector(0,0,1)\n\n# Animation window\nscene = canvas(width=800, height=800, background=vector(0.5,0.5,0))\nif (theta == pi/2 or phi == pi/2):\n    scene.camera.pos, scene.camera.axis = vector(L,L/4,L/4), vector(-L,-L/4,-L/4)\nelse:\n    scene.camera.pos, scene.camera.axis = vector(L/4,L/4,L), vector(-L/4,-L/4,-L)\n\n# Charged particle\ncharge = sphere(pos=vector(0,0,0), radius=0.02, m=m, q=q, v=v0*vector(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)),\n                color=color.red, make_trail=True)\n\n# Coordinate axes\naxis_x = cylinder(pos=vector(-L,0,0), axis=vector(2*L,0,0), radius=L/100, color=color.blue)\naxis_y = cylinder(pos=vector(0,-L,0), axis=vector(0,2*L,0), radius=L/100, color=color.blue)\naxis_z = cylinder(pos=vector(0,0,-L), axis=vector(0,0,2*L), radius=L/100, color=color.blue)\nlabel_x = label(pos=vector(L,0,0), text='x', height=30, box=False)\nlabel_y = label(pos=vector(0,L,0), text='y', height=30, box=False)\nlabel_z = label(pos=vector(0,0,L), text='z', height=30, box=False)\n\n# Magnetic field\nB = arrow(pos=vector(-L/2,-L/2,-L/2), axis=L*B_field, color=color.green, shaftwidth=L/20)\nlabel_B = label(pos=B.pos+1.2*B.axis, text='B', height=30, box = False)\n\n# Velocity\nv_vector = arrow(pos=charge.pos, axis=m*charge.v, color=color.yellow, shaftwidth=L/100)\nlabel_v = label(pos=v_vector.pos+1.2*v_vector.axis, text='v', height=30, box = False, opacity=0)\n\n# Acceleration\na_vector = arrow(pos=charge.pos, axis=vector(0,0,0), color=color.cyan, shaftwidth=L/100)\nlabel_a = label(pos=a_vector.pos, text='a', height=30, box = False, opacity=0)\n\n# Time parameters\nt, dt = 0, 0.001\n\nwhile abs(charge.pos.x)<0.6*L and abs(charge.pos.y)<0.6*L and abs(charge.pos.z)<0.6*L:\n    rate(1000)\n    B_field = vector(0,0,B)\n    F = charge.q*cross(charge.v, B_field)\n    charge.a = F/charge.m\n    charge.v += charge.a*dt\n    charge.pos += charge.v*dt\n    v_vector.pos = charge.pos\n    v_vector.axis = m*charge.v\n    label_v.pos = v_vector.pos+1.2*v_vector.axis\n    a_vector.pos = charge.pos\n    a_vector.axis = m*charge.a\n    label_a.pos = a_vector.pos+1.2*a_vector.axis\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-26 02:45:03",
      "serial_number": 1
    }
  ]
}