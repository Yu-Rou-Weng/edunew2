{
  "session_id": 857,
  "log": [
    {
      "input": "Please write a VPython animation for \"Wooden Block Spring System Elastic Collision\"\n\n# One-Dimensional Elastic Collision\n\nAssume there are two wooden blocks on a horizontal smooth table, with masses $m_1$ and $m_2$, and velocities $v_1$ and $v_2$, respectively. The velocities of the blocks after collision are $v_1'$ and $v_2'$. Since the collision process is free from external forces, the system's momentum is conserved:\n$$\nm_1 v_1 + m_2 v_2 = m_1 v_1' + m_2 v_2' \\Rightarrow m_1 (v_1 - v_1') = m_2 (v_2' - v_2) \\quad (1)\n$$\n\nIf there is no loss of energy during the collision, then the total kinetic energy of the blocks before and after the collision remains equal:\n$$\n\\frac{1}{2} m_1 v_1^2 + \\frac{1}{2} m_2 v_2^2 = \\frac{1}{2} m_1 v_1'^2 + \\frac{1}{2} m_2 v_2'^2\n$$\n$$\nm_1 (v_1^2 - v_1'^2) = m_2 (v_2'^2 - v_2^2)\n$$\n$$\nm_1 (v_1 + v_1') (v_1 - v_1') = m_2 (v_2' + v_2) (v_2' - v_2) \\quad (2)\n$$\n\nDividing equation (2) by equation (1), we get:\n$$\nv_1 + v_1' = v_2' + v_2 \\Rightarrow\n\\begin{cases}\nv_1' = v_2' + v_2 - v_1 \\quad (3) \\\\\nv_2' = v_1 + v_1' - v_2 \\quad (4)\n\\end{cases}\n$$\n\nSubstituting equation (4) into equation (1), we find:\n$$\nm_1 (v_1 - v_1') = m_2 [(v_1 + v_1' - v_2) - v_2]\n$$\n$$\n(m_1 + m_2) v_1' = (m_1 - m_2) v_1 + 2 m_2 v_2 \\Rightarrow v_1' = \\frac{m_1 - m_2}{m_1 + m_2} v_1 + \\frac{2 m_2}{m_1 + m_2} v_2\n$$\n\nSubstituting equation (3) into equation (1), we find:\n$$\nm_1 [v_1 - (v_2' + v_2 - v_1)] = m_2 (v_2' - v_2)\n$$\n$$\n(m_1 + m_2) v_2' = 2 m_1 v_1 + (m_2 - m_1) v_2 \\Rightarrow v_2' = \\frac{2 m_1}{m_1 + m_2} v_1 + \\frac{m_2 - m_1}{m_1 + m_2} v_2\n$$\n\nProgram to be written: directly substitute the post-collision velocity formulas.\n\n![image](https://hackmd.io/_uploads/S1x8VjadA.png)\n\n![image](https://hackmd.io/_uploads/H14w4jpOC.png)\nScreenshot of the one-dimensional elastic collision program\n\nParameter Settings\n\nHere, variables are set for the block's width, mass, initial velocity, color, x-axis range, time, and time interval. The time interval dt is set to 0.0005, as setting it to 0.001 would generate a larger error when calculating the block's energy, hence a smaller value has been chosen. A 3 cm white spring is tied to the right side of the green block, serving as a buffer during collision. There will be a floor.\n\nScreen Setup\n\nThe code for generating the animation window, the floor, the blocks, and the plotting window has appeared multiple times in previous animations, and is not repeated here.\n\nCustom Functions\n\nLines 36 to 39 of the code define a function named af_col_v, which accepts the parameters (m1, m2, v1, v2) and returns the velocities after collision, v1_prime and v2_prime. This function is called on line 58 of the code:\n\nb1.v.x, b2.v.x = af_col_v(m1, m2, b1.v.x, b2.v.x)\nSince the function returns two values, the program assigns the first return value to b1.v.x and the second to b2.v.x.\n\nObject Motion\n\nThe animation stops when the blocks reach the edge, so the condition for the while loop is set as:\n\nb2.pos.x <= xmax - d2/2 and b1.pos.x >= xmin + d1/2\nIf the distance between the centers of the two blocks is less than (d1 + d2) / 2, this indicates a collision between the blocks, and the custom function af_col_v is called to calculate the velocity after collision.\n\nUpdate the block's position.\n\nBoth the red and green blocks have a width of 0.1. A 3 cm spring is attached to the right side of the green block, which, when collided by the red block, undergoes the aforementioned wooden block spring system elastic collision. A 3 cm spring should also be attached to the left side of the green block, tied to the green block, and will move together with the green block without separating.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Speed_I as a cyber input variable, set Speed_I=1\n(2) Speed_I is the Initial velocity of b1. When Speed_I changes to a new value, the Initial velocity of b1 also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Function for post-collision velocity\ndef af_col_v(m1, m2, v1, v2):\n    v1_prime = (m1-m2)*v1/(m1+m2) + 2*m2*v2/(m1+m2)\n    v2_prime = 2*m1*v1/(m1+m2) + (m2-m1)*v2/(m1+m2)\n    return v1_prime, v2_prime\n\n# Parameters\nm1, m2 = 1.0, 1.0\nv1, v2 = 1.0, 0.0\nd1, d2 = 0.1, 0.1\nx1, x2 = -0.5, 0.5\nt, dt = 0, 0.0005\nxmax, xmin = 0.6, -0.6\n\n# Animation\nscene = canvas(width=600, height=300, align='left', background=vec(1,1,1))\nfloor = box(length=1.2, height=0.005, width=0.8, color=vec(0.5,0.5,0.5))\n\nb1 = box(pos=vec(x1, d1/2, 0), size=vec(d1, d1, d1), color=color.red, v=vec(v1, 0, 0))\nb2 = box(pos=vec(x2, d2/2, 0), size=vec(d2, d2, d2), color=color.green, v=vec(v2, 0, 0))\nspring = helix(radius=0.02, thickness=0.01)\nspring.pos = b2.pos + vec(d2/2, -d2/4, 0)\nspring.axis = b1.pos - spring.pos\n\n# Loop\nwhile b2.pos.x <= xmax - d2/2 and b1.pos.x >= xmin + d1/2:\n    rate(1000)\n    if abs(b1.pos.x - b2.pos.x) <= (d1 + d2) / 2:\n        b1.v.x, b2.v.x = af_col_v(m1, m2, b1.v.x, b2.v.x)\n    b1.pos = b1.pos + b1.v*dt\n    b2.pos = b2.pos + b2.v*dt\n    spring.axis = b1.pos - spring.pos",
      "mode": "initial",
      "timestamp": "2024-07-26 12:15:13",
      "serial_number": 1
    },
    {
      "input": "Please update the following program based on this instruction: The spring will only be connected to the green block and will not be connected to the red block.\n\nPlease update the following program by the above description:\nfrom vpython import *\n\n# Function for post-collision velocity\ndef af_col_v(m1, m2, v1, v2):\n    v1_prime = (m1-m2)*v1/(m1+m2) + 2*m2*v2/(m1+m2)\n    v2_prime = 2*m1*v1/(m1+m2) + (m2-m1)*v2/(m1+m2)\n    return v1_prime, v2_prime\n\n# Parameters\nm1, m2 = 1.0, 1.0\nv1, v2 = 1.0, 0.0\nd1, d2 = 0.1, 0.1\nx1, x2 = -0.5, 0.5\nt, dt = 0, 0.0005\nxmax, xmin = 0.6, -0.6\n\n# Animation\nscene = canvas(width=600, height=300, align='left', background=vec(1,1,1))\nfloor = box(length=1.2, height=0.005, width=0.8, color=vec(0.5,0.5,0.5))\n\nb1 = box(pos=vec(x1, d1/2, 0), size=vec(d1, d1, d1), color=color.red, v=vec(v1, 0, 0))\nb2 = box(pos=vec(x2, d2/2, 0), size=vec(d2, d2, d2), color=color.green, v=vec(v2, 0, 0))\nspring = helix(radius=0.02, thickness=0.01)\nspring.pos = b2.pos + vec(d2/2, -d2/4, 0)\nspring.axis = b1.pos - spring.pos\n\n# Loop\nwhile b2.pos.x <= xmax - d2/2 and b1.pos.x >= xmin + d1/2:\n    rate(1000)\n    if abs(b1.pos.x - b2.pos.x) <= (d1 + d2) / 2:\n        b1.v.x, b2.v.x = af_col_v(m1, m2, b1.v.x, b2.v.x)\n    b1.pos = b1.pos + b1.v*dt\n    b2.pos = b2.pos + b2.v*dt\n    spring.axis = b1.pos - spring.pos\n\n",
      "output": "from vpython import *\n\n# Function for post-collision velocity\ndef af_col_v(m1, m2, v1, v2):\n    v1_prime = (m1-m2)*v1/(m1+m2) + 2*m2*v2/(m1+m2)\n    v2_prime = 2*m1*v1/(m1+m2) + (m2-m1)*v2/(m1+m2)\n    return v1_prime, v2_prime\n\n# Parameters\nm1, m2 = 1.0, 1.0\nv1, v2 = 1.0, 0.0\nd1, d2 = 0.1, 0.1\nx1, x2 = -0.5, 0.5\nt, dt = 0, 0.0005\nxmax, xmin = 0.6, -0.6\n\n# Animation\nscene = canvas(width=600, height=300, align='left', background=vec(1,1,1))\nfloor = box(length=1.2, height=0.005, width=0.8, color=vec(0.5,0.5,0.5))\n\nb1 = box(pos=vec(x1, d1/2, 0), size=vec(d1, d1, d1), color=color.red, v=vec(v1, 0, 0))\nb2 = box(pos=vec(x2, d2/2, 0), size=vec(d2, d2, d2), color=color.green, v=vec(v2, 0, 0))\nspring = helix(radius=0.02, thickness=0.01)\nspring.pos = b2.pos + vec(d2/2, -d2/4, 0)\nspring.axis = vec(0,0,0)\n\n# Loop\nwhile b2.pos.x <= xmax - d2/2 and b1.pos.x >= xmin + d1/2:\n    rate(1000)\n    if abs(b1.pos.x - b2.pos.x) <= (d1 + d2) / 2:\n        b1.v.x, b2.v.x = af_col_v(m1, m2, b1.v.x, b2.v.x)\n    b1.pos = b1.pos + b1.v*dt\n    b2.pos = b2.pos + b2.v*dt\n    spring.pos = b2.pos + vec(d2/2, -d2/4, 0)\n    spring.axis = vec(0,0,0)",
      "mode": "modification",
      "timestamp": "2024-07-26 12:17:17",
      "serial_number": 2
    }
  ]
}