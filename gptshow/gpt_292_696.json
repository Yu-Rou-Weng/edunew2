{
  "session_id": 696,
  "log": [
    {
      "input": "Free Fall Collision of Two Balls\n\nIf you stack two highly elastic balls, one on top of the other, with the heavier ball on the bottom, and release them from a certain height, the balls will start accelerating downward due to gravity. What happens when the bottom ball hits the ground and bounces back? There are many experimental videos on YouTube, such as \"Stacked Ball Drop.\" We can use previously written simulation programs for \"Free Fall\" and \"One-Dimensional Elastic Collision\" to address this question.\n\nScreenshot of the program for the free fall collision of two balls: ![image](https://hackmd.io/_uploads/SyOtLjT_C.png)\n\nThe program for the free fall collision involves two balls.\n\nParameter Settings\n\nHere, variables are set for the radius, mass, and color of the balls, the height of the balls from the ground, the length of the floor, gravitational acceleration, time, and time intervals. Please refer to the program code for the corresponding variable names.\n\nDisplay Settings\nThe code to create the animation window, floor, balls, and drawing window has appeared many times in previous animations and will not be detailed here. A special feature in the animation window is the addition of an option \"range=L,\" which limits the display range of the animation window to prevent the screen from automatically shrinking if the top ball bounces too high.\n\nMotion of Objects\nUpdate the speed and position of the balls.\nIf b1.pos.y <= 0, it means b1 has hit the floor; invert the velocity to make b1 bounce.\nIf b2.pos.y - b1.pos.y <= r1 + r2, it means b1 and b2 have collided; insert m1, b1.v.y, m2, b2.v.y into a custom function af_col_v to calculate the post-collision velocities, then reassign these to b1.v.y and b2.v.y.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Custom function to calculate post-collision velocities\ndef af_col_v(m1, v1, m2, v2):\n    return [(v1*(m1-m2)+2*m2*v2)/(m1+m2), (v2*(m2-m1)+2*m1*v1)/(m1+m2)]\n\n# Parameters\nL = 20\ng = 9.8\nt = 0\ndt = 0.001\nRadius_I = 1\n\n# Objects\nfloor = box(pos=vec(0, -L/2, 0), size=vec(L, 0.01, L), color=color.green)\nb1 = sphere(pos=vec(0, -L/2+Radius_I, 0), radius=Radius_I, color=color.red)\nb2 = sphere(pos=vec(0, -L/2+2*Radius_I, 0), radius=Radius_I, color=color.blue)\nb1.v = vec(0, 0, 0)\nb2.v = vec(0, 0, 0)\nb1.m = 2\nb2.m = 1\n\n# Animation\nwhile True:\n    rate(1000)\n    b1.v += vec(0, -g, 0) * dt\n    b2.v += vec(0, -g, 0) * dt\n    b1.pos += b1.v * dt\n    b2.pos += b2.v * dt\n    if b1.pos.y <= -L/2 + b1.radius:\n        b1.v.y = -b1.v.y\n    if b2.pos.y - b1.pos.y <= b1.radius + b2.radius:\n        b1.v.y, b2.v.y = af_col_v(b1.m, b1.v.y, b2.m, b2.v.y)",
      "mode": "initial",
      "timestamp": "2024-07-24 11:30:44",
      "serial_number": 1
    }
  ]
}