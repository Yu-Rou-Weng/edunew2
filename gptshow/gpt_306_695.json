{
  "session_id": 695,
  "log": [
    {
      "input": "Motion of Charged Particles in a Magnetic Field\n\nThe magnetic force on a charged particle in a uniform magnetic field is given by\n$$\n\\vec{F}_B = q (\\vec{v} \\times \\vec{B}) \\Rightarrow F_B = qvB \\sin{\\theta}\n$$\nwhere $q$ is the charge of the particle, $v_0$ is the velocity of the particle, and $B$ is the external magnetic field. There are three possible types of motion:\n\n- $\\theta = 0^\\circ$ or $180^\\circ$: $F_B = 0$, uniform linear motion\n- $\\theta = 90^\\circ$: $F_B = qvB$, uniform circular motion\n- Other angles: Helical motion, moving forward while circling\n\nThe goal this time is to illustrate these three states of motion, with the animation window's viewpoint automatically adjusting according to the angle between velocity and the magnetic field for easier observation.\n\nHelical Motion Diagram:\n![image](https://hackmd.io/_uploads/BkS9t3TuC.png)\n\nParameter Settings\n\nVariables are set as size, m, theta, phi, v0, q, L, B_field, t, dt, with their purposes noted in the relevant comments. To ensure smoother animation, the particle's charge and mass are intentionally increased significantly.\n\nScreen Setup\n- Create an animation window, rotating the viewpoint according to theta and phi. If theta equals pi/2 or phi equals pi/2, the viewpoint is set from (L, L/4, L/4) towards the origin. Otherwise, it's set from (L/4, L/4, L) towards the origin.\n- Create the charged particle and set its initial velocity.\n- Generate coordinate axes and labels.\n- Produce arrows and labels indicating the magnetic field.\n- Generate arrows for velocity and acceleration.\n\nObject Motion\n- The particle is intended to move within a cubic space with side length 1.2 L, stopping upon reaching the edge. Therefore, the condition in the while loop is set as abs(charage.pos.x) < 0.6*L and abs(charge.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L.\n- Calculate the resultant force on the charged particle, updating its acceleration, velocity, and position.\n- Update arrows representing velocity and acceleration, only displaying direction to avoid automatically shrinking the animation.\n- Update time.\n\nSimulation Results\n\nBelow are five different data combinations and their results:\n\n1. theta = 0, phi = 0 \u21d2 Velocity has only x-direction component, moving at constant speed along the x-axis\n![image](https://hackmd.io/_uploads/BJdk9hauA.png)\n\n2. theta = 90, phi = 0 \u21d2 Velocity has no x-direction component, performing uniform circular motion in the yz plane\n![image](https://hackmd.io/_uploads/Hy31qhpOA.png)\n\n3. theta = 0, phi = 90 \u21d2 Velocity has no x-direction component, performing uniform circular motion in the yz plane\n![image](https://hackmd.io/_uploads/SJfxcnpu0.png)\n\n4. theta = 80, phi = 10 \u21d2 Velocity not at an angle of 0 degrees or 180 degrees with the x-axis, helical motion\n![image](https://hackmd.io/_uploads/S1wlcnadC.png)\n\n5. theta = 100, phi = 10 \u21d2 Velocity not at an angle of 0 degrees or 180 degrees with the x-axis, helical motion\n![image](https://hackmd.io/_uploads/Skal5nau0.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nsize, m = 0.02, 0.2\ntheta = radians(80)  \nphi = radians(10)  \nv0, q = 0.5, 5  \nL = 1.0  \nB_field = vec(0, 0, 1)  \nt, dt = 0, 0.001  \n\n# Screen Setup\nscene = canvas(width = 600, height = 600, range = 1.2*L, forward = vec(-1, -1, -1))\n\n# Create particle\ncharge = sphere(pos = vec(0, 0, 0), v = v0*vec(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)), radius = size, m = m, q = q, color = color.cyan)\ncharge.v_arrow = arrow(pos = charge.pos, axis = charge.v, color = color.green)\n\n# Generate coordinate axes and labels\naxis_x = cylinder(pos = vec(-1.2*L, 0, 0), axis = vec(2.4*L, 0, 0), radius = L/40, color = color.red)\naxis_y = cylinder(pos = vec(0, -1.2*L, 0), axis = vec(0, 2.4*L, 0), radius = L/40, color = color.red)\naxis_z = cylinder(pos = vec(0, 0, -1.2*L), axis = vec(0, 0, 2.4*L), radius = L/40, color = color.red)\nlabel_x = label(text = 'X', pos = vec(1.3*L, 0, 0), height = 30, box = False)\nlabel_y = label(text = 'Y', pos = vec(0, 1.2*L, 0), height = 30, box = False)\nlabel_z = label(text = 'Z', pos = vec(0, 0, 1.3*L), height = 30, box = False)\n\n# Produce arrows and labels indicating the magnetic field\nB_arrow = arrow(pos = vec(0, 0, 0), axis = B_field, color = color.yellow)\nlabel_B = label(text = 'B', pos = B_field, height = 30, box = False)\n\n# Generate arrows for velocity and acceleration\ncharge.v_arrow = arrow(pos = charge.pos, axis = charge.v, color = color.green)\ncharge.a_arrow = arrow(pos = charge.pos, axis = vec(0, 0, 0), color = color.red)\n\n# Object Motion\nwhile t < 10:\n    rate(1000)\n    \n    if abs(charge.pos.x) < 0.6*L and abs(charge.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L:\n        F = charge.q*cross(charge.v, B_field)\n        charge.v += F/charge.m*dt\n        charge.pos += charge.v*dt\n    else: \n        break\n\n    # Update arrows representing velocity and acceleration\n    charge.v_arrow.pos = charge.pos\n    charge.v_arrow.axis = charge.v\n    charge.a_arrow.pos = charge.pos\n    charge.a_arrow.axis = F/charge.m\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 11:03:43",
      "serial_number": 1
    }
  ]
}