{
  "session_id": 682,
  "log": [
    {
      "input": "Simple Harmonic Motion Caused by Gravity, Circular Ring, Starting with Zero Initial Velocity, Starting from the Endpoint\n\nThis is a definite yet abstract problem that appears in the second half of the 11th-grade curriculum:\n\nIn outer space, there are two planets each with mass $M$, uniformly distributed mass, and fixed positions, separated by a distance of $2d$. On the perpendicular bisector at a distance $x$ from the midpoint, there is a point mass $m$. Assuming the point mass starts from rest and considering only the influence of gravity, when $x \\ll d$, what is the period of motion of $m$?\n\n## Analysis:\n\nFirst, draw a force diagram for $m$. The resultant force on $m$ can be expressed as:\n$$\nF_x = -2 \\frac{GMmx}{(d^2 + x^2)^{3/2}} \\approx -2 \\frac{GMm}{d^3} x = -kx\n$$\n\n$$\nT = 2\\pi \\sqrt{\\frac{m}{k}} = 2\\pi \\sqrt{\\frac{d^3}{2GM}}\n$$\n\n### Force Diagram for m\n\n### Relationship Graph of Resultant Force on m and Distance x (0 \u2264 x \u2264 100)\n\n### Relationship Graph of Resultant Force on m and Distance x (0 \u2264 x \u2264 8)\n\nThere is often an advanced version of this problem where the two point masses $m$ are replaced with a uniformly distributed ring with total mass $m$ and radius $r$. If the other conditions remain the same, the resultant force on $m$ and the period of motion are:\n\n$$\nF_x = - \\frac{GMmx}{(r^2 + x^2)^{3/2}} \\approx - \\frac{GMm}{r^3} x = -kx\n$$\n\n$$\nT = 2\\pi \\sqrt{\\frac{m}{k}} = 2\\pi \\sqrt{\\frac{r^3}{GM}}\n$$\n\n### Schematic Diagram of m and M Circular Ring\n\nThe goal of this exercise is to illustrate these two problems.\n\n## Parameter Settings\n\nSet variables such as size, m, M, d, h, G, v0, i, t, dt, with their purposes noted in the respective comments.\n\n## Screen Settings\n\nSince VPython\u2019s default view is directed from the +z axis towards the origin, with the right side of the screen as the +x axis and the top as the +y axis, the original problem involves m moving along the x-axis. In the animation, this is changed to movement along the y-axis.\n\nCreate planets s1, s2, and a small ball, setting the initial position of the ball at (0, h, 0) and the initial velocity at 0. If you want to try starting the ball from different distances, simply adjust the parameter h accordingly.\n\nDraw a line between the planets, marking the equilibrium position; the starting height is the endpoint, so the lower endpoint should be at y = -h.\n\nGenerate arrows representing velocity and acceleration. To prevent overlapping, place them at distances 1 and 2 from the right side of the ball.\n\nOpen the drawing window and plot the ball's position, velocity, acceleration, and their relationships over time.\n\n## Object Motion\n\nTo keep the animation running until the ball has moved back and forth 5 times, set the condition in the while loop as i < 5, and use `if(ball.pos.y > h)` to determine if the ball has returned to the starting point. If it has, print the elapsed time t and the number of returns to the starting point i.\n\nCalculate the gravitational force F acting on the ball using Newton's law of universal gravitation, then calculate the ball\u2019s acceleration from F = ma, and update the velocity and position accordingly.\n\n### Required Program: Simple Harmonic Motion Caused by Gravity, Circular Ring, Starting with Zero Initial Velocity, Starting from the Endpoint\n\nProgram Design Part\n\nThis is based on the program: Simple Harmonic Motion Caused by Gravity, Starting with Zero Initial Velocity, Starting from the Endpoint, with the following differences:\n\nIn the screen settings, replace s1 and s2 with a circular ring, and divide the ring into N small balls, each with mass M/N. Using a for loop, evenly distribute the N small balls around the ring, storing them in a list named stars.\n\nIn the object motion part, use a for loop to take each ball from stars one by one and name it star. Calculate the gravitational force f between star and the point mass m ball, then sum it to calculate the resultant force F on ball.\n(1) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameters\nG = 6.67E-11  # gravitational constant\nM = 1E24  # mass of planet\nm = 1E20  # mass of small ball\nd = 1E10  # separation distance between planets\nh = 1E9  # initial height of small ball\nv0 = vector(0, 0, 0)  # initial velocity of small ball\nN = 100  # number of small balls in the ring\ni = 0  # initialize counter\nt = 0  # initialize time\ndt = 1E4  # time step\n\n# Screen settings\nscene = canvas(title='Simple Harmonic Motion Caused by Gravity, Circular Ring',\n               width=800, height=800, center=vector(0, -h/2, 0), background=color.black)\nstars = []  # list to store small balls in the ring\nfor j in range(N):\n    stars.append(sphere(pos=vector(d*cos(2*pi*j/N), 0, d*sin(2*pi*j/N)), radius=d/20, color=color.yellow))\nball = sphere(pos=vector(0, h, 0), radius=d/50, color=color.green, make_trail=True, v=v0)\nline = curve(vector(0, h, 0), vector(0, -h, 0), color=color.white)\nv_arrow = arrow(pos=ball.pos+vector(1, 0, 0), axis=ball.v, color=color.green)\na_arrow = arrow(pos=ball.pos+vector(2, 0, 0), axis=vector(0, 0, 0), color=color.red)\ng1 = graph(title='y-t', x=0, y=400, width=600, height=150,\n            xtitle='t', ytitle='y', foreground=color.black, background=color.white)\ny_t = gcurve(graph=g1, color=color.blue)\ng2 = graph(title='v-t', x=0, y=200, width=600, height=150,\n            xtitle='t', ytitle='v', foreground=color.black, background=color.white)\nv_t = gcurve(graph=g2, color=color.blue)\ng3 = graph(title='a-t', x=0, y=0, width=600, height=150,\n            xtitle='t', ytitle='a', foreground=color.black, background=color.white)\na_t = gcurve(graph=g3, color=color.blue)\n\n# Object motion\nwhile i < 5:\n    rate(1000)\n    F = vector(0, 0, 0)  # initialize total force\n    for star in stars:\n        r = ball.pos - star.pos\n        F += G*m*M/N*norm(r)/mag(r)**2  # calculate gravitational force\n    ball.a = F/m  # calculate acceleration\n    ball.v += ball.a*dt  # update velocity\n    ball.pos += ball.v*dt  # update position\n    v_arrow.pos = a_arrow.pos = ball.pos\n    v_arrow.axis = ball.v\n    a_arrow.axis = ball.a\n    y_t.plot(pos=(t, ball.pos.y))\n    v_t.plot(pos=(t, mag(ball.v)))\n    a_t.plot(pos=(t, mag(ball.a)))\n    t += dt\n    if ball.pos.y > h:\n        i += 1\n        print('t =', t, ', i =', i)",
      "mode": "initial",
      "timestamp": "2024-07-24 09:12:11",
      "serial_number": 1
    },
    {
      "input": "Please update the program by fixing the following error:\nA curve object point must include a pos.\n\nHere's the current program:\nfrom vpython import *\n\n# Parameter Settings\nM = 1E10  # mass of each planet\nm = 1  # mass of the small ball\nd = 1E2  # distance between two planets\nh = d/50  # starting height of the ball\nG = 1  # gravitational constant\ndt = 0.001  # time step\nN = 100  # number of stars in the ring\nR = d/2  # radius of the ring\nstars = []  # list to store the stars\n\n# Screen Setup\nscene = canvas(width=600, height=600, range=d/2, background=vec(0.5, 0.5, 0.5))\n\n# Create circular ring of stars\nfor i in range(N):\n    theta = 2 * pi * i / N\n    stars.append(sphere(pos=vec(R*cos(theta), 0, R*sin(theta)), radius=h/2, color=color.green, m=M/N))\n\nball = sphere(pos=vec(R, 0, 0), v=vec(0, 0, 0), radius=h/2, color=color.red, m=m, make_trail=True)  # small ball\n\n# Object Motion\nt = 0  # initial time\ni = 0  # counter for number of returns\nwhile i < 5:\n    rate(1000)\n    F = vec(0, 0, 0)  # resultant force on the ball\n    for star in stars:  # calculate the force from each star\n        r = star.pos - ball.pos\n        if mag(r) != 0:\n            F += -G * ball.m * star.m * r.norm() / mag2(r)\n    ball.v += F * dt / ball.m  # update velocity\n    ball.pos += ball.v * dt  # update position\n    t += dt\n    if mag(ball.pos - vec(R, 0, 0)) < ball.radius:  # check if the ball has returned to the starting point\n        print('t =', round(t, 2), 's')\n        i += 1\n        ball.v = vec(0, 0, 0)  # reset velocity when returning to start point",
      "output": "from vpython import *\n\n# Parameter Settings\nM = 1E10  # mass of each planet\nm = 1  # mass of the small ball\nd = 1E2  # distance between two planets\nh = d/50  # starting height of the ball\nG = 1  # gravitational constant\ndt = 0.001  # time step\nN = 100  # number of stars in the ring\nR = d/2  # radius of the ring\nstars = []  # list to store the stars\n\n# Screen Setup\nscene = canvas(width=600, height=600, range=d/2, background=vec(0.5, 0.5, 0.5))\n\n# Create circular ring of stars\nfor i in range(N):\n    theta = 2 * pi * i / N\n    stars.append(sphere(pos=vec(R*cos(theta), 0, R*sin(theta)), radius=h/2, color=color.green, m=M/N))\n\nball = sphere(pos=vec(R, 0, 0), v=vec(0, 0, 0), radius=h/2, color=color.red, m=m, make_trail=True)  # small ball\n\n# Object Motion\nt = 0  # initial time\ni = 0  # counter for number of returns\nwhile i < 5:\n    rate(1000)\n    F = vec(0, 0, 0)  # resultant force on the ball\n    for star in stars:  # calculate the force from each star\n        r = star.pos - ball.pos\n        if mag(r) != 0:\n            F += -G * ball.m * star.m * r.norm() / mag2(r)\n    ball.v += F * dt / ball.m  # update velocity\n    ball.pos += ball.v * dt  # update position\n    t += dt\n    if mag(ball.pos - vec(R, 0, 0)) < ball.radius:  # check if the ball has returned to the starting point\n        print('t =', round(t, 2), 's')\n        i += 1\n        ball.v = vec(0, 0, 0)  # reset velocity when returning to start point",
      "mode": "fix_error",
      "timestamp": "2024-07-24 09:12:37",
      "serial_number": 5
    }
  ]
}