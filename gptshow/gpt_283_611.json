{
  "session_id": 611,
  "log": [
    {
      "input": "# Planetary Motion\n\nProgram to write: Planetary Motion, customize planet speed and distance, can modify the power of r in the law of universal gravitation.\n\nKepler's laws of planetary motion consist of the following three laws:\n\n1. **First Law (Law of Orbits)**: All planets move in elliptical orbits with the Sun at one focus.\n\n2. **Second Law (Law of Equal Areas)**: The line connecting a planet to the Sun sweeps out equal areas during equal intervals of time. If the distance between the Sun and the planet is $r$, the planet's speed is $v$, and the angle between $r$ and $v$ is $\\theta$, then the area swept by the line connecting the planet to the Sun per unit of time is\n$$\n\\frac{\\Delta A}{\\Delta t} = \\frac{1}{2} rv \\sin{\\theta} = \\text{constant}\n$$\n\n3. **Third Law (Law of Periods)**: For all planets orbiting the Sun, the square of the orbital period $T$ is directly proportional to the cube of the semi-major axis of its orbit $a$\n$$\n\\frac{a^3}{T^2} = \\text{constant}\n$$\n\nWe know that the first law exists because there is only gravitational force acting between the Sun and the stars, and according to the law of universal gravitation, only an ellipse is a stable orbit. The second law is due to the fact that gravity passes through the Sun, so the angular momentum of the planet relative to the Sun is conserved, resulting in equal areas being swept out in equal times. The third law can be derived using the law of gravitation as the centripetal force. If combined with the real data of the solar system planets, these three laws should be able to be graphically represented.\n\n## Parameter Settings\n\nVariables are set as G, size, sun_m, d, v0, theta, n, t, dt, with their purposes written in the comments of each line. E represents powers of ten, for example, 1E3 = 1000, and can also be replaced with e. Since I hope to use real data as much as possible, when the distance is real, the planet's radius must be enlarged; otherwise, the planet will not be visible.\n\n## Screen Settings\n\nWhen generating the Sun, the last option is `emissive=True`, which defaults to False. If set to True, the Sun will emit light.\n\nWhen generating the Earth, set the material `texture=textures.earth`, as VPython has built-in textures of Earth, eliminating the need to find pictures. However, since the Earth object is not set to any color, the default color of the trail is white. To change it to blue, add `trail_color=color.blue`. To change the trail radius to `0.1*size`, add `trail_radius=0.1 * size`.\n\nTo make the Sun emit light, in older versions of VPython, you would write:\n\nscene.lights = [local_light(pos=vec(0, 0, 0), color=color.white)]\nHowever, in VPython 7, this method is no longer supported, and a light source is placed at the Sun's position instead:\n\n\nlamp = local_light(pos=vec(0,0,0), color=color.white)\nGenerate arrows representing speed and acceleration.\n\nOpen the drawing window, draw graphs of the distance between the planet and the Sun, planet speed, acceleration, and time correlation.\n\n## Object Motion\nCalculate the planet's acceleration\n\n\nplanet.a = - G*sun.m / planet.pos.mag**n * planet.pos.norm()\nTo change the power of distance in the law of universal gravitation, do not use planet.pos.mag2 to calculate the square of the distance between the planet and the Sun; instead, use planet.pos.mag**n to calculate the nth power of the distance. Then update the planet's speed and position.\n\nUpdate the position, direction, and length of the arrows representing speed and acceleration. Since the distance between the planet and the Sun is large, the arrows need to be enlarged to be visible.\n\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1E10 \n\n(2) Radius_I is the radius of the planet. When Radius_I changes to a new value, the radius of the planet also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nG = 6.67428E-11\nsize = 1E10\nsun_m = 1.989E30\nd = 1 #semi-major axis\nv0 = 2 * pi * d / (60*60*24*365.25) * 1E6\ntheta = pi / 4\nn = 2\nt = 0\ndt = 10000\nRadius_I = 1E10\n\n# Screen Settings\nscene = canvas(width=800, height=800, background=vec(0.5, 0.5, 0))\nscene.range = 3E11\nscene.forward = vec(0, -1, -1)\nsun = sphere(pos=vec(0, 0, 0), radius=1E10, color=color.red, emissive=True)\nplanet = sphere(pos=vec(d, 0, 0), radius=Radius_I, color=color.blue, make_trail=True, trail_color=color.blue, trail_radius=0.1 * size, texture=textures.earth)\nplanet.v = vec(0, v0, 0)\nplanet.a = vec(0, 0, 0)\nv_vector = arrow(pos=planet.pos, axis=planet.v, shaft_width=0.05*size, color=color.green)\na_vector = arrow(pos=planet.pos, axis=planet.a, shaft_width=0.05*size, color=color.yellow)\nlamp = local_light(pos=vec(0,0,0), color=color.white)\n\n# Object Motion\nwhile True:\n    rate(1000)\n    planet.a = - G*sun_m / planet.pos.mag**n * planet.pos.norm()\n    planet.v += planet.a * dt\n    planet.pos += planet.v * dt\n    v_vector.pos = planet.pos\n    v_vector.axis = planet.v * size / v0\n    a_vector.pos = planet.pos\n    a_vector.axis = planet.a * size / v0\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 03:48:51",
      "serial_number": 1
    }
  ]
}