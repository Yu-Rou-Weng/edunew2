{
  "session_id": 620,
  "log": [
    {
      "input": "Stacked Wooden Blocks Undergoing Completely Inelastic Collision\n\nThis is an example problem that would appear in the basic physics course 2B, covering chapters on conservation of momentum, work and energy, and collisions. The problem is described as follows:\n\nBlock A has a mass of 2m, and Block B has a mass of m. The two blocks are stacked, with no friction between Block A and the table surface. Block A has an initial velocity v. The coefficient of kinetic friction between the two blocks is \u03bck. Assuming the length of A is sufficient, A and B can eventually move forward at the same velocity. The questions are: (1) What is the final velocity of A and B? (2) How long does it take for the two blocks to reach the same velocity?\n\nThere are two versions of the problem. The first version is as shown in the figure above, with Block B initially positioned at the far right of Block A and initially at rest, with Block A's initial velocity directed to the right. The second version has Block B initially positioned at the far left of Block A with an initial velocity to the right, while Block A is initially at rest. The goal this time is to write a program for completely inelastic collision of stacked blocks.\n\nParameter Settings\n\nVariables are set for the blocks' length, width, height, mass, initial velocity, color, x-axis range, gravitational acceleration, coefficient of kinetic friction, time, and time interval. The time interval dt is set to 0.0005 because setting it to 0.001 resulted in larger computational errors, hence the selection of a smaller value.\n\nDisplay Settings\nMost functions have already been used in previous animations, so only the special parts need explanation: b2's initial position is determined by v1 and v2. If v2 \u2265 v1, b2's initial position should be on the left side of b1; otherwise, if v2 < v1, it should be on the right side. The following two lines of code calculate b2's initial position:\n\nif(v2 >= v1): bx = xmin + d2/2\nelse: bx = xmin + d1 - d2/2\n\nObject Motion\nTo repeat the animation until one of the following two situations occurs:\n\nb1 reaches the edge of the screen\nb2 reaches the edge of b1\nThus, the condition in the while loop is set as:\n\n((b1.pos.x <= xmax - d1/2) and (b2.pos.x + d2/2 <= b1.pos.x + d1/2 + 0.001)\nThe second condition includes 0.001 to prevent the animation from stopping immediately when v1 > v2 at the start.\n\nThe direction of the kinetic friction between b1 and b2 depends on their velocities at the time, with three scenarios:\n\nWhen b2.v.x > b1.v.x, the kinetic friction acts to the right on b1 and to the left on b2.\nWhen b2.v.x < b1.v.x, the kinetic friction acts to the left on b1 and to the right on b2.\nWhen b2.v.x = b1.v.x, the kinetic friction is 0.\nThus, lines 60 to 71 of the code use if\u2026 elif\u2026 else to determine the magnitude and direction of the kinetic friction. The else part could be omitted because in the program b1.v.x and b2.v.x are floating-point numbers and almost never equal.\n\nTo record the time it takes for b1 and b2 to reach the same velocity, lines 73 to 75 are needed. Since b1.v.x and b2.v.x are almost never equal, the condition is set as abs(b2.v.x - b1.v.x) < 0.0005. Because only the first moment when b1.v.x and b2.v.x are nearly equal needs to be recorded, the condition includes i == 0, and i is set to 1 in the execution of the if block, so it will not be executed a second time.\n\nCalculate the blocks' acceleration, update velocities and positions, and calculate the kinetic energy of the blocks.\n\nFinally, the final velocities of the blocks and the time required for b1 and b2 to reach the same velocity are printed.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Friction_I as a cyber input variable, set Friction_I=0.1\n\n(2) Friction_I is the Coefficient of friction. When Frilly_I changes to a new value, Coefficient of friction also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# parameter settings\nm1, m2 = 2, 1\nv1, v2 = 2, 1\nd1, d2 = 1, 1\nw, h = 0.2, 0.4\ncolor1, color2 = color.red, color.green\nFriction_I=0.1\ng = 9.8\ndt = 0.0005\ni = 0\n\n# scene settings\nscene = canvas(width=600, height=600, center=vector(0, h/2, 0), background=color.white)\nfloor = box(pos=vector(0, 0, 0), length=25, height=0.01, width=3, color=color.blue)\n\n# block settings\nb1 = box(pos=vector(-9.5+d1/2, h/2, 0), length=d1, height=h, width=w, color=color1, v=vector(v1, 0, 0), m=m1)\nb2 = box(pos=vector(-9.5+d2/2, h+d2/2, 0), length=d2, height=d2, width=w, color=color2, v=vector(v2, 0, 0), m=m2)\n\n# motion\nwhile(b1.pos.x <= 9.5 - d1/2 and b2.pos.x + d2/2 <= b1.pos.x + d1/2 + 0.001):\n    rate(1000)\n    if(b2.v.x > b1.v.x):\n        b1.f_friction = vector(-m1*g*Friction_I, 0, 0)\n        b2.f_friction = vector(m2*g*Friction_I, 0, 0)\n    elif(b2.v.x < b1.v.x):\n        b1.f_friction = vector(m1*g*Friction_I, 0, 0)\n        b2.f_friction = vector(-m2*g*Friction_I, 0, 0)\n    else:\n        b1.f_friction = vector(0, 0, 0)\n        b2.f_friction = vector(0, 0, 0)\n\n    if(abs(b2.v.x - b1.v.x) < 0.0005 and i == 0):\n        t = scene.k\n        i = 1\n\n    b1.a = b1.f_friction/b1.m\n    b2.a = (b2.f_friction + vector(0, -b2.m*g, 0))/b2.m\n\n    b1.v += b1.a*dt\n    b2.v += b2.a*dt\n\n    b1.pos += b1.v*dt\n    b2.pos += b2.v*dt\n\nprint(b1.v.x)\nprint(t)",
      "mode": "initial",
      "timestamp": "2024-07-24 05:31:15",
      "serial_number": 1
    }
  ]
}