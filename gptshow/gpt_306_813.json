{
  "session_id": 813,
  "log": [
    {
      "input": "Motion of Charged Particles in a Magnetic Field\n\nThe magnetic force on a charged particle in a uniform magnetic field is given by:\n$$\n\\vec{F}_B = q (\\vec{v} \\times \\vec{B}) \\Rightarrow F_B = qvB \\sin{\\theta}\n$$\nwhere $q$ is the charge of the particle, $v_0$ is the velocity of the particle, and $B$ is the external magnetic field. There are three possible types of motion:\n\n- $\\theta = 0^\\circ$ or $180^\\circ$: $F_B = 0$, motion is a uniform linear movement.\n- $\\theta = 90^\\circ$: $F_B = qvB$, motion is a uniform circular movement.\n- Other angles: Helical motion, spiraling while moving forward.\n\nThe goal here is to illustrate these three types of motion, with the animation window\u2019s viewpoint automatically adjusting according to the angle between the velocity and the magnetic field for optimal observation.\n\nHelical motion illustration:\n![image](https://hackmd being.io/_uploads/BkS9t3TuC.png)\n\nParameter Settings\n\nVariables are set as size, m, theta, phi, v0, q, L, B_field, t, dt, with their purposes described in the comments. To ensure smoother animation, the particle\u2019s charge and mass are intentionally increased significantly.\n\nDisplay Setup\n- Create an animation window, adjusting the viewpoint based on theta and phi. If theta == pi/2 or phi == pi/2, the view is from (L, L/4, L/4) towards the origin; otherwise, it is from (L/4, L/4, L) towards the origin.\n- Initialize the charged particle and set its initial velocity.\n- Create coordinate axes and labels.\n- Generate arrows and labels representing the magnetic field.\n- Generate arrows representing velocity and acceleration.\n\nObject Motion\n- The particle is confined to move within a cubic space with side length 1.2 L, stopping upon reaching the boundary. Thus, the while loop condition is set to abs(charge.pos.x) < 0.6*L and abs(charge.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L.\n- Calculate the net force on the charged particle, update its acceleration, velocity, and position.\n- Update arrows representing velocity and acceleration, displaying only their directions to avoid automatic resizing of the animation.\n- Update time.\n\nSimulation Results\n\nPlease illustrate the scene in the picture:\n2. theta = 90, phi = 0 \u21d2 No x-component of velocity, performing uniform circular motion on the yz-plane.\n![image](https://hackmd.io/_uploads/Hy31qhpOA.png)\n\nPlease write a Vpython animation for \"Motion of Charged Particles in a Magnetic Field\"\nThere is a central point with a rope acting as the radius, a red ball with a radius of 0.5 tied to the rope performing vertical circular motion on a 360-degree circle, with a trail. The velocity at any moment on the circle is visually represented by an arrow for velocity, and the acceleration by an arrow for acceleration. Use yellow arrow lines to depict X, Y, Z coordinate axes, and green arrow lines for the magnetic field axis, with the magnetic field axis coinciding with the X-axis.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# parameter settings\nL = 20\nR = L / 5\nm = 10 ** 11\nq = 10 ** -11\ntheta = radians(90)\nphi = radians(0)\nv0 = 0.2\nB_field = vec(0, 0, 0.1)\nsize = R / 5\nt = 0\ndt = 0.001\n\n# display setup\nscene = canvas(width = 800, height = 800, background = vec(0.5, 0.5, 0))\nif theta == pi / 2 or phi == pi / 2:\n    scene.camera.pos = vec(L, L / 4, L / 4)\nelse:\n    scene.camera.pos = vec(L / 4, L / 4, L)\nscene.range = 1.2 * L\nscene.forward = vec(-1, -1, -1)\n\ncharge = sphere(pos = vec(R * cos(phi), R * sin(phi), 0), radius = size, color = color.red, make_trail = True)\ncharge.v = vec(0, 0, v0)\n\nx_axis = arrow(pos = vec(-L, 0, 0), axis = vec(2 * L, 0, 0), shaftwidth = 0.8, color = color.yellow)\ny_axis = arrow(pos = vec(0, -L, 0), axis = vec(0, 2 * L, 0), shaftwidth = 0.8, color = color.yellow)\nz_axis = arrow(pos = vec(0, 0, -L), axis = vec(0, 0, 2 * L), shaftwidth = 0.8, color = color.yellow)\n\nB_vector = arrow(pos = vec(-L / 2, -L / 2, -L / 2), axis = B_field * L / 2, shaftwidth = 0.8, color = color.green)\nB_label = label(pos = B_vector.pos + B_vector.axis, text = 'B', xoffset = 25, yoffset = -25, space = B_vector.length / 8, height = 16, color = color.green, opacity = 0.4, box = False)\n\nv_vector = arrow(pos = charge.pos, axis = charge.v, shaftwidth = 0.8, color = color.magenta)\na_vector = arrow(pos = charge.pos, axis = vec(0, 0, 0), shaftwidth = 0.8, color = color.cyan)\n\n# object motion\nwhile abs(charge.pos.x) < 0.6 * L and abs(charge.pos.y) < 0.6 * L and abs(charge.pos.z) < 0.6 * L:\n    rate(1000)\n    F_net = q * cross(charge.v, B_field)\n    a = F_net / m\n    charge.v += a * dt\n    charge.pos += charge.v * dt\n    v_vector.pos = charge.pos\n    v_vector.axis = charge.v\n    a_vector.pos = charge.pos\n    a_vector.axis = a\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-26 02:53:04",
      "serial_number": 1
    },
    {
      "input": "Please update the following program based on this instruction: The red ball needs to perform circular motion.\n\nfrom vpython import *\n\n# parameter settings\nL = 20\nR = L / 5\nm = 10 ** 11\nq = 10 ** -11\ntheta = radians(90)\nphi = radians(0)\nv0 = 0.2\nB_field = vec(0, 0, 0.1)\nsize = R / 5\nt = 0\ndt = 0.001\n\n# display setup\nscene = canvas(width = 800, height = 800, background = vec(0.5, 0.5, 0))\nif theta == pi / 2 or phi == pi / 2:\n    scene.camera.pos = vec(L, L / 4, L / 4)\nelse:\n    scene.camera.pos = vec(L / 4, L / 4, L)\nscene.range = 1.2 * L\nscene.forward = vec(-1, -1, -1)\n\ncharge = sphere(pos = vec(R * cos(phi), R * sin(phi), 0), radius = size, color = color.red, make_trail = True)\ncharge.v = vec(0, 0, v0)\n\nx_axis = arrow(pos = vec(-L, 0, 0), axis = vec(2 * L, 0, 0), shaftwidth = 0.8, color = color.yellow)\ny_axis = arrow(pos = vec(0, -L, 0), axis = vec(0, 2 * L, 0), shaftwidth = 0.8, color = color.yellow)\nz_axis = arrow(pos = vec(0, 0, -L), axis = vec(0, 0, 2 * L), shaftwidth = 0.8, color = color.yellow)\n\nB_vector = arrow(pos = vec(-L / 2, -L / 2, -L / 2), axis = B_field * L / 2, shaftwidth = 0.8, color = color.green)\nB_label = label(pos = B_vector.pos + B_vector.axis, text = 'B', xoffset = 25, yoffset = -25, space = B_vector.length / 8, height = 16, color = color.green, opacity = 0.4, box = False)\n\nv_vector = arrow(pos = charge.pos, axis = charge.v, shaftwidth = 0.8, color = color.magenta)\na_vector = arrow(pos = charge.pos, axis = vec(0, 0, 0), shaftwidth = 0.8, color = color.cyan)\n\n# object motion\nwhile abs(charge.pos.x) < 0.6 * L and abs(charge.pos.y) < 0.6 * L and abs(charge.pos.z) < 0.6 * L:\n    rate(1000)\n    F_net = q * cross(charge.v, B_field)\n    a = F_net / m\n    charge.v += a * dt\n    charge.pos += charge.v * dt\n    v_vector.pos = charge.pos\n    v_vector.axis = charge.v\n    a_vector.pos = charge.pos\n    a_vector.axis = a\n    t += dt",
      "output": "from vpython import *\n\n# parameter settings\nL = 20\nR = L / 5\nm = 10 ** 11\nq = 10 ** -11\ntheta = radians(90)\nphi = radians(0)\nv0 = 0.2\nB_field = vec(0, 0, 0.1)\nsize = R / 5\nt = 0\ndt = 0.001\n\n# display setup\nscene = canvas(width = 800, height = 800, background = vec(0.5, 0.5, 0))\nscene.camera.pos = vec(L / 4, L / 4, L)\nscene.range = 1.2 * L\nscene.forward = vec(-1, -1, -1)\n\ncharge = sphere(pos = vec(R * cos(phi), R * sin(phi), 0), radius = size, color = color.red, make_trail = True)\ncharge.v = vec(0, 0, v0)\n\nx_axis = arrow(pos = vec(-L, 0, 0), axis = vec(2 * L, 0, 0), shaftwidth = 0.8, color = color.yellow)\ny_axis = arrow(pos = vec(0, -L, 0), axis = vec(0, 2 * L, 0), shaftwidth = 0.8, color = color.yellow)\nz_axis = arrow(pos = vec(0, 0, -L), axis = vec(0, 0, 2 * L), shaftwidth = 0.8, color = color.yellow)\n\nB_vector = arrow(pos = vec(-L / 2, -L / 2, -L / 2), axis = B_field * L / 2, shaftwidth = 0.8, color = color.green)\nB_label = label(pos = B_vector.pos + B_vector.axis, text = 'B', xoffset = 25, yoffset = -25, space = B_vector.length / 8, height = 16, color = color.green, opacity = 0.4, box = False)\n\nv_vector = arrow(pos = charge.pos, axis = charge.v, shaftwidth = 0.8, color = color.magenta)\na_vector = arrow(pos = charge.pos, axis = vec(0, 0, 0), shaftwidth = 0.8, color = color.cyan)\n\n# object motion\nwhile True:\n    rate(1000)\n    F_net = q * cross(charge.v, B_field)\n    a = F_net / m\n    charge.v += a * dt\n    charge.pos += charge.v * dt\n    v_vector.pos = charge.pos\n    v_vector.axis = charge.v\n    a_vector.pos = charge.pos\n    a_vector.axis = a\n    t += dt",
      "mode": "modification",
      "timestamp": "2024-07-26 02:56:05",
      "serial_number": 2
    }
  ]
}