{
  "session_id": 642,
  "log": [
    {
      "input": "Electric Field, Two Spherical Charged Bodies\n\n# Gravitational Field and Electric Field\n\nIf there is a sphere with mass $M$ uniformly distributed in space, and we take the center of mass $M$ as the origin, the gravitational field at a point in space with position vector $\\vec{r}$ is given by:\n$$\n\\vec{g} = - \\frac{GM}{r^2} \\hat{r}\n$$\nThe negative sign in the formula indicates that the direction of the gravitational field points towards the center of the sphere. If there are multiple spheres, the gravitational field for the $i$-th sphere, which has mass $M_i$ and is centered at $\\vec{r}_i$, is given by:\n$$\n\\vec{g} = \\sum \\vec{g}_i = -G \\sum \\frac{M_i (\\vec{r} - \\vec{r}_i)}{|\\vec{r} - \\vec{r}_i|^3}\n$$\n\nIt is nearly an impossible task to draw the intensity and direction of the gravitational field at various points on the blackboard. The figure below is a schematic diagram of the Earth's gravitational field that I have drawn.\n\n### Schematic Diagram of Earth's Gravitational Field\n\nIn the following lessons, we want to take points at regular intervals in space and represent the gravitational field at each point with the length and direction of an arrow. Hence, we first practice using a for loop in the program \"Using a for loop to generate arrows\" to draw an arrow at regular intervals in space. In the program \"Gravitational field, can be adapted to draw different planets,\" besides drawing arrows, it also calculates the gravitational field at that location and updates the length and direction of the arrows. If we can successfully draw the gravitational field of a sphere, in the program \"Gravitational field, can be adapted to draw different planets,\" we would further draw the gravitational fields established by two or multiple spheres.\n\nAfter completing the drawing of the gravitational field, we can use the same method to draw the electric field established by charged spheres in space, whose mathematical form is:\n$$\n\\vec{E} = \\sum \\vec{E}_i = k \\sum \\frac{Q_i (\\vec{r} - \\vec{r}_i)}{|\\vec{r} - \\vec{r}_i|^3}\n$$\nWe only need to slightly modify the program \"Gravitational field, can be adapted to draw different planets\" to be able to draw the electric field established by two charged spheres in space.\n\nProgram to be written: Electric Field, Two Spherical Charged Bodies\n\nThe program \"Electric Field, Two Spherical Charged Bodies\" is almost identical to \"Gravitational field, can be adapted to draw different planets,\" except for the following differences:\n\nReduce the radius of the spheres and the width of the screen considerably, set the charge of the charged bodies, and the electrostatic constant.\nFrom lines 23 to 31, when creating a custom class Ball, do not use inheritance; instead, create this class object by entering position pos, radius radius, color color, and charge charge, creating a sphere and customizing the function to calculate the electric field.\nIf the charge of the left small sphere is q1 and the right small sphere is q2, here are the simulation results for 3 different combinations.\n\nScreenshots of the drawn program code:\n\nq1 = 1, q2 = -5 simulation result screenshot:\n![image](https://hackmd.io/_uploads/B18ne26uR.png)\n\nq1 = 5, q2 = -5 simulation result screenshot:\n![image](https://hackmd.io/_uploads/rkX6g36u0.png)\n\nq1 = 5, q2 = -1 simulation result screenshot:\n![image](https://hackmd.io/_uploads/SJQCeh6uC.png)\n(1) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\r\n\r\n# Constants\r\nk = 8.99e9  # N.m2/C2\r\ngrid_size = 0.5\r\n\r\n# Define class\r\nclass Ball:\r\n    def __init__(self, pos, radius, color, charge):\r\n        self.sphere = sphere(pos=pos, radius=radius, color=color)\r\n        self.charge = charge\r\n\r\n    def E_field(self, loc):\r\n        r_vec = loc - self.sphere.pos\r\n        r_mag = mag(r_vec)\r\n        E_mag = k*self.charge/r_mag**2\r\n        E_vec = (E_mag / r_mag) * r_vec\r\n        return E_vec\r\n\r\n# Create balls\r\nball1 = Ball(vec(-3, 0, 0), 1, color.red, 5)\r\nball2 = Ball(vec(3, 0, 0), 1, color.blue, -1)\r\n\r\n# Create arrows\r\nx = arange(-8, 8, grid_size)\r\ny = arange(-5, 5, grid_size)\r\nz = arange(-5, 5, grid_size)\r\nfor x in x:\r\n    for y in y:\r\n        for z in z:\r\n            loc = vec(x, y, z)\r\n            E_net = ball1.E_field(loc) + ball2.E_field(loc)\r\n            if mag(E_net) > 1e18:  # Limit value for visibility\r\n                E_net = 1e18 * (E_net / mag(E_net))\r\n            arrow(pos=loc, axis=E_net/1e18*grid_size/2, shaftwidth=0.1, color=color.yellow)\r",
      "mode": "initial",
      "timestamp": "2024-07-24 06:41:09",
      "serial_number": 1
    }
  ]
}