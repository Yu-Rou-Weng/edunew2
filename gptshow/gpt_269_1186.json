{
  "session_id": 1186,
  "log": [
    {
      "input": "# Free Fall and Collision of Three BallsIn this scenario, three highly elastic balls of varying masses and radii are stacked vertically, with the heaviest ball at the bottom. When the stack is released from rest, all three balls accelerate downward due to gravity. After the bottom ball hits the ground and rebounds, a series of collisions occurs between the balls, transferring energy and momentum among them.1. **Initial Setup:**\u00a0 \u00a0- The balls are stacked with the largest and heaviest at the bottom and the smallest and lightest at the top.\u00a0 \u00a0- Each ball is subjected to the same gravitational acceleration.2. **Collision Dynamics:**\u00a0 \u00a0- The bottom ball rebounds upon hitting the ground.\u00a0 \u00a0- Elastic collisions occur between the balls, with velocities updated according to conservation laws of energy and momentum.3. **Outcome of Motion:**\u00a0 \u00a0- If the lower balls are heavier, the top ball is propelled upward to heights significantly greater than its original release height.\u00a0 \u00a0- If the bottom ball is lighter, it tends to bounce repeatedly between the ground and the balls above it.",
      "output": "from vpython import *\n\n# Constants\ng = 9.81  # acceleration due to gravity\n\n# Create balls\nball1 = sphere(pos=vector(0, 0, 0), radius=1, color=color.red, mass=3, velocity=vector(0, 0, 0))\nball2 = sphere(pos=vector(0, 2, 0), radius=0.8, color=color.green, mass=2, velocity=vector(0, 0, 0))\nball3 = sphere(pos=vector(0, 3.4, 0), radius=0.5, color=color.blue, mass=1, velocity=vector(0, 0, 0))\n\nballs = [ball1, ball2, ball3]\n\n# Time step\ndt = 0.001\n\nwhile True:\n    rate(1000)\n    \n    # Update velocities due to gravity\n    for ball in balls:\n        ball.velocity.y += -g * dt\n    \n    # Update positions\n    for ball in balls:\n        ball.pos += ball.velocity * dt\n    \n    # Collision detection and handling\n    for i in range(len(balls) - 1):\n        if balls[i].pos.y - balls[i].radius <= balls[i + 1].pos.y + balls[i + 1].radius:\n            # Elastic collision\n            v1_prime = ((balls[i].mass - balls[i + 1].mass) / (balls[i].mass + balls[i + 1].mass)) * balls[i].velocity + (2 * balls[i + 1].mass / (balls[i].mass + balls[i + 1].mass)) * balls[i + 1].velocity\n            v2_prime = (2 * balls[i].mass / (balls[i].mass + balls[i + 1].mass)) * balls[i].velocity + ((balls[i + 1].mass - balls[i].mass) / (balls[i].mass + balls[i + 1].mass)) * balls[i + 1].velocity\n            \n            balls[i].velocity = v1_prime\n            balls[i + 1].velocity = v2_prime",
      "mode": "initial",
      "timestamp": "2024-12-26 19:03:30",
      "serial_number": 1
    }
  ]
}