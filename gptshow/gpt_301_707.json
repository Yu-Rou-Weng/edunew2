{
  "session_id": 707,
  "log": [
    {
      "input": "Simple Harmonic Motion Caused by Electrostatic Force (Placed above the Perpendicular Bisector)\n\nPreviously, we discussed simple harmonic motion caused by gravity in \"Gravity and Simple Harmonic Motion.\" When we learn about electrostatic forces, we find that Coulomb's Law is similar in form to the Law of Universal Gravitation. Therefore, electrostatic forces should be able to produce the same motion patterns. Here are 3 different scenarios:\n\n19-2. Two fixed charged spheres, with a movable charged sphere placed above their perpendicular bisector\n\n## Program 19-2\n\n### Theoretical Derivation\n\nAs shown in the diagram below, there are two point charges of $+Q$ that are fixed in position and spaced $2R$ apart. At a distance $x$ on their perpendicular bisector, there is a point charge of $-q$ with mass $m$.\n![image](https://hackmd.io/_uploads/B14gQ36dA.png)\n\nIf the velocity of the $-q$ point charge is zero at this point and $x \\ll R$, considering only the electrostatic force between the objects, the resultant force on $-q$ is directed downwards with a magnitude\n$$\nF = \\frac{kQq}{R^2 + x^2} \\cdot \\frac{x}{\\sqrt{R^2 + x^2}} \\cdot 2 = \\frac{2kQq x}{(R^2 + x^2)^{3/2}}\n$$\n\n$$\n\\approx \\frac{2kQq x}{R^3} = Kx\n$$\n\nTherefore, $-q$ undergoes simple harmonic motion, with a period\n$$\nT = 2\\pi \\sqrt{\\frac{m}{K}} = 2\\pi \\sqrt{\\frac{mR^3}{2kQq}}\n$$\n\nBelow is a graph of electrostatic force \\(F\\) versus distance \\(x\\) plotted with \\(Q=q=2 \\times 10^4 \\, C\\). From the graph, it can be observed that when \\(x\\) is very small, \\(F \\propto x\\), and the slope is approximately 0.7, which matches the theoretical value.\n\nElectrostatic Force F - Distance x graph (0 \u2264 x \u2264 100):\n![image](https://hackmd.io/_uploads/HkRXXh6O0.png)\n\nElectrostatic Force F - Distance x graph (0 \u2264 x \u2264 10):\n![image](https://hackmd.io/_uploads/r1o4XnpdC.png)\n\nScreenshot of Program 19-2:\n![image](https://hackmd.io/_uploads/Hy7g42TOR.png)\n\nProgram Design\n\nProgram 19-2 is almost identical to Program 19-1, with only the following differences:\n\nThe sphere is placed at (0, h, 0).\n\nThe initial position of the sphere is at the top point, so the lower endpoint should be at y = -h. A line is drawn at the endpoint to mark the position.\n\nArrows representing velocity and acceleration are changed to be drawn at distances 1 and 2 to the right of the sphere.\n\nThe condition to check if the sphere has returned to the starting point is modified to if(ball.pos.y >= h and ball.v.y >= 0).\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, setting Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\nk = 9E9 # N*m^2/C^2\nQ = 2E-6 # C\nq = 2E-6 # C\nm = 0.01 # kg\nR = 0.6 # m\nh = 0.5 # m\nK = 2*k*Q*q/R**3 # N/m\nT = 2*pi*sqrt(m/K) # s\ndt = T/10000 # s\nend_t = 3*T # s\n\n# Objects\nwall_left = box(pos=vector(-R, 0, 0), size=vector(0.01, 2, 2), color=color.red)\nwall_right = box(pos=vector(R, 0, 0), size=vector(0.01, 2, 2), color=color.red)\nball = sphere(pos=vector(0, h, 0), v=vector(0, 0, 0), radius=0.02, m=m, color=color.yellow)\nball.v = vector(0, 0, 0)\nv_arrow = arrow(pos=vector(1, h, 0), axis=ball.v, color=color.green)\na_arrow = arrow(pos=vector(2, h, 0), color=color.blue)\nfloor = box(pos=vector(0, -h, 0), size=vector(4, 0.01, 2), color=color.white)\n\n# Calculation loop\nt = 0\nwhile t < end_t:\n    rate(1000)\n    \n    # Calculate force\n    F_net = vector(0, 0, 0)\n    r1 = ball.pos - wall_left.pos\n    r2 = ball.pos - wall_right.pos\n    F_net += k*Q*q*norm(r1)/mag(r1)**2\n    F_net += k*Q*q*norm(r2)/mag(r2)**2\n    ball.a = F_net/ball.m\n    \n    # Update motion\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    v_arrow.pos.y = a_arrow.pos.y = ball.pos.y\n    v_arrow.axis = ball.v\n    a_arrow.axis = ball.a\n    \n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 12:46:13",
      "serial_number": 1
    }
  ]
}