{
  "session_id": 710,
  "log": [
    {
      "input": "Motion of Charged Particles in a Magnetic Field\n\nThe magnetic force on a charged particle in a uniform magnetic field is given by\n$$\n\\vec{F}_B = q (\\vec{v} \\times \\vec{B}) \\Rightarrow F_B = qvB \\sin{\\theta}\n$$\nwhere $q$ is the charge of the particle, $v_0$ is the velocity of the particle, and $B$ is the externally applied magnetic field. There are three possible modes of motion:\n\n- $\\theta = 0^\\circ$ or $180^\\circ$: $F_B = 0$, motion is uniform linear motion.\n- $\\theta = 90^\\circ$: $F_B = qvB$, motion is uniform circular motion.\n- Other angles: Helical motion, spiraling while moving forward.\n\nThe goal here is to illustrate these three states of motion, and the animation window's viewpoint automatically adjusts for ease of observation based on the angle between the velocity and the magnetic field.\n\nIllustration of Helical Motion:\n![image](https://hackmd.io/_uploads/BkS9t3TuC.png)\n\nParameter Settings\n\nVariables are set for size, m, theta, phi, v0, q, L, B_field, t, dt, with their purposes described in the comments. To ensure smoother animation, the particle's charge and mass are significantly increased.\n\nDisplay Settings\n- Create an animation window and rotate the viewpoint according to theta and phi. If theta == pi/2 or phi == pi/2, observe from (L, L/4, L/4) towards the origin; otherwise, observe from (L/4, L/4, L) towards the origin.\n- Create a charged particle and set its initial velocity.\n- Generate coordinate axes and labels.\n- Generate arrows and labels representing the magnetic field.\n- Create arrows representing velocity and acceleration.\n\nObject Motion\n- The particle is confined to move within a cubic space with side length 1.2*L, and stops upon reaching the edges, so the condition in the while loop is set as abs(charge.pos.x) < 0.6*L and abs(charge.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L.\n- Calculate the total force on the charged particle, and update acceleration, velocity, and position of the particle.\n- Update arrows representing velocity and acceleration, only showing direction to prevent auto-scaling of the animation.\n- Update time.\n\nSimulation Results\n\nHere are five different sets of data and test results:\n\n1. theta = 0, phi = 0 \u21d2 Velocity has only x-component, moves at constant speed along x-axis\n![image](https://hackmd.io/_uploads/BJdk9hauA.png)\n\n2. theta = 90, phi = 0 \u21d2 No x-component in velocity, moves in uniform circular motion on the yz-plane\n![image](https://hackmd.io/_uploads/Hy31qhpOA.png)\n\n3. theta = 0, phi = 90 \u21d2 No x-component in velocity, moves in uniform circular motion on the yz-plane\n![image](https://hackmd.io/_uploads/SJfxcnpu0.png)\n\n4. theta = 80, phi = 10 \u21d2 Velocity forms an angle with the x-axis that is neither 0 nor 180 degrees, helical motion\n![image](https://hackmd.io/_uploads/S1wlcnadC.png)\n\n5. theta = 100, phi = 10 \u21d2 Velocity forms an angle with the x-axis that is neither 0 nor 180 degrees, helical motion\n![image](https://hackmd.io/_uploads/Skal5nau0.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nsize = 0.02 \nm = 10.0 \ntheta = 90 \nphi = 0 \nv0 = 1.0 \nq = 1.0 \nRadius_I = 1.0 \nL = 2.0 \nB_field = vec(0, 0, 1.0) \nt = 0 \ndt = 0.001 \n\n# Display Settings\nscene = canvas(width=800, height=800, background=vec(0.5, 0.5, 0)) \nif theta == pi / 2 or phi == pi / 2: \n    scene.camera.pos = vec(L, L / 4, L / 4)\nelse: \n    scene.camera.pos = vec(L / 4, L / 4, L) \nscene.camera.axis = -scene.camera.pos\ncharge = sphere(pos=vec(0, 0, 0), radius=Radius_I * size, m = m, q = q, v = v0 * vec(sin(theta), cos(theta) * cos(phi), cos(theta) * sin(phi)), a = vec(0, 0, 0), color=color.red) \nxaxis = cylinder(pos=vec(-L, 0, 0), axis=vec(2 * L, 0, 0), radius=L/40, color=color.yellow) \nxlabel = label(text = \"x\", pos = vec(L, 0, 0), height = 15, box = False)\nyaxis = cylinder(pos=vec(0, -L, 0), axis=vec(0, 2 * L, 0), radius=L/40, color=color.yellow) \nylabel = label(text = \"y\", pos = vec(0, L, 0), height = 15, box = False)\nzaxis = cylinder(pos=vec(0, 0, -L), axis=vec(0, 0, 2 * L), radius=L/40, color=color.yellow) \nzlabel = label(text = \"z\", pos = vec(0, 0, L), height = 15, box = False)\nB_arrow = arrow(pos=vec(0, 0, 0), axis=0.5*L*B_field, shaftwidth=0.05*size, color=color.green) \nB_label = label(text = \"B\", pos = 0.5*L*B_field, height = 20, box = False)\nv_vector = arrow(pos=charge.pos, axis=charge.v, shaftwidth=0.05*size, color=color.orange) \nv_label = label(text = \"v\", pos = charge.pos + charge.v, height = 15, box = False)\na_vector = arrow(pos=charge.pos, axis=charge.a, shaftwidth=0.05*size, color=color.cyan) \na_label = label(text = \"a\", pos = charge.pos + charge.a, height = 15, box = False)\n\n# Object Motion\nwhile abs(charge.pos.x) < 0.6 * L and abs(charge.pos.y) < 0.6 * L and abs(charge.pos.z) < 0.6 * L: \n    rate(1000) \n    charge.a = (charge.q / charge.m) * cross(charge.v, B_field)  \n    charge.v += charge.a * dt \n    charge.pos += charge.v * dt \n    v_vector.pos = charge.pos\n    v_vector.axis = charge.v \n    v_label.pos = charge.pos + charge.v\n    a_vector.pos = charge.pos\n    a_vector.axis = charge.a \n    a_label.pos = charge.pos + charge.a\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 13:00:52",
      "serial_number": 1
    }
  ]
}