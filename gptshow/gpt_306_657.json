{
  "session_id": 657,
  "log": [
    {
      "input": "Motion of Charged Particles in a Magnetic Field\n\nThe magnetic force exerted on a charged particle in a uniform magnetic field is given by:\n$$\n\\vec{F}_B = q (\\vec{v} \\times \\vec{B}) \\Rightarrow F_B = qvB \\sin{\\theta}\n$$\nwhere $q$ is the charge of the particle, $v_0$ is the particle's velocity, and $B$ is the external magnetic field. There are three possible types of motion:\n\n- $\\theta = 0^\\circ$ or $180^\\circ$: $F_B = 0$, motion in a straight line at constant speed\n- $\\theta = 90^\\circ$: $F_B = qvB$, circular motion at constant speed\n- Other angles: Helical motion, spiraling while progressing forward\n\nThe goal this time is to illustrate these three types of motion, with the animation window's viewpoint automatically adjusting according to the angle between velocity and magnetic field to facilitate observation.\n\nHelical motion diagram:\n![image](https://hackmd.io/_uploads/BkS9t3TuC.png)\n\nParameter Settings\n\nVariables such as size, m, theta, phi, v0, q, L, B_field, t, and dt are set here, with their purposes mentioned in the comments. To ensure smoother animation, the particle's charge and mass are intentionally increased significantly.\n\nDisplay Settings\n- Create an animation window, and rotate the viewpoint according to theta and phi. If the condition (theta == pi/2 or phi == pi/2) is met, the view is set from (L, L/4, L/4) towards the origin. If not, the view is from (L/4, L/4, L) towards the origin.\n- Create a charged particle and set its initial velocity.\n- Generate coordinate axes and labels.\n- Produce arrows and labels representing the magnetic field.\n- Create arrows for velocity and acceleration.\n\nObject Motion\n- The particle is designed to move only within a cubic space with edge length 1.2 L, and stops upon reaching the boundary, hence the condition in the while loop is set to abs(charage.pos.x) < 0.6*L and abs(charge.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L.\n- Calculate the net force on the charged particle, update its acceleration, velocity, and position.\n- Update the arrows representing velocity and acceleration, displaying only direction to prevent automatic resizing of the animation.\n- Update the time.\n\nSimulation Results\n\nHere are five different data combinations and their results:\n\n1. theta = 0, phi = 0 \u21d2 Velocity has only an x-component, moves along the x-axis at constant speed\n![image](https://hackmd.io/_uploads/BJdk9hauA.png)\n\n2. theta = 90, phi = 0 \u21d2 No velocity x-component, performs circular motion on the yz-plane at constant speed\n![image](https://hackmd.io/_uploads/Hy31qhpOA.png)\n\n3. theta = 0, phi = 90 \u21d2 No velocity x-component, performs circular motion on the yz-plane at constant speed\n![image](https://hackmd.io/_uploads/SJfxcnpu0.png)\n\n4. theta = 80, phi = 10 \u21d2 Velocity forms an angle with the x-axis that is neither 0 nor 180 degrees, resulting in helical motion\n![image](https://hackmd.io/_uploads/S1wlcnadC.png)\n\n5. theta = 100, phi = 10 \u21d2 Velocity forms an angle with the x-axis that is neither 0 nor 180 degrees, resulting in helical motion\n![image](https://hackmd.io/_uploads/Skal5nau0.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nsize, m = 0.01, 0.1  # radius and mass of the particle\nL, B_field = 3, vector(0, 0, 1)  # length of the animation box, magnetic field\ntheta = 0  # angle between v0 and x-axis\nphi = 0  # angle between projection of v0 onto yz-plane and z-axis\nv0, q = 1, 100  # initial velocity and charge of the particle\nt, dt = 0, 0.001  # initial time and time step\n\n# Display Settings\nscene = canvas(width=600, height=600, center=vec(L/2, L/2, L/2), background=vec(0.5, 0.5, 0))\ncharge = sphere(pos=vec(L/2, L/2, L/2), radius=size, m=m, v=v0*vec(cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta)), q=q, color=color.red)\naxes = [arrow(pos=vec(0, 0, 0), axis=L*vec(sqrt(2)/2, sqrt(2)/2, 0), shaftwidth=0.01, color=color.black),\n         arrow(pos=vec(0, 0, 0), axis=L*vec(-sqrt(2)/2, sqrt(2)/2, 0), shaftwidth=0.01, color=color.black),\n         arrow(pos=vec(0, 0, 0), axis=L*vec(0, -sqrt(2)/2, sqrt(2)/2), shaftwidth=0.01, color=color.black),\n         text(text='x', pos=1.1*L*vec(sqrt(2)/2, sqrt(2)/2, 0), color=color.black, height=0.1*L),\n         text(text='y', pos=1.1*L*vec(-sqrt(2)/2, sqrt(2)/2, 0), color=color.black, height=0.1*L),\n         text(text='z', pos=1.1*L*vec(0, -sqrt(2)/2, sqrt(2)/2), color=color.black, height=0.1*L)]\nB_arrow = arrow(pos=vec(L/2, L/2, 0), axis=L/4*B_field, shaftwidth=0.01, color=color.blue)\nB_label = label(text='B', pos=vec(L/2, L/2, 0)+1.1*L/4*B_field, box=False)\nv_arrow = arrow(pos=charge.pos, axis=0.1*charge.v, shaftwidth=0.01, color=color.green)\nv_label = label(text='v', pos=charge.pos+0.1*charge.v, box=False)\na_arrow = arrow(pos=charge.pos, axis=vec(0, 0, 0), shaftwidth=0.01, color=color.yellow)\na_label = label(text='a', pos=charge.pos, box=False)\n\n# Object Motion\nwhile abs(charge.pos.x) < 0.6*L and abs(charge.pos.y) < 0.6*L and abs(charge.pos.z) < 0.6*L:\n    rate(1000)\n    B = B_field if charge.pos.x < L else vec(0, 0, 0)\n    charge.F = charge.q*cross(charge.v, B)\n    charge.a = charge.F/charge.m\n    charge.v += charge.a*dt\n    charge.pos += charge.v*dt\n    v_arrow.pos = a_arrow.pos = charge.pos\n    v_arrow.axis = 0.1*charge.v\n    a_arrow.axis = 0.1*charge.a\n    v_label.pos = charge.pos+0.1*charge.v\n    a_label.pos = charge.pos+0.1*charge.a\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 07:22:58",
      "serial_number": 1
    }
  ]
}