{
  "session_id": 615,
  "log": [
    {
      "input": "Program to be written: Planetary motion, storing planetary data using a dictionary\n\nKepler's laws of planetary motion include the following three laws:\n\n1. **First Law (Law of Orbits)**: All planets move in elliptical orbits with the Sun at one of the foci.\n\n2. **Second Law (Law of Equal Areas)**: A line segment joining a planet and the Sun sweeps out equal areas during equal intervals of time. If $r$ is the distance between the Sun and the planet, $v$ is the velocity of the planet, and $\\theta$ is the angle between $r$ and $v$, then the area swept by the line segment per unit time is\n   $$\n   \\frac{\\Delta A}{\\Delta t} = \\frac{1}{2} rv \\sin{\\theta} = \\text{constant}\n   $$\n\n3. **Third Law (Law of Periods)**: The square of the orbital period $T$ of a planet is proportional to the cube of the semi-major axis $a$ of its orbit\n   $$\n   \\frac{a^3}{T^2} = \\text{constant}\n   $$\n\nThe first law is due to the gravitational interaction between the Sun and the planets, and according to the law of universal gravitation, only an ellipse is a stable orbit. The second law is because the gravitational force passes through the Sun, so the angular momentum of the planet relative to the Sun is conserved, hence the area swept by the line segment connecting the planet to the Sun is equal per unit time. The third law can be derived using the law of gravity as the centripetal force. If combined with real data from the solar system, these three laws can theoretically be graphically represented.\n\nParameter Settings\n\nThe dictionary is a special data storage format in Python. Suppose a dictionary named data is defined as follows:\n\n```\ndata = {\"key1\": value1, \"key2\": value2, ...}\n```\n\nSingle or double quotes can be used as long as they are paired. Each key corresponds to a piece of data, which can be any format, but each key must be unique and not duplicated. To call the data corresponding to key2, the syntax is:\n\n```\ndata[\"key2\"]\n```\n\nFor example, in the program:\n\n```\nradius = {\"Mercury\": 2439700, \"Venus\": 6051800, \"Earth\": 6371000, \"Mars\": 3389500, \"Sun\": 696392000}\n```\n\nIf you input `radius[\"Sun\"]`, the system outputs 696392000.\n\nVariables such as G, eps, t, dt are also set, with their purposes written in the comments of the respective lines.\n\nDisplay Settings\n\nThe display settings are very similar to the planetary motion program, but the way planetary objects are created is slightly different. Previously, corresponding variable names were directly entered. Now, data is handled using the dictionary + name method, for instance, setting Earth at its aphelion using `pos = vec(d_at_aphelion[\"Earth\"], 0, 0)`. The advantage of this method is that the code used to generate each planet is almost identical, only requiring a change in the planet's name to automatically find the corresponding data.\n\nObject Motion\n\nThe section on object motion is very similar to the planetary motion program. Since only two planets are depicted, you only need to write the code for calculating acceleration, updating velocity, and displacement for each planet once. Additionally, an if statement is used to determine if the planet has returned near its starting point to calculate the period. Although this method is not very precise, it is still usable.\n(1) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Define the parameters\nG = 6.67384 * 10**-11 # gravitational constant\nd_at_aphelion = {\"Earth\": 1.52 * 10**11, \"Mars\": 2.49 * 10**11} # dictionary of aphelion distances\nmass = {\"Sun\": 1.989 * 10**30, \"Earth\": 5.972 * 10**24, \"Mars\": 0.64171 * 10**24} # dictionary of masses\nr = {\"Sun\": 0, \"Earth\": d_at_aphelion[\"Earth\"], \"Mars\": d_at_aphelion[\"Mars\"]} # dictionary of radii\nv = {\"Sun\": 0, \"Earth\": 0, \"Mars\": 0} # dictionary of initial velocities\nt = 0\ndt = 60*60*24*7 # one week\n\n# Create the objects\nscene = canvas(title=\"Planetary Motion\", width=800, height=800, forward=vec(0, -1, -1))\nSun = sphere(pos=vec(0,0,0), radius=6.9634*10**8, color=color.yellow)\nEarth = sphere(pos=vec(r[\"Earth\"],0,0), radius=6.371*10**6, color=color.blue, make_trail=True, trail_type=\"points\", interval=10, retain=50)\nMars = sphere(pos=vec(r[\"Mars\"],0,0), radius=3.390*10**6, color=color.red, make_trail=True, trail_type=\"points\", interval=10, retain=50)\n\n# Initialize the planets' momentum\nEarth.p = Earth.mass * vec(0, 0, 0)\nMars.p = Mars.mass * vec(0, 0, 0)\n\n# Time loop for the motion of the planets\nwhile t < 10*365*24*60*60: # for 10 years\n    rate(1000)\n\n    # Calculate the force on each planet\n    F_earth = -G * mass[\"Sun\"] * mass[\"Earth\"] / r[\"Earth\"]**2 * norm(Earth.pos)\n    F_mars = -G * mass[\"Sun\"] * mass[\"Mars\"] / r[\"Mars\"]**2 * norm(Mars.pos)\n    \n    # Update each planet's momentum and position\n    Earth.p = Earth.p + F_earth*dt\n    Earth.pos = Earth.pos + (Earth.p/Earth.mass)*dt\n    Mars.p = Mars.p + F_mars*dt\n    Mars.pos = Mars.pos + (Mars.p/Mars.mass)*dt\n\n    t = t + dt",
      "mode": "initial",
      "timestamp": "2024-07-24 03:58:53",
      "serial_number": 1
    }
  ]
}