{
  "session_id": 604,
  "log": [
    {
      "input": "# Gravity and Simple Harmonic Motion\n\nThis is an abstract topic that is certain to appear in the curriculum of the second year of high school:\n\nIn outer space, there are two planets each with mass $M$. The mass of each planet is uniformly distributed, and their positions are fixed. The distance between the centers of the planets is $2d$. On the perpendicular bisector at a distance $x$ from the midpoint, there is a point mass of $m$. Assuming the point mass was initially at rest and only considering gravitational forces, what is the period of motion of $m$ when $x \\ll d$?\n\n## Analysis:\n\nFirst, draw a force diagram for $m$. The resultant force on $m$ is\n$$\nF_x = -2 \\frac{GMmx}{(d^2 + x^2)^{3/2}} \\approx -2 \\frac{GMm}{d^3} x = -kx\n$$\n\n$$\nT = 2\\pi \\sqrt{\\frac{m}{k}} = 2\\pi \\sqrt{\\frac{d^3}{2GM}}\n$$\n\n### Force diagram for m\n\n### Relationship between resultant force on m and distance x (0 \u2264 x \u2264 100)\n\n### Relationship between resultant force on m and distance x (0 \u2264 x \u2264 8)\n\nOften, there is an advanced version, replacing the two planets each with mass $m$ with a uniformly distributed mass ring with total mass $m$ and radius $r$. If the other conditions remain the same, then the resultant force on $m$ and the period of motion:\n\n$$\nF_x = - \\frac{GMmx}{(r^2 + x^2)^{3/2}} \\approx - \\frac{GMm}{r^3} x = -kx\n$$\n\n$$\nT = 2\\pi \\sqrt{\\frac{m}{k}} = 2\\pi \\sqrt{\\frac{r^3}{GM}}\n$$\n\n### Diagram of m and the mass ring M\n\nThe goal of this session is to illustrate these two problems.\n\n## Parameter Settings\n\nHere, variables such as size, m, M, d, h, G, v0, i, t, dt are defined and initialized with their uses commented in the respective lines.\n\n## Screen Setup\n\nSince VPython\u2019s default viewpoint is from the +z axis looking towards the origin, with the right side of the screen as the +x axis and the top as the +y axis, the original problem\u2019s motion of m along the x-axis is modified to motion along the y-axis in the animation.\n\nGenerate planets s1, s2, and a small ball, setting the initial position of the ball at (0, h, 0) and initial velocity at 0. If you want to try launching the ball from different distances later, just modify the h parameter in the settings.\n\nDraw a line between planets to denote the balance point; with the starting height at the top endpoint, thus the bottom endpoint should be at y = -h.\n\nCreate arrows to represent velocity and acceleration. To prevent the arrows from overlapping, draw them at distances of 1 and 2 places to the right of the small ball.\n\nOpen the drawing window, plot the position, velocity, acceleration, and time relationship of the small ball.\n\n## Object Motion\n\nTo ensure the animation runs through 5 cycles, set the condition in the while loop as i < 5 and use `if(ball.pos.y > h)` to determine if the ball has returned to the starting point. If it has, print the elapsed time t and the number of times it returned to the starting point.\n\nCalculate the resultant force F on the ball using the law of universal gravitation, then from F = ma, calculate the ball's acceleration, updating its velocity and position.\n\n\nIntended program: Simple harmonic motion caused by gravity, starting from rest, initiating from an endpoint.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameters\nd = 1\nM = 2\nG = 1\nh = 0.1\nt = 0\ndt = 0.001\ni = 0\nRadius_I = 1\n\n# Screen setup\nscene = canvas(title = \"Gravity and Simple Harmonic Motion\", width = 600, height = 600, x = 0, y = 0, center = vector(0, 0, 0), background = color.black)\ns1 = sphere(pos = vector(-d, 0, 0), radius = 0.1, color = color.yellow)\ns2 = sphere(pos = vector(d, 0, 0), radius = 0.1, color = color.yellow)\nball = sphere(pos = vector(0, h, 0), radius = Radius_I, color = color.red)\nline = curve(pos = [vector(-d, 0, 0), vector(d, 0, 0)], radius = 0.01)\nv_arrow = arrow(pos = ball.pos + vector(1, 0, 0), axis = vector(0, 0, 0), shaftwidth = 0.05, color = color.green)\na_arrow = arrow(pos = ball.pos + vector(2, 0, 0), axis = vector(0, 0, 0), shaftwidth = 0.05, color = color.blue)\ngraph1 = graph(width = 600, height = 400, x = 0, y = 600, xtitle = \"t\", ytitle = \"y\", xmax = 20, xmin = 0, ymax = h, ymin = -h)\nfunct1 = gcurve(color = color.red, graph = graph1)\n\n# Object motion\nwhile i < 5:\n    rate(1000)\n\n    # Calculate forces\n    F = -2 * G * M * ball.mass * ball.pos / mag(ball.pos)**3\n    ball.a = F / ball.mass\n    ball.v += ball.a * dt\n    ball.pos += ball.v * dt\n\n    # Update arrows and graph\n    v_arrow.pos = ball.pos + vector(1, 0, 0)\n    v_arrow.axis = ball.v\n    a_arrow.pos = ball.pos + vector(2, 0, 0)\n    a_arrow.axis = ball.a\n    funct1.plot(pos = (t, ball.pos.y))\n\n    # Check for return to starting position\n    if ball.pos.y > h:\n        i += 1\n        print(\"t = \", t, \"i = \", i)\n    \n    # Update time\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 03:29:07",
      "serial_number": 1
    }
  ]
}