{
  "session_id": 711,
  "log": [
    {
      "input": "# Electron Charge-to-Mass Ratio\n\nThe experimental setup for measuring the electron charge-to-mass ratio is illustrated below. It looks quite similar to a velocity selector, thus we can slightly modify the velocity selector program to create an animation for the electron charge-to-mass ratio experiment.\n\n### Schematic Diagram of the Experimental Setup\n![image](https://hackmd.io/_uploads/SkTFu36OR.png)\n\n## Theoretical Analysis\n\nRefer to the diagram above. The particle has a mass $m$ and charge $q$, and it enters a downward uniform electric field $E$ with a horizontal velocity $v_0$ to the right. The length of the parallel charged plates is $L$, and the distance from the right side of the parallel plates to the screen is $D$. If only the electrostatic force is considered, the particle\u2019s upward acceleration in the field is\n$$\na = \\frac{qE}{m}\n$$\n\nThere are no external forces horizontally, so it moves at a constant speed, and thus the time spent in the electric field is\n$$\nt_1 = \\frac{L}{v_0}\n$$\n\nThe upward displacement is\n$$\ny_1 = \\frac{1}{2} a t_1^2 = \\frac{1}{2} \\left( \\frac{qE}{m} \\right) \\left( \\frac{L}{v_0} \\right)^2\n$$\n\nThe upward velocity of the particle upon leaving the electric field is\n$$\nv_{y1} = a t_1 = \\frac{qEL}{mv_0}\n$$\n\nOutside the electric field, the particle moves in a straight line at constant speed, and the time spent moving outside the field is\n$$\nt_2 = \\frac{D}{v_0}\n$$\n\nThe upward displacement\n$$\ny_2 = v_{y1} t_2 = \\left( \\frac{qEL}{mv_0} \\right) \\left( \\frac{D}{v_0} \\right) = \\frac{qELD}{mv_0^2}\n$$\n\nThe total upward displacement is\n$$\ny = y_1 + y_2 = \\frac{qE}{2m} \\left( \\frac{L^2}{v_0^2} \\right) + \\frac{qELD}{mv_0^2} = \\frac{qEL(L + 2D)}{2mv_0^2}\n$$\n\nThe charge-to-mass ratio of the charged particle is\n$$\n\\frac{q}{m} = \\frac{2yv_0^2}{E L (L + 2D)}\n$$\n\nThe value of the electric field can be determined by the voltage and distance of the parallel charged plates, and the initial velocity $v_0$ can be controlled by a velocity selector, so all data except the charge-to-mass ratio can be measured in the experiment.\n\nParameter Settings\n\nVariables are set as size, m, v0, q, V, d, L, E_field, t, dt, and their purposes are commented in the respective lines. To make the animation smoother, the charge and mass of the particle are deliberately set much larger.\n\nScreen Settings\nGenerate the animation window, parallel charged plates, horizontal line, and charged particle. The parallel charged plates are located between -L < x < 0.\n\nGenerate arrows and labels indicating the electric and magnetic fields.\n\nGenerate arrows indicating velocity and acceleration.\n\nObject Motion\nTo stop the animation when the charged particle reaches the screen or hits the parallel charged plates, the condition in the while loop is set as 0 < charge.pos.x < screen.pos.x - screen.length/2 - size or (charge.pos.x < 0 and abs(charge.pos.y) < d/2 - p1.height - size)\n(a) Function of the first set of conditions: The animation continues to operate when the particle is between the electric field and the screen.\n(b) Function of the second set of conditions: The animation continues to operate when the particle is in the electric field and does not hit the parallel charged plates.\n\nCalculate the net force on the charged particle, which is zero outside the parallel charged plates.\n\nUpdate the charged particle's acceleration, velocity, and position.\n\nUpdate the arrows representing velocity and acceleration, drawing only the direction to avoid automatic resizing of the animation.\n\nTo draw a horizontal line when the charged particle leaves the parallel charged plates, define variables xp and xc, where xp is the particle's position at the previous moment, and xc is the current position of the particle. If xp < 0 and xc > 0, it means the particle has just left the parallel charged plates, and a cylinder command is used to draw a parallel line.\n\nUpdate time.\n\nSimulation Results\n\nBelow are six different combinations of data and test results:\n\n1.v0 = 20, q = -2 \u00d7 10-9, V = 1, d = 0.1 \u21d2 Hits the parallel charged plates upward.\n![image](https://hackmd.io/_uploads/B1w6O2TdR.png)\n\n2.q = -1 \u00d7 10-9, other conditions the same as combination 1 \u21d2 Moves upward but does not hit the parallel charged plates.\n![image](https://hackmd.io/_uploads/Bkoa_naOC.png)\n\n3.v0 = 25, other conditions the same as combination 1 \u21d2 Moves upward but does not hit the parallel charged plates.\n![image](https://hackmd.io/_uploads/S11AunauA.png)\n\n4.q = 2 \u00d7 10-9, other conditions the same as combination 1 \u21d2 Hits the parallel charged plates downward.\n![image](https://hackmd.io/_uploads/S1NROhpO0.png)\n\n5.q = 1 \u00d7 10-9, other conditions the same as combination 1 \u21d2 Moves downward but does not hit the parallel charged plates.\n![image](https://hackmd.io/_uploads/ryY0OnTu0.png)\n\n6.v0 = 25, q = 2 \u00d7 10-9, other conditions the same as combination 1 \u21d2 Moves downward but does not hit the parallel charged plates.\n![image](https://hackmd.io/_uploads/rJpRO3TO0.png)\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# parameter settings\nsize = 1E-3   # radius of the charged particle\nm = 1E-9   # mass of the particle\nv0 = 20   # initial velocity\nq = -2E-9   # charge of the particle\nV = 1   # voltage between the parallel charged plates\nd = 0.1   # distance between the parallel charged plates\nL = 0.4   # length of the parallel charged plates\nE_field = V/d   # electric field within the parallel charged plates\nt = 0   # time\ndt = 1E-5   # time interval\n\n# screen settings\nscene = canvas(width=800, height=800, background=vector(0.5, 0.5, 0), align = 'left')\nscreen = box(pos=vector(L + 0.1, 0, 0), size=vector(0.1, 0.2, 0.2), color=color.red)\np1 = box(pos=vector(-L/2, d/2, 0), size=vector(L, 0.01, 0.2), color=color.blue)\np2 = box(pos=vector(-L/2, -d/2, 0), size=vector(L, 0.01, 0.2), color=color.blue)\ncharge = sphere(pos=vector(-L - size, 0, 0), radius=size, color=color.green)\ncharge.v = vector(v0, 0, 0)\ncharge.a = vector(0, 0, 0)\ncharge.q = q\ncharge.m = m\nE_arrow = arrow(pos=vector(-L/2, -d/4, 0), axis=vector(0, -0.2, 0), color=color.red)\nB_arrow = arrow(pos=vector(-L/2, -d/4, 0), axis=vector(0, 0, 0.2), color=color.blue)\nv_arrow = arrow(pos=charge.pos, axis=charge.v/20, color=color.yellow)\na_arrow = arrow(pos=charge.pos, axis=charge.a/20, color=color.white)\nscene.waitfor('click')\n\n# object motion\nxp = charge.pos.x   # previous x position\nxc = charge.pos.x   # current x position\nwhile (0 < charge.pos.x < screen.pos.x - screen.length/2 - size) or (charge.pos.x < 0 and abs(charge.pos.y) < d/2 - p1.height - size):\n    if charge.pos.x < 0:\n        charge.f = charge.q * vector(0, -E_field, 0)\n    else:\n        charge.f = vector(0, 0, 0)\n    charge.a = charge.f / charge.m\n    charge.v += charge.a * dt\n    charge.pos += charge.v * dt\n    v_arrow.pos = charge.pos\n    v_arrow.axis = charge.v / 20\n    a_arrow.pos = charge.pos\n    a_arrow.axis = charge.a / 20\n    xc = charge.pos.x\n    if xp < 0 and xc > 0:\n        cylinder(pos=vector(0, charge.pos.y, 0), axis=vector(0, 0, 0.2), radius=0.001, color=color.white)\n    xp = xc\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 13:01:13",
      "serial_number": 1
    }
  ]
}