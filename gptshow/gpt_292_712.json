{
  "session_id": 712,
  "log": [
    {
      "input": "Free Fall Collision of Two Balls\n\nIf two highly elastic balls are stacked vertically with the heavier ball at the bottom, and then released from a certain height, both balls will accelerate downwards due to gravity from rest. What happens when the bottom ball hits the ground and bounces back? There are numerous experimental videos on YouTube, such as \"Stacked Ball Drop\". We can use previously written simulation programs for \"Free Fall\" and \"One-Dimensional Elastic Collision\" to handle this problem.\n\nScreenshot of the program for the free fall collision of two balls: ![image](https://hackmd.io/_uploads/SyOtLjT_C.png)\n\nThe program for the free fall collision of two balls involves two balls.\n\nParameter Settings\n\nIn this setup, variables are defined for the radius, mass, and color of the balls, the height of the balls from the ground, the length of the floor, gravitational acceleration, time, and time interval. Please refer to the program code for the corresponding variable names.\n\nDisplay Settings\nThe code for generating the animation window, floor, balls, and drawing window has appeared many times in previous animations, so it is not elaborated here. A special feature in the animation window is the addition of an option range=L, which limits the display range of the animation window to prevent the view from automatically shrinking when the upper ball bounces too high.\n\nMotion of Objects\nUpdate the velocity and position of the balls.\nIf b1.pos.y <= 0, it means b1 has hit the floor, and its velocity is reversed to make b1 bounce.\nIf b2.pos.y - b1.pos.y <= r1 + r2, it means b1 and b2 have collided. Insert m1, b1.v.y, m2, b2.v.y into the custom function af_col_v to calculate the post-collision velocity, and then reassign to b1.v.y, b2.v.y.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\ng = 9.8\nL = 2\nr1 = 0.05\nr2 = 0.05\nm1 = 0.2\nm2 = 0.2\nh1 = L\nh2 = L+r1+r2\ndt = 0.001\n\n# Post-collision velocity\ndef af_col_v(m1, v1, m2, v2):\n    return (2*m2*v2 + v1*(m1 - m2)) / (m1 + m2), (2*m1*v1 + v2*(m2 - m1)) / (m1 + m2)\n\n# Objects\nfloor = box(length=2, height=0.01, width=2, color=color.blue)\nb1 = sphere(radius=r1, color=color.red)\nb2 = sphere(radius=r2, color=color.green)\nb1.pos = vector(0, h1, 0)\nb2.pos = vector(0, h2, 0)\nb1.v = vector(0, 0, 0)\nb2.v = vector(0, 0, 0)\n\n# Animation\nwhile True:\n    rate(1000)\n    \n    # Update velocity & position\n    b1.v.y -= g*dt\n    b2.v.y -= g*dt\n    b1.pos.y += b1.v.y*dt\n    b2.pos.y += b2.v.y*dt\n    \n    # Collision with floor\n    if b1.pos.y <= r1:\n        b1.v.y = -b1.v.y\n        \n    # Collision with each other\n    if b2.pos.y - b1.pos.y <= r1 + r2:\n        b1.v.y, b2.v.y = af_col_v(m1, b1.v.y, m2, b2.v.y)",
      "mode": "initial",
      "timestamp": "2024-07-24 13:06:41",
      "serial_number": 1
    }
  ]
}