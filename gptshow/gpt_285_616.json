{
  "session_id": 616,
  "log": [
    {
      "input": "Program to be written: Planetary motion, store planetary data in a dictionary, generate planets using a for loop.\n\nKepler\u2019s laws of planetary motion consist of the following three laws:\n\n1. **First Law (Law of Orbits)**: All planets move in elliptical orbits with the Sun at one of the foci.\n\n2. **Second Law (Law of Equal Areas)**: The line segment joining a planet and the sun sweeps out equal areas during equal intervals of time. If $r$ is the distance between the sun and the planet, $v$ is the velocity of the planet, and $\\theta$ is the angle between $r$ and $v$, then the area swept out by the line segment per unit time is\n$$\n\\frac{\\Delta A}{\\Delta t} = \\frac{1}{2} rv \\sin{\\theta} = \\text{constant}\n$$\n\n3. **Third Law (Law of Periods)**: For all planets orbiting the Sun, the square of the orbital period $T$ is proportional to the cube of the semi-major axis of the orbit $a$\n$$\n\\frac{a^3}{T^2} = \\text{constant}\n$$\n\nThe first law is due to the only force acting between the Sun and the planets being gravity, which according to the law of universal gravitation, proves that only an ellipse can be a stable orbit. The second law is because the angular momentum of the planet relative to the sun is conserved due to gravity passing through the sun, hence the area swept by the planet-sun line segment is equal in equal times. The third law can be derived using gravitational force as the centripetal force. Using real data from the solar system's planets, these three laws should be graphically representable.\n\nProgram Design Part\n\nThis is a shortcut derived from the program \"Planetary Motion,\" which uses a dictionary to store planetary data. Since the code for generating planets and calculating acceleration, updating speed, and position is nearly identical for each planet, writing the same code four times for four planets is too cumbersome. Using a for loop can reduce the amount of code by three-quarters.\n\nWhen generating planets, first store the names of the planets to be generated in a list:\n\nnames = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\"]\n\nLines 31 to 35, open a blank list named planets, then use a for loop to take the planet names from names and assign them to the variable name. When using sphere to create a sphere, throw it into the dictionary used to store data as a key, allowing the corresponding data to be read. Next, use planets.append() to add the object in the parentheses to the end of the planets list. In Python, there is a special syntax that allows generating a list with a for loop in one line of code, so lines 31 to 35 can be rewritten as:\n\nplanets = [sphere(pos=vec(d_at_aphelion[name], 0, 0), radius=radius[name]*2E3, m=mass[name], \n                  color=material[name], make_trail=True, retain = 365, v=vec(0, v_at_aphelion[name], 0)) for name in names]\n\nCalculate the acceleration, update the velocity, and position of the planets. Use a for loop to take the planet objects from planets and assign them to the variable planet. Use\nplanet.a = - G*sun.m / planet.pos.mag2 * planet.pos.norm()\nto calculate acceleration, then use\nplanet.v += planet.a*dt\nto update the velocity, and finally use\nplanet.pos += planet.v*dt\nto update the position.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1E10\n\n(2) Radius_I is the radius of the planet. When Radius_I changes to a new value, the radius of the planet also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\nG = 6.67428E-11  # Gravitational constant\nmass = {\"Sun\": 1.9891E30, \"Mercury\": 3.3022E23, \"Venus\": 4.8685E24, \"Earth\": 5.9736E24, \"Mars\": 6.4185E23}  # Mass of planets, kg\nradius = {\"Sun\": 6.9634E8, \"Mercury\": 2.4397E6, \"Venus\": 6.0518E6, \"Earth\": 6.37101E6, \"Mars\": 3.390E6}  # Radii of planets, m\nd_at_aphelion = {\"Mercury\": 6.9816E10, \"Venus\": 1.0894E11, \"Earth\": 1.5210E11, \"Mars\": 2.4923E11}  # Distance at aphelion, m\nT = {\"Mercury\": 0.240846, \"Venus\": 0.615198, \"Earth\": 1, \"Mars\": 1.8808}  # Orbital period, yr\nv_at_aphelion = {name: 2*pi*d_at_aphelion[name]/T[name]/(60*60*24*365.25) for name in [\"Mercury\", \"Venus\", \"Earth\", \"Mars\"]}  # Velocity at aphelion, m/s\nmaterial = {\"Mercury\": color.red, \"Venus\": color.orange, \"Earth\": color.blue, \"Mars\": color.red}  # Planet colors\n\n# Create solar system objects\nscene = canvas(title=\"Solar System\", width=800, height=800, range=2E11)\nsun = sphere(pos=vec(0, 0, 0), radius=6.9634E8, m=mass[\"Sun\"], color=color.yellow)\nnames = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\"]\nplanets = [sphere(pos=vec(d_at_aphelion[name], 0, 0), radius=radius[name]*2E3, m=mass[name],\n                  color=material[name], make_trail=True, retain=365, v=vec(0, v_at_aphelion[name], 0)) for name in names]\n\n# Time parameters\nt = 0  # Initial time, sec\ndt = 60 * 60 * 24  # Time step, sec\n\n# Main loop\nwhile True:\n    rate(100)  # Limit execution speed\n    for planet in planets:\n        planet.a = - G * sun.m / planet.pos.mag2 * planet.pos.norm()  # Calculate acceleration\n        planet.v += planet.a * dt  # Update velocity\n        planet.pos += planet.v * dt  # Update position\n    t += dt  # Update time",
      "mode": "initial",
      "timestamp": "2024-07-24 03:59:12",
      "serial_number": 1
    }
  ]
}