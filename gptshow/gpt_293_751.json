{
  "session_id": 751,
  "log": [
    {
      "input": "Please write a Vpython program for \"Free Falling Three Ball Collision\"\n\nOne-dimensional Elastic Collision Velocity Formula\n\nAssume two particles have masses \\( m_1 \\) and \\( m_2 \\), with initial velocities \\( v_1 \\) and \\( v_2 \\) respectively. After the collision, their velocities become \\( v_1' \\) and \\( v_2' \\) respectively, given by:\n\n\\[ v_1' = \\frac{m_1 - m_2}{m_1 + m_2} v_1 + \\frac{2m_2}{m_1 + m_2} v_2 \\]\n\n\\[ v_2' = \\frac{2m_1}{m_1 + m_2} v_1 + \\frac{m_2 - m_1}{m_1 + m_2} v_2 \\]\n\nWhere:\n- \\( v_1' \\) is the velocity of mass \\( m_1 \\) after the collision\n- \\( v_2' \\) is the velocity of mass \\( m_2 \\) after the collision\n- \\( v_1 \\) is the velocity of mass \\( m_1 \\) before the collision\n- \\( v_2 \\) is the velocity of mass \\( m_2 \\) before the collision\n\nThere are three balls: one red, one green, and one blue. Create a floor with a side length of 50. The red ball has a mass of 3 and a radius of 3, the green ball has a mass of 2 and a radius of 2, and the blue ball has a mass of 1 and a radius of 1. The balls are stacked vertically. The green ball is stacked on top of the red ball, and the blue ball is stacked on top of the green ball. Release the three stacked balls from a height of 15 above the floor, where they start accelerating downwards due to gravity, and the red ball bounces upon hitting the floor. The balls adhere to one-dimensional elastic collision. The range of the green ball's bounce after colliding with the red ball is only between the red and blue balls, and the blue ball's bounce after colliding with the green ball is only above the green ball. If the red ball hits the ground, it will bounce back. If the red and green balls collide, their masses and velocities in the y-direction are plugged into the one-dimensional elastic collision formula to compute the post-collision velocities, which are then reassigned to the velocities of the red and green balls in the y-direction. If the green and blue balls collide, their masses and velocities in the y-direction are plugged into the one-dimensional elastic collision formula to compute the post-collision velocities, which are then reassigned to the velocities of the green and blue balls in the y-direction. Since the balls below: the red and green balls are heavier than the blue ball, the rebound height of the blue ball will far exceed its original height above the ground.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\ng = vec(0, -9.8, 0)\nheight = 15\nsize = 0.5\ndt = 0.001\nRadius_I = 1\n\n# Objects\nfloor = box(pos=vec(0, -0.5 * size, 0), length=50, height=size, width=10, color=color.blue)\nball_1 = sphere(pos=vec(0, height - Radius_I * 3, 0), radius=3 * Radius_I, color=color.red, v=vec(0, 0, 0), m=3)\nball_2 = sphere(pos=vec(0, height - Radius_I * 3 - Radius_I * 2, 0), radius=2 * Radius_I, color=color.green, v=vec(0, 0, 0), m=2)\nball_3 = sphere(pos=vec(0, height - Radius_I * 3 - Radius_I * 2 - Radius_I, 0), radius=Radius_I, color=color.blue, v=vec(0, 0, 0), m=1)\n\n# Animation\nwhile True:\n    rate(1000)\n\n    ball_1.v += g * dt\n    ball_1.pos += ball_1.v * dt\n\n    ball_2.v += g * dt\n    ball_2.pos += ball_2.v * dt\n\n    ball_3.v += g * dt\n    ball_3.pos += ball_3.v * dt\n\n    if ball_1.pos.y <= floor.pos.y + ball_1.radius and ball_1.v.y < 0:\n        ball_1.v.y = - ball_1.v.y\n\n    if ball_2.pos.y <= ball_1.pos.y + ball_1.radius + ball_2.radius and ball_2.v.y < ball_1.v.y:\n        ball_1.v.y = ((ball_1.m - ball_2.m) / (ball_1.m + ball_2.m)) * ball_1.v.y + ((2 * ball_2.m) / (ball_1.m + ball_2.m)) * ball_2.v.y\n        ball_2.v.y = ((2 * ball_1.m) / (ball_1.m + ball_2.m)) * ball_1.v.y + ((ball_2.m - ball_1.m) / (ball_1.m + ball_2.m)) * ball_2.v.y\n\n    if ball_3.pos.y <= ball_2.pos.y + ball_2.radius + ball_3.radius and ball_3.v.y < ball_2.v.y:\n        ball_2.v.y = ((ball_2.m - ball_3.m) / (ball_2.m + ball_3.m)) * ball_2.v.y + ((2 * ball_3.m) / (ball_2.m + ball_3.m)) * ball_3.v.y\n        ball_3.v.y = ((2 * ball_2.m) / (ball_2.m + ball_3.m)) * ball_2.v.y + ((ball_3.m - ball_2.m) / (ball_2.m + ball_3.m)) * ball_3.v.y",
      "mode": "initial",
      "timestamp": "2024-07-25 18:42:30",
      "serial_number": 1
    }
  ]
}