{
  "session_id": 875,
  "log": [
    {
      "input": "# Simple Harmonic Motion\n\nOn a horizontal frictionless table, there is a block of mass $m$ connected to a wall on the left by a spring with a spring constant $k$. If the block is pulled to the right by a distance $R$ and then released from rest, the relationship between the net force experienced by the block and its acceleration is given by\n$$\nF = -kx = ma \\Rightarrow -kx = m \\frac{d^2 x}{d t^2}\n$$\n\nAt this point, the motion of the block is known as simple harmonic motion (S.H.M.). From the equation above, we can solve for:\n$$\nx(t) = R \\cos(\\omega t + \\phi)\n$$\n$$\nv(t) = -\\omega R \\sin(\\omega t + \\phi)\n$$\n$$\na(t) = -\\omega^2 R \\cos(\\omega t + \\phi)\n$$\n\nIn the above equations, $\\omega$ represents the angular frequency:\n$$\n\\omega = \\sqrt{\\frac{k}{m}}\n$$\n\nThe period is given by:\n$$\nT = 2\\pi \\sqrt{\\frac{m}{k}}\n$$\n\nTheoretically, by setting up the relationship between the restoring force of the spring and the position of the block from the equilibrium point in VPython, we should be able to simulate the process and period of simple harmonic motion.\n\n## Parameter Settings\n\nVariables defined here include m, size, R, k, L0, i, t, dt, and their purposes are already commented on in the respective lines.\n\n## Screen Setup\n\nSince I want the center of the block to be on the x-axis, the floor's position is moved downward to y = -(size+0.1)/2.\nTo allow the block to oscillate back and forth between $-R \\leq x \\leq R$, the wall is moved to the left to x = -L0.\nSince the block's position is centered, and the spring is attached to the left of the block, the block needs to be placed to the right of the spring's endpoint by size/2.\nTo draw the spring, a new object called helix (spiral) is used, with adjustable options including:\n- Position (pos), based on the endpoint of the spiral.\n- Radius (radius)\n- Axis (axis), starting from the position, formatted as a vector.\n- Thickness (thickness), the radius of the line itself, default value is radius/20.\n- Color (color)\n\n## Object Movement\n\nFirst, calculate and update the direction and length of the spring's axis using `spring.axis = block.pos - spring.pos - vector(size/2, 0, 0)`, then compute the stretch and restoring force of the spring using `F = -k * (spring.axis - vector(L0, 0, 0))`.\nTo determine if the block returns to the starting point, there are various methods. I use `block.pos.x > R + size/2` and the block's velocity direction to the right to judge. When the block returns to the starting point, increment the count i by 1 and print the time.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Amplification_I as a cyber input variable, set Amplification_I=5\n(2) Amplification_I is the amplification of the block. When Amplification_I changes to a new value, the amplification of the block also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nm = 0.2  # block mass\nsize = 0.05  # block size\nR = 0.3  # initial stretch of the spring\nk = 15  # spring constant\nL0 = R + size / 2 + 0.005  # spring original length\ni = 0  # counting variable\nt = 0  # time\ndt = 0.001  # time step\nAmplification_I = 5  # amplification variable\n\n# Screen Setup\nscene = canvas(width=800, height=800, align='left', background=vector(0.5, 0.5, 0))\nfloor = box(pos=vector(0, -size / 2, 0), length=0.6, height=0.005, width=0.3)\nwall = box(pos=vector(-L0, 0, 0), length=0.01, height=0.1, width=0.3)\nblock = box(pos=vector(R + size / 2, 0, 0), length=size, height=size, width=size, color=color.blue)\nspring = helix(pos=wall.pos, radius=0.02, thickness=0.01)\n\n# Object Movement\nwhile True:\n    rate(1000)\n    spring.axis = block.pos - spring.pos - vector(size / 2, 0, 0)\n    L = spring.axis.mag  # spring length\n    spring_force = -k * (spring.axis - vector(L0, 0, 0))  # spring force\n    block.a = spring_force / m  # block acceleration\n    block.v = block.a * dt  # block velocity\n    block.pos += block.v * dt / Amplification_I  # block position\n    t += dt\n\n    # check if block returns to start\n    if block.v.x > 0 and block.pos.x > R + size / 2 and i == 0:\n        T = t  # period\n        i += 1\n    elif block.v.x < 0 and block.pos.x < R + size / 2 and i == 1:\n        print(\"Period = \", 2 * T)\n        i = 0",
      "mode": "initial",
      "timestamp": "2024-07-27 12:45:06",
      "serial_number": 1
    }
  ]
}