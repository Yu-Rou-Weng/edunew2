{
  "session_id": 568,
  "log": [
    {
      "input": "Free fall, the ball bounces when it hits the ground, with a coefficient of restitution \\(e\\)\n\nAllow the object to be affected by gravity, with the objective to simulate a ball falling from a certain height, accelerating downwards to the floor, and bouncing upon impact, with a coefficient of restitution \\(e\\).\n\nThe program for \"Free fall, the ball bounces when it hits the ground, with a coefficient of restitution \\(e\\)\" and \"Free fall, the ball bounces when it hits the ground\" are almost identical, with only the differences described below.\n\nSince the collision between the ball and the floor is not perfectly elastic, we define the coefficient of restitution as:\n\n\\[ e = \\frac{v'}{v} \\]\nwhere:\n- \\( v \\) is the velocity before the collision\n- \\( v' \\) is the velocity after the collision\n\nCode modification for collision:\n\nThe code executed upon collision is modified to:\n\n\\[ \\text{ball.v.y} = -\\text{ball.v.y} \\times e \\]\n\nCounting collisions:\nTo count the number of times the ball hits the floor, and to stop the program after 20 collisions, add the variables:\n\n\\[ i = 0 \\] (number of times the ball hits the floor, default value is 0)\n\\[ N = 20 \\] (upper limit of floor collisions, after which the program stops)\nThe condition in the while loop is changed to \\( i < N \\), and with each collision, the value of \\( i \\) is incremented by 1.\n\nPrecise collision conditions:\nTo make the conditions for the ball hitting the floor more precise, the floor\u2019s thickness must be considered, so the if condition is modified to:\n\n\\[ \\text{if ball.pos.y - floor.pos.y} \\leq \\text{size} + 0.5 \\times \\text{floor.height} \\text{ and ball.v.y < 0:} \\]\n\nIn the above equation, \\( \\text{floor.height} \\) is used to read the height value of the object \\( \\text{floor} \\).\n\nCyber Input Variable Mapping Information:\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math and time.",
      "output": "from vpython import *\n\n# Constants\ng = 9.8  # acceleration due to gravity\nsize = 0.5  # ball radius\nheight = 15.0  # ball initial height\ne = 0.9  # coefficient of restitution\n\n# Objects\nfloor = box(length=30, height=0.01, width=10, color=color.blue)  # floor\nball = sphere(radius=size, color=color.red, make_trail=True)  # ball\n\n# Initial Conditions\nball.pos = vector(0, height, 0)  # ball initial position\nball.v = vector(0, 0, 0)  # ball initial velocity\ndt = 0.001  # time step size\ni = 0  # collision counter\nN = 20  # upper limit of floor collisions\n\n# Time evolution (animation)\nwhile i < N:\n    rate(1000)  # limit the execution speed to 1000 loops per second\n    ball.pos = ball.pos + ball.v * dt  # update position\n    ball.v.y = ball.v.y - g * dt  # update velocity\n\n    if ball.pos.y - floor.pos.y <= size + 0.5 * floor.height and ball.v.y < 0:\n        i += 1  # update collision counter\n        ball.v.y = -ball.v.y * e  # update velocity upon collision",
      "mode": "initial",
      "timestamp": "2024-07-23 21:29:19",
      "serial_number": 1
    }
  ]
}