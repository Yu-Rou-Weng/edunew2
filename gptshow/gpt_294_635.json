{
  "session_id": 635,
  "log": [
    {
      "input": "# Three-Dimensional Elastic Collision, m1 = m2\n\nThis program primarily references the lecture notes \"VPhysics Freshman Course: Collisions\" by Professor Ming-Feng Shih from the Department of Physics at National Taiwan University. However, the code within has been rewritten to comply with Python 3.X format. After completing this program, it can be used to simulate collisions between ideal gas molecules and produce a graph of molecule quantity versus speed distribution. Due to the complexity of this program, please refer to the VPython example program \u201cA hard-sphere gas\u201d.\n\nProgram to be written: Three-dimensional elastic collision, m1 = m2, both spheres of equal mass\n\n### Theoretical Derivation\n\nAssume there are two elastic spheres of equal size in space, with masses $m_1$ and $m_2$ respectively, and initial velocities $v_1$ and $v_2$. Derive the formula for the velocities of the spheres after collision. The special case when the masses are equal is given as\n\n$$\nv_1' = v_1 + \\frac{(v_2 - v_1) \\cdot (r_1 - r_2)}{|r_1 - r_2|^2} (r_1 - r_2)\n$$\n\n$$\nv_2' = v_2 + \\frac{(v_1 - v_2) \\cdot (r_2 - r_1)}{|r_2 - r_1|^2} (r_2 - r_1)\n$$\n\nProof:  \nAssuming the change in momentum during the collision of the two spheres is $\\Delta p$, then\n\n$$\n\\Delta p_1 = \\Delta p \\frac{r_1 - r_2}{|r_1 - r_2|}\n$$\n\n$$\n\\Delta p_2 = - \\Delta p_1 = \\Delta p \\frac{r_2 - r_1}{|r_2 - r_1|}\n$$\n\nThe momenta of the spheres after the collision are\n\n$$\np_1' = p_1 + \\Delta p_1 \\Rightarrow m_1 v_1' = m_1 v_1 + \\Delta p \\frac{r_1 - r_2}{|r_1 - r_2|}\n$$\n\n$$\np_2' = p_2 + \\Delta p_2 \\Rightarrow m_2 v_2' = m_2 v_2 + \\Delta p \\frac{r_2 - r_1}{|r_2 - r_1|}\n$$\n\nSince the collision is elastic, there is no loss of kinetic energy before and after the collision,\n\n$$\n\\frac{1}{2} m_1 v_1^2 + \\frac{1}{2} m_2 v_2^2 = \\frac{1}{2} m_1 v_1'^2 + \\frac{1}{2} m_2 v_2'^2\n$$\n\nSubstituting $v_1'$ and $v_2'$ into the equation and multiplying by 2,\n\n$$\nm_1 v_1^2 + m_2 v_2^2 = m_1 \\left[ v_1 + \\Delta p \\frac{(r_1 - r_2)}{m_1 |r_1 - r_2|} \\right]^2 + m_2 \\left[ v_2 + \\Delta p \\frac{(r_2 - r_1)}{m_2 |r_2 - r_1|} \\right]^2\n$$\n\n$$\nm_1 v_1^2 + m_2 v_2^2 = m_1 v_1^2 + 2 \\Delta p \\frac{v_1 \\cdot (r_1 - r_2)}{|r_1 - r_2|} + \\frac{(\\Delta p)^2}{m_1} \\frac{(r_1 - r_2)^2}{|r_1 - r_2|^2} + m_2 v_2^2 + 2 \\Delta p \\frac{v_2 \\cdot (r_2 - r_1)}{|r_1 - r_2|} + \\frac{(\\Delta p)^2}{m_2} \\frac{(r_2 - r_1)^2}{|r_2 - r_1|^2}\n$$\n\nBecause $(r_1 - r_2)^2 = |r_1 - r_2|^2$, the equation can be simplified to\n\n$$\n2 \\Delta p \\frac{(v_1 - v_2) \\cdot (r_1 - r_2)}{|r_1 - r_2|} + (\\Delta p)^2 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) = 0\n$$\n\n$$\n2 \\frac{(v_1 - v_2) \\cdot (r_1 - r_2)}{|r_1 - r_2|} + \\Delta p \\frac{m1 + m2}{m_1 m_2} = 0\n$$\n\n$$\n\\Delta p = \\frac{2 m_1 m_2}{m_1 + m_2} \\frac{(v_2 - v_1) \\cdot (r_1 - r_2)}{|r_1 - r_2|}\n$$\n\nSubstituting into the top two equations yields the post-collision velocities\n\n$$\nv_1' = v_1 + \\frac{2 m_2}{m_1 + m_2} \\frac{(v_2 - v_1) \\cdot (r_1 - r_2)}{|r_1 - r_2|^2} (r_1 - r_2)\n$$\n\n$$\nv_2' = v_2 + \\frac{2 m_1}{m_1 + m_2} \\frac{(v_1 - v_2) \\cdot (r_2 - r_1)}{|r_2 - r_1|^2} (r_2 - r_1)\n$$\n\n\nScreenshot:\n![image](https://hackmd.io/_uploads/Hyuy9sTdR.png)\n\n\nParameter Settings\nVariables such as the radius, mass, color, initial velocity, dimension of the screen, time, and time interval are set here. Please refer to the variable names in the code.\n\n\nScreen Setup\nThe code for creating animation windows, balls, and drawing windows has appeared many times in previous animations and will not be reiterated here.\n\n\nCustom Function\nThe custom function af_col_v calculates the post-collision velocity. The content of the function is\n\nv1_prime = v1 + dot((v2 - v1), (x1 - x2)) / mag2(x1 - x2) * (x1 - x2)\nv2_prime = v2 + dot((v1 - v2), (x2 - x1)) / mag2(x2 - x1) * (x2 - x1)\nThis transcribes the formula derived theoretically into code, utilizing two vector calculations:\n\ndot(a, b): takes the dot product of vectors a and b\nmag2(a) = a.mag2: calculates the square of the magnitude of vector a\n\nObject Motion Part\nUpdates the position of the balls.\nIf mag(b1.pos - b2.pos) <= r1 + r2 and dot((b1.pos - b2.pos), (b1.v - b2.v)) <= 0, it indicates a collision between b1 and b2. The velocities and positions (b1.v, b2.v, b1.pos, b2.pos) are then input into the custom function af_col_v to calculate the post-collision velocity, which is reassigned to b1.v and b2.v.\n\n\nCyber Input Variable Mapping Information:\n\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nRadius_I = 1\nmass1 = 1.0\nmass2 = 1.0\nball1 = sphere(pos=vector(-15, 0, 0), radius=Radius_I, color=color.red, v=vector(0.2, 0.1, 0))\nball2 = sphere(pos=vector(15, 0, 0), radius=Radius_I, color=color.green, v=vector(-0.2, -0.1, 0))\nwallR = box(pos=vector(25, 0, 0), size=vector(0.2, 50, 50), color=color.blue)\nwallL = box(pos=vector(-25, 0, 0), size=vector(0.2, 50, 50), color=color.blue)\nwallT = box(pos=vector(0, 25, 0), size=vector(50, 0.2, 50), color=color.blue)\nwallB = box(pos=vector(0, -25, 0), size=vector(50, 0.2, 50), color=color.blue)\nwallBK = box(pos=vector(0, 0, -25), size=vector(50, 50, 0.2), color=color.blue)\nball1.m = mass1\nball2.m = mass2\n\ndt = 0.005\n\ndef af_col_v(v1, v2, x1, x2, m1, m2):  # function after collision velocity / mass\n    v1_prime = v1 + (dot(v2 - v1, x1 - x2) / mag2(x1 - x2)) * (x1 - x2)\n    v2_prime = v2 + (dot(v1 - v2, x2 - x1) / mag2(x2 - x1)) * (x2 - x1)\n    return v1_prime, v2_prime\n\n# Object Motion Part\nwhile True:\n    rate(1000)\n    ball1.pos = ball1.pos + ball1.v * dt\n    ball2.pos = ball2.pos + ball2.v * dt\n    if abs(ball1.pos.x) > 24:\n        ball1.v.x = -ball1.v.x\n    if abs(ball2.pos.x) > 24:\n        ball2.v.x = -ball2.v.x\n    if abs(ball1.pos.y) > 24:\n        ball1.v.y = -ball1.v.y\n    if abs(ball2.pos.y) > 24:\n        ball2.v.y = -ball2.v.y\n    if abs(ball1.pos.z) > 24:\n        ball1.v.z = -ball1.v.z\n    if abs(ball2.pos.z) > 24:\n        ball2.v.z = -ball2.v.z\n    if mag(ball1.pos - ball2.pos) < 2 * Radius_I and dot(ball1.pos - ball2.pos, ball1.v - ball2.v) < 0:\n        ball1.v, ball2.v = af_col_v(ball1.v, ball2.v, ball1.pos, ball2.pos, ball1.m, ball2.m)",
      "mode": "initial",
      "timestamp": "2024-07-24 06:25:49",
      "serial_number": 1
    }
  ]
}