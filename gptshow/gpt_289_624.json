{
  "session_id": 624,
  "log": [
    {
      "input": "Double Simple Harmonic Motion Composed of a Horizontal Spring and Spheres\n\nAssume there are two spheres on a smooth horizontal table, with masses m1 and m2 respectively, connected by an ideal spring with a spring constant k. If one of the spheres is struck to impart momentum, the entire system will move forward in a manner similar to a caterpillar crawling. Previously, I saw an animation made with Mathematica, but this time we will achieve the same effect using VPython.\n\nParameter Settings\n\nHere, variables are set for the radius of the spheres, mass, initial velocity, color, the natural length of the spring, elasticity constant, the range of the x-axis, time, and time intervals. The time interval dt is set to 0.00005 because when set to 0.001, the calculation of the system's energy has a larger error, hence the choice of a smaller value.\n\nDisplay Settings\nThe code for generating the animation window, floor, spheres, and drawing window has appeared many times in previous animations and will not be reiterated here. An object less frequently used before is the helix, with adjustable options including:\n\nPosition (pos), based on the endpoint of the helix.\nRadius (radius)\nAxis (axis), starting from the position, formatted as a vector.\nThickness (thickness), the radius of the line itself, default value is radius/20.\nColor (color)\n\nObject Motion\nTo make the animation repeat until sphere b2 reaches the right edge of the floor, the condition in the while loop is set as:\n\nb2.pos.x <= xmax\nUpdate the starting position of the spring, since the left end of the spring is connected at the center of sphere b1, therefore:\n\nspring.pos = b1.pos\nUpdate the length and direction of the spring, i.e., update the axis, since the spring is connected between the two spheres, therefore:\n\nspring.axis = b2.pos - b1.pos\nCalculate the restoring force of the spring using Hooke's Law. The deformation of the spring is spring.axis.mag - L0, if the deformation due to compression is negative, to push the right sphere to the right, the calculation should add a negative sign and multiply by the unit vector of the spring axis, the code is:\n\nforce = -k*(spring.axis.mag - L0) * spring.axis.norm()\nIf the spring stretches and the deformation is positive, at this time the right sphere is pulled to the left, the force obtained in the above formula is opposite to the direction of the spring's axis, which is consistent with the actual situation.\n\nCalculate the acceleration of the spheres, update the velocity, position, calculate the kinetic energy of the block, the potential elastic energy of the system, and the total energy.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Length_I as a cyber input variable, set Length_I=10\n(2) Radius_I is the elasticity constants of the spring. When Radius_I changes to a new value, the elasticity constants of the spring also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter settings\nRadius_I = 0.5\nk = 5\nm1 = 0.2\nm2 = 0.3\nv1 = vector(0.1, 0, 0)\nv2 = vector(-0.1, 0, 0)\ncolor1 = color.red\ncolor2 = color.green\nL0 = 3\nxmax = 12\nt = 0\ndt = 0.00005\nLength_I = 10\n\n# Display settings\nscene = canvas(title=\"Double Simple Harmonic Motion Composed of a Horizontal Spring and Spheres\", width=1000, height=600, x=0, y=0, center=vector(Length_I/2.0, 0, 0), background=color.white)\nfloor = box(pos=vector(Length_I/2.0, -Radius_I-0.01, 0), size=vector(Length_I, 0.02, 0.02), color=color.blue)\nb1 = sphere(pos=vector(-xmax/2.0, 0, 0), radius=Radius_I, color=color1, make_trail=True)\nb2 = sphere(pos=vector(-xmax/2.0 + L0, 0, 0), radius=Radius_I, color=color2, make_trail=True)\nspring = helix(pos=b1.pos, radius=0.4*Radius_I, thickness=0.1*Radius_I, axis=b2.pos-b1.pos, color=color.yellow)\n\n# Object motion\nwhile b2.pos.x <= xmax:\n    rate(3000)\n    spring.pos = b1.pos\n    spring.axis = b2.pos - b1.pos\n    force = -k*(spring.axis.mag - L0) * spring.axis.norm()\n    a1 = force/m1\n    a2 = -force/m2\n    v1 += a1*dt\n    v2 += a2*dt\n    b1.pos += v1*dt\n    b2.pos += v2*dt\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 05:40:31",
      "serial_number": 1
    }
  ]
}