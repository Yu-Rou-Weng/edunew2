{
  "session_id": 716,
  "log": [
    {
      "input": "Magnetic Fields Generated by Long Straight Current-Carrying Wires\n\nChapter 8 of elective physics, \"Magnetic Effects of Current,\" introduces the Biot-Savart Law, which is used to calculate the magnetic field produced at a point in space by a small segment of current-carrying wire. The equation is:\n$$\nd\\vec{B} = \\frac{\\mu_0}{4\\pi} \\frac{I d\\vec{L} \\times \\hat{r}}{r^2} \\Rightarrow dB = \\frac{\\mu_0}{4\\pi} \\frac{I dL \\sin{\\theta}}{r^2}\n$$\n\nUsing the Biot-Savart Law, the magnitude of the magnetic field at a perpendicular distance \\( r \\) from a long straight current-carrying wire is:\n$$\nB = \\frac{\\mu_0 I}{2\\pi r}\n$$\n\nThe magnitude of the magnetic field at the center of a current-carrying loop with radius \\( r \\) is:\n$$\nB = \\frac{\\mu_0 I}{2r}\n$$\n\nThe magnetic field strength at the center of a solenoid with \\( n \\) turns per unit length carrying a current is:\n$$\nB = \\mu_0 n I\n$$\n\nAlthough magnetic fields are distributed throughout space, the diagrams in textbooks are often planar. Therefore, I intend to use VPython to visualize the strength and direction of the magnetic field in space.\n\nParameter Settings\n\nVariables such as size, n, L, d, mu, current, direct, and N are set here with their purposes commented in the respective lines. To make the arrows representing the magnetic field more visible, a very large current value is set.\n\nDisplay Settings\nCreation of an animation window and the wire.\n\nA blank list segs is created, and spheres are added to this list using a for loop to represent segments of the wire. The two methods below achieve the same effect; the first method is more verbose but easier to understand, while the second is more concise but less clear:\n\n```python\nsegs = []\nfor i in range(n+1):\n    segs.append(sphere(pos=line.pos + vec(i*d, 0, 0), radius=size, color=color.cyan))\nsegs = [sphere(pos=line.pos + vec(i*d, 0, 0), radius=size, color=color.cyan) for i in range(n+1)]\n```\n\nA blank list locations is created, and the positions for placing arrows are calculated using a triple for loop, with two variants:\n\n```python\nfields = []\nfor location in locations:\n    fields.append(arrow(pos=location, axis=vec(0, 0, 0), color=color.green))\nfields = [arrow(pos=location, axis=vec(0, 0, 0), color=color.green) for location in locations]\n```\n\nA custom function `magnetic`, which takes a location coordinate `loc` as input and a list `segments` storing segmented wire data, calculates the magnetic field using the Biot-Savart Law.\n\nArrows are created at corresponding positions from the list locations.\n\nThe length and direction of the arrows are updated, tracking the maximum magnetic field strength \\( B_{max} \\). Arrows are colored red as their value approaches \\( B_{max} \\), and green as their value approaches zero. \n\nIllustrative Diagram:\n![image](https://hackmd.io/_uploads/H1fL6hp_R.png)\n(1) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameters\nmu = 4*pi*1E-7 # Permeability of free space\nI = 1000 # Current through the wire\nn = 5 # Number of segments\nd = 1.0 # Length of each segment\nsize = 0.2 # Radius of each segment\nL = n*d # Total length of the wire\n\n# Display settings\nscene = canvas(width=800, height=800, background=vec(0.5,0.5,0))\nscene.range = 2.5*L\nscene.forward = vec(0, -1, -2)\n\n# Creation of wire\nwire = cylinder(pos=vec(-L/2, 0, 0), axis=vec(L, 0, 0), radius=size, color=color.blue)\n\n# Dividing the wire into segments\nsegs = []\nfor i in range(n+1):\n    segs.append(sphere(pos=wire.pos + vec(i*d, 0, 0), radius=size, color=color.cyan))\n\n# Calculation of magnetic fields\nN = 300 # Number of field lines\nlocations = [vec(x, y, z) for x in arange(-2*L, 2*L, L/N) for y in arange(-2*L, 2*L, L/N) for z in arange(-2*L, 2*L, L/N)]\nfields = [arrow(pos=loc, axis=vec(0, 0, 0), color=color.green) for loc in locations]\n\n# Function to calculate the magnetic field at a point in space due to a current segment\ndef magnetic(loc, segs):\n    B = vec(0, 0, 0)\n    for seg in segs:\n        r = loc - seg.pos\n        if mag(r) < size:\n            B = vec(0, 0, 0)\n        else:\n            dB = (mu/4/pi) * I * cross(vec(d, 0, 0), norm(r)) / mag(r)**2\n            B = B + dB\n    return B\n\n# Update the magnetic fields\nB_max = 0\nfor field in fields:\n    B = magnetic(field.pos, segs)\n    if mag(B) > B_max: B_max = mag(B)\n    field.axis = 0.5*L*norm(B)/N\n    field.color = (mag(B)/B_max, 1 - mag(B)/B_max, 0)",
      "mode": "initial",
      "timestamp": "2024-07-24 13:29:49",
      "serial_number": 1
    }
  ]
}