{
  "session_id": 626,
  "log": [
    {
      "input": "# One-Dimensional Elastic Collision\n\nAssume there are two balls on a horizontal smooth table with masses $m_1$ and $m_2$, and velocities $v_1$ and $v_2$, respectively. After colliding, the velocities of the balls change to $v_1'$ and $v_2'$. Since the collision between the two balls is not subjected to external forces, the system conserves momentum:\n$$\nm_1 v_1 + m_2 v_2 = m_1 v_1' + m_2 v_2' \\Rightarrow m_1 (v_1 - v_1') = m_2 (v_2' - v_2) \\quad (1)\n$$\n\nIf there is no energy loss during the collision, then the total kinetic energy of the two balls before and after the collision remains equal:\n$$\n\\frac{1}{2} m_1 v_1^2 + \\frac{1}{2} m_2 v_2^2 = \\frac{1}{2} m_1 v_1'^2 + \\frac{1}{2} m_2 v_2'^2\n$$\n$$\nm_1 (v_1^2 - v_1'^2) = m_2 (v_2'^2 - v_2^2)\n$$\n$$\nm_1 (v_1 + v_1') (v_1 - v_1') = m_2 (v_2' + v_2) (v_2' - v_2) \\quad (2)\n$$\n\nDividing equation (2) by equation (1) we get:\n$$\nv_1 + v_1' = v_2' + v_2 \\Rightarrow\n\\begin{cases}\nv_1' = v_2' + v_2 - v_1 \\quad (3) \\\\\nv_2' = v_1 + v_1' - v_2 \\quad (4)\n\\end{cases}\n$$\n\nSubstituting equation (4) into equation (1) we get:\n$$\nm_1 (v_1 - v_1') = m_2 [(v_1 + v_1' - v_2) - v_2]\n$$\n$$\n(m_1 + m_2) v_1' = (m_1 - m_2) v_1 + 2 m_2 v_2 \\Rightarrow v_1' = \\frac{m_1 - m_2}{m_1 + m_2} v_1 + \\frac{2 m_2}{m_1 + m_2} v_2\n$$\n\nSubstituting equation (3) into equation (1) we get:\n$$\nm_1 [v_1 - (v_2' + v_2 - v_1)] = m_2 (v_2' - v_2)\n$$\n$$\n(m_1 + m_2) v_2' = 2 m_1 v_1 + (m_2 - m_1) v_2 \\Rightarrow v_2' = \\frac{2 m_1}{m_1 + m_2} v_1 + \\frac{m_2 - m_1}{m_1 + m_2} v_2\n$$\n\nProgram to Implement: Directly use the post-collision velocity formulas.\n\n![image](https://hackmd.io/_uploads/S1x8VjadA.png)\n\n![image](https://hackmd.io/_uploads/H14w4jpOC.png)\nScreenshot of the one-dimensional elastic collision program\n\nParameter Settings\n\nHere, variables are set for the block's width, mass, initial velocity, color, the range of the x-axis, time, and time interval, where the time interval dt is set to 0.0005, as a larger value of 0.001 resulted in greater errors in calculating the block's energy, thus a smaller value was chosen.\n\nScreen Settings\nThe code for generating the animation window, floor, blocks, and drawing window has appeared many times in previous animations and is not repeated here.\n\nCustom Functions\nLines 36 to 39 of the code define a function named af_col_v, which takes parameters (m1, m2, v1, v2) and uses them in the one-dimensional elastic collision velocity formulas, returning the velocities v1_prime, v2_prime. This function is called on line 58 of the code:\n\nb1.v.x, b2.v.x = af_col_v(m1, m2, b1.v.x, b2.v.x)\n\nMotion of Objects\nThe animation stops when a block reaches the edge, so the condition for the while loop is set as:\n\nb2.pos.x <= xmax - d2/2 and b1.pos.x >= xmin + d1/2\nIf the distance between the centers of the two blocks is less than (d1 + d2) / 2, it indicates a collision has occurred, and the custom function af_col_v is called to calculate the post-collision velocities.\n\nUpdate the positions of the blocks.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Speed_I as a cyber input variable, set Speed_I=1\n(2) Speed_I is the Initial velocity of b1. When Speed_I changes to a new value, the initial velocity of b1 also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Predefined Constants\nd1, m1 = 0.2, 0.2  # for block 1\nd2, m2 = 0.4, 0.4  # for block 2\nv1 = 1.0  # initial velocity of block 1\nv2 = 0  # initial velocity of block 2\nL = 5  # length of the floor\nH = 0.05  # height of the floor\nT = 0.2  # thickness of the floor\ng = 9.8  # gravitational acceleration\ndt = 0.0005  # time interval for animation\nt = 0  # initial time\nb1color = color.red  # color of block 1\nb2color = color.blue  # color of block 2\nxmax = L / 2 - T / 2  # x component of the maximum range\nxmin = -xmax  # x component of the minimum range\n\n# Scene, Blocks and Floor Settings\nscene = canvas(width=600, height=300, align='left', center=vec(0, 0, 0), background=color.black)\nscene.range = 1.3 * (L / 2)\nfloor = box(pos=vec(0, -H / 2, 0), length=L, height=H, width=T, color=color.white)\nb1 = box(pos=vec(-L / 4, 0, 0), length=d1, height=H, width=T, color=b1color)\nb2 = box(pos=vec(L / 4, 0, 0), length=d2, height=H, width=T, color=b2color)\n\n# Initial conditions\nb1.v = vec(v1, 0, 0)\nb2.v = vec(v2, 0, 0)\n\n# After collision velocities\ndef af_col_v(m1, m2, v1, v2):\n    v1_prime = ((m1 - m2) / (m1 + m2)) * v1 + (2 * m2 / (m1 + m2)) * v2\n    v2_prime = (2 * m1 / (m1 + m2)) * v1 + ((m2 - m1) / (m1 + m2)) * v2\n    return v1_prime, v2_prime\n\n# Time evolution\nwhile b2.pos.x <= xmax - d2 / 2 and b1.pos.x >= xmin + d1 / 2:\n    rate(1000)\n    if abs(b1.pos.x - b2.pos.x) <= (d1 + d2) / 2:\n        b1.v.x, b2.v.x = af_col_v(m1, m2, b1.v.x, b2.v.x)\n    b1.pos.x += b1.v.x * dt\n    b2.pos.x += b2.v.x * dt\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 05:49:40",
      "serial_number": 1
    }
  ]
}