{
  "session_id": 665,
  "log": [
    {
      "input": "Speed Selector with an Exit Baffle\n\n# Speed Selector\n\nA speed selector is a device used to filter charged particles with specific velocities. Its basic structure is shown in the figure below. It creates a downward electric field using two parallel charged plates, combined with a magnetic field entering perpendicularly to the page. If a positively charged particle enters the speed selector from the left side with a horizontal velocity \\(v\\), the particle experiences a downward electrostatic force and an upward magnetic force. When the net force is zero, the particle moves at a constant velocity, where\n$$\nqE = qvB \\Rightarrow v = \\frac{E}{B} = \\frac{V}{Bd}\n$$\n\nIf a baffle with only a small hole is added on the right side, only particles moving straight right can pass through. By adjusting the magnitude of the electric and magnetic fields, the velocity of the particles passing through the device can be controlled. There are two programs associated:\n\n- Program 20-1: Draws the electric field, magnetic field, parallel charged plates, and particle trajectories. The particle stops moving when it hits the parallel charged plates.\n- Program 20-2: Based on 20-1, adds a baffle at the exit.\n\nProgram to be written: 20-2: Based on 20-1, adding a baffle at the exit.\n\n## Program Design\n\nOnly three changes were made:\n\n1. Adding a baffle at the exit:\n   ```python\n   b1 = box(pos=vec(L/2, d/4 + size, 0), size=vec(0.01*L, 0.5*d, L), color=color.gray(0.7))\n   b2 = box(pos=vec(L/2, -d/4 - size, 0), size=vec(0.01*L, 0.5*d, L), color=color.gray(0.7))\n   ```\n2. Modification of the while loop condition:\n   ```python\n   (charge.pos.x + size + b1.length/2 < L/2 and abs(charge.pos.y) < d/2 - p1.height - size) or \\\n   (L/2 < charge.pos.x + size + b1.length/2 < L and abs(charge.pos.y) < 0.1*size)\n   ```\n   (a) First part: The animation continues as long as the particle is between the parallel charged plates and hasn't hit them.\n   (b) Second part: The animation continues as long as the particle hasn't reached the edge of the screen or hit the baffle.\n\n## Simulation Results\n\nBelow are five different data combinations and their results:\n\n1. \\(v0 = 10, V = 1, d = 0.1, B = 1\\) \u21d2 Uniform linear motion\n   ![image](https://hackmd.io/_uploads/Hk0Ywhp_A.png)\n\n2. \\(q > 0, v0 = 20\\) other conditions same as combination 1 \u21d2 Upward deflection\n   ![image](https://hackmd.io/_uploads/SyQcD3puR.png)\n\n3. \\(q > 0, d = 0.2\\) other conditions same as combination 1 \u21d2 Upward deflection\n   ![image](https://hackmd.io/_uploads/Byqcv26uC.png)\n\n4. \\(q > 0, V = 2\\) other conditions same as combination 1 \u21d2 Downward deflection\n   ![image](https://hackmd.io/_uploads/S1RqDhadC.png)\n\n5. \\(q > 0, B = 5\\) other conditions same as combination 1 \u21d2 Upward deflection\n   ![image](https://hackmd.io/_uploads/SJviDn6OR.png)\n\n## Cyber Input Variable Mapping Information:\n\n1. Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1.\n2. Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(1) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\nscene = canvas(width=800, height=800, background=vec(0.5,0.5,0))\n\n# constants\nd = 0.1  # separation of parallel plates\nL = 1.0  # length of parallel plates\nV = 200.0  # voltage on parallel plates\nB = 1.0  # magnetic field\nq = 1.0  # charge on particle\nm = 1.0  # mass of particle\ndt = 0.001  # time step\nsize = 0.01  # size of particle\nRadius_I = 1.0  # radius of particle\n\ncharge = sphere(pos=vec(-L/2,0,0), radius=size, color=color.red, make_trail=True)\ncharge.v = vec(0.5*L,0,0)  # initial velocity of particle\ncharge.q = q  # charge of particle\n\np1 = box(pos=vec(0, d/2, 0), size=vec(L,0.01,L), color=color.yellow)  # top plate\np2 = box(pos=vec(0,-d/2, 0), size=vec(L,0.01,L), color=color.blue)  # bottom plate\nb1 = box(pos=vec(L/2, d/4 + size, 0), size=vec(0.01*L, 0.5*d, L), color=color.gray(0.7))  # top baffle\nb2 = box(pos=vec(L/2, -d/4 - size, 0), size=vec(0.01*L, 0.5*d, L), color=color.gray(0.7))  # bottom baffle\n\nwhile (charge.pos.x + size + b1.length/2 < L/2 and abs(charge.pos.y) < d/2 - p1.height - size) or \\\n      (L/2 < charge.pos.x + size + b1.length/2 < L and abs(charge.pos.y) < 0.1*size):\n    charge.v += charge.q/m*vec(0,-V/d,0)*dt+charge.q/m*cross(charge.v, vec(0,0,B))*dt\n    charge.pos += charge.v*dt",
      "mode": "initial",
      "timestamp": "2024-07-24 07:27:44",
      "serial_number": 1
    }
  ]
}