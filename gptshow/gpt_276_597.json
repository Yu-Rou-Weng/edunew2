{
  "session_id": 597,
  "log": [
    {
      "input": "# Vertical Circular Motion\n\n## Theoretical Analysis\n\nTo simplify the calculation process, I set the center of the circle at the origin, with the ball starting from $(0, R, 0)$ with an initial velocity of $(-v_0, 0, 0)$. The acceleration can be divided into normal acceleration $a_n$, also known as centripetal acceleration $a_c$, and tangential acceleration $a_t$ that changes the magnitude of the velocity. The calculation of $a_n$ is the same as in Program 7-1 and will not be repeated here. $a_t$ originates from the tangential component of gravitational acceleration, assuming the angle between the ball and the vertical line is $\\theta$, then $$a_t = g \\sin{\\theta}$$\n\nThe y-component of $a_t$ is downward, with a magnitude of $$a_{t,y} = a_t \\sin{\\theta} = g \\sin^2{\\theta}$$\n\nThe x-component of $a_t$ depends on position, pointing right in the first and third quadrants, and left in the second and fourth quadrants, with a magnitude of\n$$\na_{t,x} = a_t \\cos{\\theta} = g \\sin{\\theta} \\cos{\\theta}\n$$\n\nIf only the period is sought, it can be calculated using conservation of mechanical energy. Assuming the velocity magnitude at the highest point is\n$$\nv_0 = \\sqrt{ngR}\n$$\n\nThe relationship between any point and the highest point can be expressed by conservation of energy [9]\n$$\n\\frac{1}{2} m v^2 + m g R \\cos{\\theta} = \\frac{1}{2} m n^2 g R + m g R\n$$\n$$\nv = R \\frac{d\\theta}{dt} = \\sqrt{(n^2 + 2 - 2 \\cos{\\theta}) g R}\n$$\n$$\nT = \\int_0^T dt = 2 \\frac{R}{g} \\int_0^\\pi \\frac{d\\theta}{\\sqrt{n^2 + 2 - 2 \\cos{\\theta}}}\n$$\n\n## Parameter Settings\n\nThe variables defined here include size, R, g, v0, ratio, i, t, dt, and their purposes are already written in the comments of each line. To reduce errors caused by long input times, dt is adjusted to 0.0001.\n\n## Screen Settings\n\nThe ball moves on the xy plane, starting from the top of the screen at distance R, with initial velocity directed towards the -x axis, and magnitude v0. There is no need to adjust the observer's position and direction.\nThe axis is rotated to point in the +z axis direction.\narrow_v and arrow_a are arrows representing the ball's velocity and acceleration.\n\n## Custom Functions\n\nThe custom function findan, whose parameters are v and pos, both in vector format, is used to calculate the ball's normal acceleration $a_n$.\nThe custom function findat, whose parameters are pos, in vector format, is used to calculate the ball's tangential acceleration $a_t$. First, calculate $\\sin{\\theta}$ and $\\cos{\\theta}$; since $\\theta$ only takes acute angles, both are positive. Then calculate $a_{t,y}$ and $a_{t,x}$, and determine the sign of $a_{t,x}$ based on pos.\n\n## Object Motion\n\nThe condition for the ball to return to the starting point is: the ball's original position xp is in the +x area, and the current position xc is in the -x area. If it returns to the starting point, print the elapsed time t, increment i by 1, and stop the animation after the ball returns 5 times.\nSince dt is small, the number of calculations per second is increased to 5000 to speed up the animation.\nUse custom functions findan and findat to calculate the ball's normal and tangential accelerations.\nUpdate the ball's velocity and position, update the starting point, direction, and length of the arrows, and update the time.\n\n## Data Handling\n\nIf the ball's velocity at the highest point is\n$$\nv_0 = n \\sqrt{gR}\n$$\nsubstitute n from 1 to 7, and find the period from both simulation and theoretical calculations, as shown below:\n\nn | v0 | T_theoretical | T_simulation\n---|----|----------------|--------------\n1 | 7 | 2.8841511713977500 | 2.8838000000016613\n2 | 14 | 1.8728982530658000 | 1.8728999999998102\n3 | 21 | 1.3617223964215400 | 1.3617999999999999\n4 | 28 | 1.0602946238731300 | 1.0602999999998997\n5 | 35 | 0.8646052540953560 | 0.8645999999999211\n6 | 42 | 0.7284267507699600 | 0.7283999999999361\n7 | 49 | 0.6286255969937600 | 0.6285999999999471\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=0.5\n\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\nscene = canvas(width = 600, height = 600, range = 0.8, align = 'left')\n\n# create objects\nball = sphere(pos = vec(0, 0.5, 0), radius = 0.02, color = color.red)\nball.v = vec(-3.5, 0, 0)\npole = cylinder(pos = vec(0, 0, 0), axis = vec(0, 0.5, 0), radius = 0.01)\narrow_v = arrow(pos = ball.pos, axis = ball.v, shaftwidth = 0.01, color = color.green)\narrow_a = arrow(pos = ball.pos, axis = vec(0, 0, 0), shaftwidth = 0.01, color = color.blue)\n\n# define the function to calculate the normal acceleration\ndef findan(v, pos):\n    return mag(v)**2/mag(pos)*norm(pos)\n\n# define the function to calculate the tangential acceleration\ndef findat(pos):\n    sin_theta = pos.y/mag(pos)\n    cos_theta = pos.x/mag(pos)\n    a_t_y = 9.8*sin_theta**2\n    if cos_theta > 0:\n        a_t_x = -9.8*sin_theta*abs(cos_theta)\n    else:\n        a_t_x = 9.8*sin_theta*abs(cos_theta)\n    return vec(a_t_x, -a_t_y, 0)\n\n# initial conditions\nxp = ball.pos.x\nt = 0\ndt = 0.0001\ni = 0\n\n# motion\nwhile i < 5:\n    rate(5000)\n    ball.a = findan(ball.v, ball.pos) + findat(ball.pos)\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    arrow_v.pos = ball.pos\n    arrow_v.axis = ball.v/5\n    arrow_a.pos = ball.pos\n    arrow_a.axis = ball.a/10\n    t += dt\n    xc = ball.pos.x\n    if xp > 0 and xc < 0:\n        i += 1\n        if i == 5:\n            print(t)\n    xp = xc",
      "mode": "initial",
      "timestamp": "2024-07-24 02:51:12",
      "serial_number": 1
    }
  ]
}