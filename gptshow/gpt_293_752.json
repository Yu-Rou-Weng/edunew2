{
  "session_id": 752,
  "log": [
    {
      "input": "Please write a Vpython program for \"Free Fall Three Ball Collision.\"\n\nOne-dimensional Elastic Collision Velocity Formula:\n\nAssuming two particles have masses \\( m_1 \\) and \\( m_2 \\), and their velocities before the collision are \\( v_1 \\) and \\( v_2 \\) respectively. The velocities after the collision will be \\( v_1' \\) and \\( v_2' \\), which can be described by:\n\n\\[ v_1' = \\frac{m_1 - m_2}{m_1 + m_2} v_1 + \\frac{2m_2}{m_1 + m_2} v_2 \\]\n\n\\[ v_2' = \\frac{2m_1}{m_1 + m_2} v_1 + \\frac{m_2 - m_1}{m_1 + m_2} v_2 \\]\n\nWhere:\n- \\( v_1' \\) is the velocity of the object with mass \\( m_1 \\) after the collision\n- \\( v_2' \\) is the velocity of the object with mass \\( m_2 \\) after the collision\n- \\( v_1 \\) is the velocity of the object with mass \\( m_1 \\) before the collision\n- \\( v_2 \\) is the velocity of the object with mass \\( m_2 \\) before the collision\n\nThere are three balls, one is red, one is green, and another is blue. Please draw a floor with a side length of 50. The red ball has a mass of 3 and a radius of 3, the green ball has a mass of 2 and a radius of 2, and the blue ball has a mass of 1 and a radius of 1. The three balls are stacked vertically. The green ball is stacked on top of the red ball, and the blue ball is stacked on top of the green ball. Release the three stacked balls from a height of 15 above the floor. The balls start accelerating downward due to gravity, and the red ball bounces upon hitting the floor. After the red ball bounces twice, the green ball on top will also bounce. Next, the green ball collides with the blue ball. The three balls adhere to one-dimensional elastic collisions. The bounce range of the green ball after colliding with the red ball is only between the red and blue balls, and the blue ball's bounce range after colliding with the green ball is only above the green ball. If the red ball hits the ground, it will bounce back. If the red ball and green ball collide, the masses of the red ball, the green ball, and their velocities in the y-direction are substituted into the one-dimensional elastic collision formula to calculate the post-collision velocities, which are then reassigned to the red ball and green ball in the y-direction. If the green ball and the blue ball collide, the mass of the green ball, the velocity of the green ball in the y-direction, the mass of the blue ball, and the velocity of the blue ball in the y-direction are substituted into the one-dimensional elastic collision formula to calculate the post-collision velocities, which are then reassigned to the green ball and blue ball in the y-direction. Because the balls below (red and green) are heavier than the blue ball, the rebound height of the blue ball will far exceed its original height above the ground.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\ng = 9.8\nmass = [3, 2, 1]\nRadius = 3\nRadius_I = 1\nheight = [15, 15+2*Radius, 15+4*Radius]\nv = [0, 0, 0]\ndt = 0.001\n\n# Objects\nball = [sphere(radius = Radius*Radius_I, color = color.red, pos = vec(0, height[0], 0), v = vec(0, v[0], 0)), \n        sphere(radius = Radius*Radius_I, color = color.green, pos = vec(0, height[1], 0), v = vec(0, v[1], 0)), \n        sphere(radius = Radius*Radius_I, color = color.blue, pos = vec(0, height[2], 0), v = vec(0, v[2], 0))]\n\nfloor = box(pos = vec(0, 0, 0), size = vec(50, 0.01, 50))\n\n# Function for collision\ndef collision(b1, b2):\n    v1prime = b1.v.y*(mass[b1] - mass[b2])/(mass[b1] + mass[b2]) + b2.v.y*2*mass[b2]/(mass[b1] + mass[b2])\n    v2prime = b1.v.y*2*mass[b1]/(mass[b1] + mass[b2]) + b2.v.y*(mass[b2] - mass[b1])/(mass[b1] + mass[b2])\n    return v1prime, v2prime\n\n# Animation\nwhile True:\n    rate(1000)\n    for i in range(3):\n        ball[i].pos = ball[i].pos + ball[i].v*dt\n        ball[i].v.y = ball[i].v.y - g*dt\n    # Collision with floor\n    if ball[0].pos.y - Radius*Radius_I <= 0:\n        ball[0].v.y = abs(ball[0].v.y)\n    # Collision between balls\n    if abs(ball[0].pos.y - ball[1].pos.y) <= 2*Radius*Radius_I and ball[0].v.y < ball[1].v.y:\n        v1, v2 = collision(0, 1)\n        ball[0].v.y = v1\n        ball[1].v.y = v2\n    if abs(ball[1].pos.y - ball[2].pos.y) <= 2*Radius*Radius_I and ball[1].v.y < ball[2].v.y:\n        v1, v2 = collision(1, 2)\n        ball[1].v.y = v1\n        ball[2].v.y = v2",
      "mode": "initial",
      "timestamp": "2024-07-25 18:47:41",
      "serial_number": 1
    }
  ]
}