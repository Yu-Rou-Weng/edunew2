{
  "session_id": 725,
  "log": [
    {
      "input": "Magnetic Field Generated by a Current-Carrying Coil\n\nIn Chapter 8 of Elective Physics on the magnetic effects of currents, the Biot-Savart Law is introduced. This law calculates the magnetic field produced by a small segment of current-carrying wire at a point in space. The equation is:\n$$\nd\\vec{B} = \\frac{\\mu_0}{4\\pi} \\frac{I d\\vec{L} \\times \\hat{r}}{r^2} \\Rightarrow dB = \\frac{\\mu_0}{4\\pi} \\frac{I dL \\sin{\\theta}}{r^2}\n$$\n\nUsing the Biot-Savart Law, we can calculate the magnetic field magnitude at a perpendicular distance $r$ from a long straight current-carrying wire as:\n$$\nB = \\frac{\\mu_0 I}{2\\pi r}\n$$\n\nThe magnetic field magnitude at the center of a current-carrying loop with radius $r$ is:\n$$\nB = \\frac{\\mu_0 I}{2r}\n$$\n\nThe magnetic field magnitude at the center of a solenoid with $n$ turns per unit length carrying a current is:\n$$\nB = \\mu_0 n I\n$$\n\nMagnetic fields are distributed in space, but the diagrams in the books are all flat. Therefore, I want to use VPython to visualize the strength and direction of the magnetic fields in space.\n\nProgramming Section\nThe program for generating the magnetic field from a current-carrying loop is very similar to that for a long straight current-carrying wire. Below are the differences:\n\nHere, variables such as size, r, n, part, d, mu, current, direct, L, N, and Bmax are set. Since the magnetic field values vary significantly, Bmax is set directly instead of being derived from the calculated values.\n\nA ring object is used to create the coil.\n\nAfter dividing the ring, small spheres are placed starting from (r, 0, 0). If looking from the +y axis towards the origin, the placement direction is counterclockwise, hence the position is set as:\n\n(r*cos(i*2*pi*part/n), 0, -*sin(i*2*pi*part/n))\n\nIn the custom function, if the current direction is counterclockwise, i.e., direct = True, then dr is set as:\n\nnorm(vec(segment.pos.z, 0, -segment.pos.x))\n\nOtherwise, it is set as:\n\nnorm(vec(-segment.pos.z, 0, segment.pos.x))\n\nIllustration to be drawn:\n![image](https://hackmd.io/_uploads/Bk156hadC.png)\n(1) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# constants\nmu = 4*pi*1E-7\nI = 1E-2\ndirect = True\nN = 500\nsize = 0.01\nr = 0.3\npart = 50\nd = r/10\nBmax = 1E-4\n\n# ring\nring(pos=vector(0,0,0), radius=r, thickness=d/5, color=color.red)\n\n# segments and arrows\nsegments = []\nB_arrows = []\nfor i in range(part):\n    theta = i*2*pi/part\n    if direct:\n        segments.append(sphere(pos=vector(r*cos(theta), 0, -r*sin(theta)), radius=size, color=color.red))\n    else:\n        segments.append(sphere(pos=vector(r*cos(theta), 0, r*sin(theta)), radius=size, color=color.red))\n    B_arrows.append(arrow(pos=segments[i].pos, axis=vector(0,0,0), color=color.cyan))\n\n# calculate B field\ndef B_field(segment, observation_location):\n    dB = mu/4/pi*I*cross(direct*norm(vector(segment.pos.z, 0, -segment.pos.x)),-(observation_location-segment.pos))/mag2(observation_location-segment.pos)\n    return(dB)\n\n# observation locations\nfor x in range(-N,N+1):\n    for z in range(-N,N+1):\n        location = vector(x, 0, z)*2*r/N\n        B = vector(0, 0, 0)\n        for i in range(part):\n            B = B + B_field(segments[i], location)\n        if mag(B) > Bmax:\n            B = B * Bmax / mag(B)\n        if (x%10 == 0) and (z%10 == 0):\n            arrow(pos=location, axis=B*1E4, color=B_arrow_color(B))",
      "mode": "initial",
      "timestamp": "2024-07-24 14:12:46",
      "serial_number": 1
    }
  ]
}