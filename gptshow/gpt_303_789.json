{
  "session_id": 789,
  "log": [
    {
      "input": "**Velocity Selector with an Outlet Baffle**\n\n# Velocity Selector\n\nA velocity selector is a device used to filter charged particles with specific velocities. Its basic structure is shown in the diagram below. Two parallel charged plates create a downward electric field, combined with a magnetic field perpendicular to the plane of the paper. If a positively charged particle enters the velocity selector from the left with a horizontal velocity \\( v \\), the particle will experience a downward electrostatic force and an upward magnetic force. When the net force is zero, the particle moves at a constant speed, where\n$$\nqE = qvB \\Rightarrow v = \\frac{E}{B} = \\frac{V}{Bd}\n$$\n\nBy placing a baffle with only a small hole on the right side, only particles moving straight to the right can pass through. Thus, the velocity of the particles passing through the device can be controlled by changing the values of the electric and magnetic fields. Below are two programs:\n\n- Program 20-1: Draw the electric field, magnetic field, parallel charged plates, and particle trajectories. The particle stops moving when it hits the parallel charged plates.\n- Program 20-2: Based on 20-1, add a baffle at the outlet.\nThe velocity selector is used to filter charged particles with specific velocities. Its basic construction is shown in the diagram below. Two parallel charged plates create a downward electric field, combined with a magnetic field perpendicular to the plane of the paper. If a positively charged particle enters the velocity selector from the left with a horizontal velocity \\( v \\), the particle will experience a downward electrostatic force and an upward magnetic force. When the net force is zero, the particle moves at a constant speed, where\n$$\nqE = qvB \\Rightarrow v = \\frac{E}{B} = \\frac{V}{Bd}\n$$\n\nBy placing a baffle with only a small hole on the right side, only particles moving straight to the right can pass through. Thus, the velocity of the particles passing through the device can be controlled by changing the values of the electric and magnetic fields. Below are two programs:\n\n- Program 20-1: Draw the electric field, magnetic field, parallel charged plates, and particle trajectories. The particle stops moving when it hits the parallel charged plates.\n- Program 20-2: Based on 20-1, add a baffle at the outlet.\n\nProgram to be written: 20-1: Draw the electric field, magnetic field, parallel charged plates, and particle trajectories. The particle stops moving when it hits the parallel charged plates.\n\n## Velocity Selector Construction Diagram:\n![image](https://hackmd.io/_uploads/HJlvr2auR.png)\n\n## Parameter Settings\n\nVariables such as size, m, v0, q, V, d, L, B, E_field, B_field, t, dt are set here; their purposes are noted in the comments. To ensure smoother animation, the particle's mass is set much larger than the actual mass of a nucleus.\n\n## Display Settings\n\nGenerate an animation window, parallel charged plates, a horizontal line, and a charged particle.\n\nGenerate arrows representing velocity and acceleration.\n\nGenerate arrows and labels for the electric field and magnetic field. The syntax for labels is:\n\n[label_name] = label(pos=[position vector], text=\"[label content]\", xoffset=[x-direction offset], yoffset=[y-direction offset], color=[color name or RGB value], font=\"[font name]\")\nReplace the contents in [] with your required parameters.\n\nOpen the graphical window and plot the position, velocity, acceleration, and time relationship of the small ball.\n\nObject Motion\nTo stop the animation when the charged particle reaches the right side of the screen or hits the parallel charged plates, set the condition in the while loop to charge.pos.x < L and abs(charge.pos.y) < d/2 - p1.height - size.\n\nCalculate the net force on the charged particle. Since the electric and magnetic fields exist only between the parallel charged plates, set them to zero outside. The mathematical formula for the net force on the charged particle is\n\n$$\n\\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B})\n$$\nThe corresponding code is:\n\nF = q*(E_field + cross(charge.v, B_field))\nUpdate the charged particle's acceleration, velocity, and position.\n\nUpdate the arrows representing velocity and acceleration, only displaying direction to avoid automatic resizing of the animation.\n\nUpdate the time.\n\n## Program Design\n\nOnly three changes were made:\n\nAdd a baffle at the outlet\n\nb1 = box(pos=vec(L/2, d/4 + size, 0), size=vec(0.01*L, 0.5*d, L), color = color.gray(0.7))\nb2 = box(pos=vec(L/2, -d/4 - size, 0), size=vec(0.01*L, 0.5*d, L), color = color.gray(0.7))\nModify the operation condition of the while loop to:\n\n(charge.pos.x + size + b1.length/2 < L/2 and abs(charge.pos.y) < d/2 - p1.height - size) or \\\n(L/2 < charge.pos.x + size + b1.length/2 < L and abs(charge.pos.y) < 0.1*size)\n(a) The effect of the first part: The animation continues as long as the particle is between the parallel charged plates and has not collided with them.\n(b) The effect of the second part: The animation continues as long as the particle has not reached the edge of the screen and has not collided with the baffle.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Constants\nm, v0, q, V, d, L, B = 1e-5, 100, 1, 100, 0.1, 1, 1\nsize = 0.01\nE_field, B_field = vec(0, -V/d, 0), vec(0, 0, -B)\n\n# Scene settings\nscene = canvas(title='Velocity Selector', width=800, height=800, center=vec(L/2, 0, 0), background=vec(0.5, 0.5, 0))\n\n# Charged particle\ncharge = sphere(pos=vec(0, 0, 0), radius=size, color=color.cyan, m=m, v=vec(v0, 0, 0), a=vec(0, 0, 0))\n\n# Plates\np1 = box(pos=vec(L/2, -d/4, 0), size=vec(L, 0.01*d, L), color = color.gray(0.7))\np2 = box(pos=vec(L/2, d/4, 0), size=vec(L, 0.01*d, L), color = color.gray(0.7))\n\n# Baffle\nb1 = box(pos=vec(L/2, d/4 + size, 0), size=vec(0.01*L, 0.5*d, L), color = color.gray(0.7))\nb2 = box(pos=vec(L/2, -d/4 - size, 0), size=vec(0.01*L, 0.5*d, L), color = color.gray(0.7))\n\n# Electric and magnetic field arrows\nE_arrow = arrow(pos=vec(L/2, -d/2, 0), axis=1.5*E_field, color=color.red)\nB_arrow = arrow(pos=vec(L/2, d/2, 0), axis=1.5*B_field, color=color.blue)\n\n# Labels\nE_label = label(pos=E_arrow.pos, text='E', xoffset=20, yoffset=-25, color=E_arrow.color, font='sans')\nB_label = label(pos=B_arrow.pos, text='B', xoffset=20, yoffset=-25, color=B_arrow.color, font='sans')\n\n# Velocity and acceleration arrows\nv_arrow = arrow(pos=charge.pos, axis=charge.v, color=color.green)\na_arrow = arrow(pos=charge.pos, axis=charge.a, color=color.yellow)\n\n# Time settings\nt, dt = 0, 0.001\n\nwhile (charge.pos.x + size + b1.length/2 < L/2 and abs(charge.pos.y) < d/2 - p1.height - size) or \\\n      (L/2 < charge.pos.x + size + b1.length/2 < L and abs(charge.pos.y) < 0.1*size):\n\n    rate(1000)\n\n    if 0 < charge.pos.x < L and abs(charge.pos.y) < d/2 - p1.height - size:\n        E_field = vec(0, -V/d, 0)\n        B_field = vec(0, 0, -B)\n    else:\n        E_field = vec(0, 0, 0)\n        B_field = vec(0, 0, 0)\n\n    F = q*(E_field + cross(charge.v, B_field))\n    charge.a = F/charge.m\n    charge.v += charge.a*dt\n    charge.pos += charge.v*dt\n\n    v_arrow.pos = charge.pos\n    v_arrow.axis = 0.03*charge.v\n    a_arrow.pos = charge.pos\n    a_arrow.axis = 0.1*charge.a\n\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-25 22:05:06",
      "serial_number": 1
    }
  ]
}