{
  "session_id": 717,
  "log": [
    {
      "input": "Two Balls Colliding in Free Fall\n\nIf two highly elastic balls are stacked vertically with the larger mass ball at the bottom and released from a certain height, both balls will start accelerating downwards due to gravity. What happens when the bottom ball hits the ground and bounces back? There are many experimental videos available on YouTube, such as \"Stacked Ball Drop\". We can use the previously written simulation programs for \"Free Fall\" and \"One-Dimensional Elastic Collision\" to address this issue.\n\nScreenshot of the program for the collision of two balls in free fall: ![image](https://hackmd.io/_uploads/SyOtLjT_C.png)\n\nThe program for the collision of two balls in free fall involves two balls.\n\nParameter Settings\n\nIn this setting, variables are set for the radius, mass, and color of the ball, the height of the ball above the ground, the length of the floor, gravitational acceleration, time, and time interval. Please refer to the program code for the corresponding variable names.\n\nDisplay Settings\nThe code for generating the animation window, floor, balls, and drawing window has appeared many times in previous animations and will not be repeated here. A special feature is the addition of an option range=L in the animation window to limit the display range and prevent the window from automatically shrinking due to the upper ball bouncing too high.\n\nObject Motion\nUpdate the velocity and position of the balls.\nIf b1.pos.y <= 0, it means b1 has hit the floor, and its velocity is reversed to bounce.\nIf b2.pos.y - b1.pos.y <= r1 + r2, it means b1 and b2 have collided. The masses m1, b1.v.y, m2, and b2.v.y are entered into a custom function af_col_v to calculate the velocity after collision, which is then reassigned to b1.v.y and b2.v.y.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1\n(2) Radius_I is the radius of the ball. When Radius_I changes to a new value, the radius of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# ball parameters\nm1 = 1\nr1 = 1\nm2 = 0.2\nr2 = 0.5\nRadius_I = 1\n\n# initial conditions\nh = 5\nv1 = 0\nv2 = 0\n\n# animation window and objects\nscene = canvas(width=400, height=400, center=vector(0, h / 2, 0), background=vector(0.5, 0.5, 0))\nfloor = box(length=30, height=0.01, width=10, color=color.blue)\nb1 = sphere(pos=vector(0, h, 0), radius=Radius_I, color=color.red)\nb2 = sphere(pos=vector(0, h + r1 + r2, 0), radius=r2, color=color.green)\n\n# physics constants and time variables\ng = 9.8\nt = 0\ndt = 0.001\n\ndef af_col_v(m1, v1, m2, v2):  # function to calculate velocities after collision\n    v1f = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n    v2f = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    return v1f, v2f\n\nwhile True:\n    rate(1000)\n\n    # update velocities and positions\n    v1 = v1 - g * dt\n    v2 = v2 - g * dt\n    b1.pos.y = b1.pos.y + v1 * dt\n    b2.pos.y = b2.pos.y + v2 * dt\n\n    # collision with floor\n    if b1.pos.y <= Radius_I:\n        v1 = -v1\n\n    # collision between balls\n    if b2.pos.y - b1.pos.y <= r1 + r2:\n        v1, v2 = af_col_v(m1, v1, m2, v2)\n\n    t = t + dt",
      "mode": "initial",
      "timestamp": "2024-07-24 13:35:40",
      "serial_number": 1
    }
  ]
}