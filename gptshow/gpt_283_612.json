{
  "session_id": 612,
  "log": [
    {
      "input": "# Planetary Motion\n\nProgram to be written: Planetary motion, customizing planetary speed and distance, possibility to modify the power of \\( r \\) in the law of universal gravitation.\n\nKepler's laws of planetary motion consist of the following three laws:\n\n1. **First Law (Orbital Law)**: The stable orbits of all planets revolving around the Sun are elliptical, with the Sun at one of the foci.\n\n2. **Second Law (Equal Area Speed Law)**: The area swept by the line connecting a planet and the Sun in a unit of time is constant. If the distance between the Sun and the planet is \\( r \\), the planet's speed is \\( v \\), and the angle between \\( r \\) and \\( v \\) is \\( \\theta \\), then the area swept by the line connecting the planet and the Sun in a unit of time is\n$$\n\\frac{\\Delta A}{\\Delta t} = \\frac{1}{2} rv \\sin{\\theta} = \\text{constant}\n$$\n\n3. **Third Law (Period Law)**: For all planets revolving around the Sun, the relationship between the orbital period \\( T \\) and the average orbital radius \\( a \\) is\n$$\n\\frac{a^3}{T^2} = \\text{constant}\n$$\n\nWe know that the first law is due to only gravitational forces acting between the Sun and the stars, and according to the law of universal gravitation, it can be proven that only ellipses are stable orbits. The second law is because the gravitational force passes through the Sun, so the angular momentum of the planet relative to the Sun is conserved, hence the area swept by the line connecting the planet and the Sun in a unit of time is equal. The third law can be derived using the law of universal gravitation as the centripetal force. If combined with real data from the solar system, these three laws could be visually demonstrated.\n\n## Parameter Settings\n\nVariables are set as G, size, sun_m, d, v0, theta, n, t, dt, with their purposes annotated in the comments. Here, E represents multiples of 10, for example, 1E3 = 1000, and can be replaced with e. Since I aim to use real data as much as possible, but when using real distances, the radii of the planets must be enlarged, otherwise, the planets will not be visible.\n\n## Display Settings\n\nWhen generating the Sun, the last option is `emissive=True`, which by default is set to False. If set to True, the Sun will emit light.\n\nWhen generating Earth, set the material `texture=textures.earth` because VPython has a built-in texture of Earth, eliminating the need to find a picture. However, since the Earth object does not have a set color, the trail color defaults to white. To change it to blue, add `trail_color=color.blue`. To change the trail radius to `0.1*size`, add `trail_radius=0.1 * size`.\n\nTo make the Sun emit light, in the older versions of VPython, it was written as\n\nscene.lights = [local_light(pos=vec(0, 0, 0), color=color.white)]\nHowever, VPython 7 no longer supports this syntax, and instead, a light source is placed at the position of the Sun:\n\nlamp = local_light(pos=vec(0,0,0), color=color.white)\nGenerate arrows representing velocity and acceleration.\n\nOpen the graphics window, drawing the distance between the planet and the Sun, the planet's speed, acceleration, and the relationship with time.\n\n## Object Motion\nCalculate the planet's acceleration:\n\nplanet.a = - G*sun.m / planet.pos.mag**n * planet.pos.norm()\nTo change the power of distance in the law of universal gravitation, do not use planet.pos.mag2 to calculate the square of the distance between the planet and the Sun, instead use planet.pos.mag**n to calculate the nth power of the distance. Then update the planet's speed and position.\n\nUpdate the position, direction, and length of the arrows representing velocity and acceleration. Due to the large distance between the planet and the Sun, the arrows need to be enlarged to be visible.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Radius_I as a cyber input variable, set Radius_I=1E10\n\n(2) Radius_I is the radius of the planet. When Radius_I changes to a new value, the radius of the planet also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math, sympy, scipy and time.",
      "output": "from vpython import *\n\n# Parameter Settings\nG = 6.67430E-11  # gravitational constant\nsize = 1E10  # scale size\nsun_m = 1.989E30  # mass of the Sun\nd = Radius_I  # distance between the Sun and the planet\nv0 = 2 * pi * d / (1 * 365 * 24 * 60 * 60)  # initial velocity of the planet\ntheta = pi / 2  # angle between r and v\nn = 2  # power of r in the law of universal gravitation\nt = 0  # time\ndt = 60 * 60 * 24  # time step\n\n# Display Settings\nscene = canvas(width=800, height=800, background=vec(0, 0, 0))  # create a scene\nsun = sphere(pos=vec(0, 0, 0), radius=size, color=color.red, emissive=True)  # create the Sun\nsun.m = sun_m  # set the mass of the Sun\nplanet = sphere(pos=vec(d, 0, 0), radius=0.1 * size, texture=textures.earth, make_trail=True,\n                trail_type='points', trail_color=color.blue, trail_radius=0.1 * size)  # create the planet\nplanet.v = vec(0, v0, 0)  # set the initial velocity of the planet\nplanet.m = 5.965E24  # set the mass of the planet\nplanet.a = vec(0, 0, 0)  # set the initial acceleration of the planet\nv_arrow = arrow(pos=planet.pos, axis=planet.v, shaftwidth=0.05 * size, color=color.green)  # create a velocity arrow\na_arrow = arrow(pos=planet.pos, axis=planet.a, shaftwidth=0.05 * size, color=color.yellow)  # create an acceleration arrow\nlamp = local_light(pos=vec(0, 0, 0), color=color.white)  # create a light source\n\n# Object Motion\nwhile True:\n    rate(365)  # set the animation speed\n    planet.a = - G * sun.m / planet.pos.mag ** n * planet.pos.norm()  # calculate the acceleration of the planet\n    planet.v += planet.a * dt  # update the velocity of the planet\n    planet.pos += planet.v * dt  # update the position of the planet\n    v_arrow.pos = planet.pos  # update the position of the velocity arrow\n    v_arrow.axis = planet.v * size / v0  # update the direction and length of the velocity arrow\n    a_arrow.pos = planet.pos  # update the position of the acceleration arrow\n    a_arrow.axis = planet.a * size  # update the direction and length of the acceleration arrow\n    t += dt  # update time",
      "mode": "initial",
      "timestamp": "2024-07-24 03:50:48",
      "serial_number": 1
    },
    {
      "input": "Please update the program by fixing the following error:\nRadius_I is not defined\n\nHere's the current program:\nfrom vpython import *\n\n# Parameter Settings\nG = 6.67428E-11\nsize = 1E10\nsun_m = 1.989E30\nd = 1 #semi-major axis\nv0 = 2 * pi * d / (60*60*24*365.25) * 1E6\ntheta = pi / 4\nn = 2\nt = 0\ndt = 10000\nRadius_I = 1E10\n\n# Screen Settings\nscene = canvas(width=800, height=800, background=vec(0.5, 0.5, 0))\nscene.range = 3E11\nscene.forward = vec(0, -1, -1)\nsun = sphere(pos=vec(0, 0, 0), radius=1E10, color=color.red, emissive=True)\nplanet = sphere(pos=vec(d, 0, 0), radius=Radius_I, color=color.blue, make_trail=True, trail_color=color.blue, trail_radius=0.1 * size, texture=textures.earth)\nplanet.v = vec(0, v0, 0)\nplanet.a = vec(0, 0, 0)\nv_vector = arrow(pos=planet.pos, axis=planet.v, shaft_width=0.05*size, color=color.green)\na_vector = arrow(pos=planet.pos, axis=planet.a, shaft_width=0.05*size, color=color.yellow)\nlamp = local_light(pos=vec(0,0,0), color=color.white)\n\n# Object Motion\nwhile True:\n    rate(1000)\n    planet.a = - G*sun_m / planet.pos.mag**n * planet.pos.norm()\n    planet.v += planet.a * dt\n    planet.pos += planet.v * dt\n    v_vector.pos = planet.pos\n    v_vector.axis = planet.v * size / v0\n    a_vector.pos = planet.pos\n    a_vector.axis = planet.a * size / v0\n    t += dt",
      "output": "from vpython import *\n\n# Parameter Settings\nG = 6.67428E-11\nsize = 1E10\nsun_m = 1.989E30\nd = 1E10  #semi-major axis\nv0 = 2 * pi * d / (60*60*24*365.25) * 1E6\ntheta = pi / 4\nn = 2\nt = 0\ndt = 10000\nRadius_I = 1E10\n\n# Screen Settings\nscene = canvas(width=800, height=800, background=vec(0.5, 0.5, 0))\nscene.range = 3E11\nscene.forward = vec(0, -1, -1)\nsun = sphere(pos=vec(0, 0, 0), radius=1E10, color=color.red, emissive=True)\nplanet = sphere(pos=vec(d, 0, 0), radius=Radius_I, color=color.blue, make_trail=True, trail_color=color.blue, trail_radius=0.1 * size, texture=textures.earth)\nplanet.v = vec(0, v0, 0)\nplanet.a = vec(0, 0, 0)\nv_vector = arrow(pos=planet.pos, axis=planet.v, shaft_width=0.05*size, color=color.green)\na_vector = arrow(pos=planet.pos, axis=planet.a, shaft_width=0.05*size, color=color.yellow)\nlamp = local_light(pos=vec(0,0,0), color=color.white)\n\n# Object Motion\nwhile True:\n    rate(1000)\n    planet.a = - G*sun_m / planet.pos.mag**n * planet.pos.norm()\n    planet.v += planet.a * dt\n    planet.pos += planet.v * dt\n    v_vector.pos = planet.pos\n    v_vector.axis = planet.v * size / v0\n    a_vector.pos = planet.pos\n    a_vector.axis = planet.a * size / v0\n    t += dt",
      "mode": "fix_error",
      "timestamp": "2024-07-24 03:51:08",
      "serial_number": 2
    },
    {
      "input": "Please update the program by fixing the following error:\nRadius_I is not defined\n\nHere's the current program:\nfrom vpython import *\n\n# Parameter Settings\nG = 6.67430E-11  # gravitational constant\nsize = 1E10  # scale size\nsun_m = 1.989E30  # mass of the Sun\nd = Radius_I  # distance between the Sun and the planet\nv0 = 2 * pi * d / (1 * 365 * 24 * 60 * 60)  # initial velocity of the planet\ntheta = pi / 2  # angle between r and v\nn = 2  # power of r in the law of universal gravitation\nt = 0  # time\ndt = 60 * 60 * 24  # time step\n\n# Display Settings\nscene = canvas(width=800, height=800, background=vec(0, 0, 0))  # create a scene\nsun = sphere(pos=vec(0, 0, 0), radius=size, color=color.red, emissive=True)  # create the Sun\nsun.m = sun_m  # set the mass of the Sun\nplanet = sphere(pos=vec(d, 0, 0), radius=0.1 * size, texture=textures.earth, make_trail=True,\n                trail_type='points', trail_color=color.blue, trail_radius=0.1 * size)  # create the planet\nplanet.v = vec(0, v0, 0)  # set the initial velocity of the planet\nplanet.m = 5.965E24  # set the mass of the planet\nplanet.a = vec(0, 0, 0)  # set the initial acceleration of the planet\nv_arrow = arrow(pos=planet.pos, axis=planet.v, shaftwidth=0.05 * size, color=color.green)  # create a velocity arrow\na_arrow = arrow(pos=planet.pos, axis=planet.a, shaftwidth=0.05 * size, color=color.yellow)  # create an acceleration arrow\nlamp = local_light(pos=vec(0, 0, 0), color=color.white)  # create a light source\n\n# Object Motion\nwhile True:\n    rate(365)  # set the animation speed\n    planet.a = - G * sun.m / planet.pos.mag ** n * planet.pos.norm()  # calculate the acceleration of the planet\n    planet.v += planet.a * dt  # update the velocity of the planet\n    planet.pos += planet.v * dt  # update the position of the planet\n    v_arrow.pos = planet.pos  # update the position of the velocity arrow\n    v_arrow.axis = planet.v * size / v0  # update the direction and length of the velocity arrow\n    a_arrow.pos = planet.pos  # update the position of the acceleration arrow\n    a_arrow.axis = planet.a * size  # update the direction and length of the acceleration arrow\n    t += dt  # update time",
      "output": "from vpython import *\n\n# Parameter Settings\nG = 6.67430E-11  # gravitational constant\nsize = 1E10  # scale size\nsun_m = 1.989E30  # mass of the Sun\nRadius_I = 1.496E11  # distance between the Sun and the Earth\nd = Radius_I  # distance between the Sun and the planet\nv0 = 2 * pi * d / (1 * 365 * 24 * 60 * 60)  # initial velocity of the planet\ntheta = pi / 2  # angle between r and v\nn = 2  # power of r in the law of universal gravitation\nt = 0  # time\ndt = 60 * 60 * 24  # time step\n\n# Display Settings\nscene = canvas(width=800, height=800, background=vec(0, 0, 0))  # create a scene\nsun = sphere(pos=vec(0, 0, 0), radius=size, color=color.red, emissive=True)  # create the Sun\nsun.m = sun_m  # set the mass of the Sun\nplanet = sphere(pos=vec(d, 0, 0), radius=0.1 * size, texture=textures.earth, make_trail=True,\n                trail_type='points', trail_color=color.blue, trail_radius=0.1 * size)  # create the planet\nplanet.v = vec(0, v0, 0)  # set the initial velocity of the planet\nplanet.m = 5.965E24  # set the mass of the planet\nplanet.a = vec(0, 0, 0)  # set the initial acceleration of the planet\nv_arrow = arrow(pos=planet.pos, axis=planet.v, shaftwidth=0.05 * size, color=color.green)  # create a velocity arrow\na_arrow = arrow(pos=planet.pos, axis=planet.a, shaftwidth=0.05 * size, color=color.yellow)  # create an acceleration arrow\nlamp = local_light(pos=vec(0, 0, 0), color=color.white)  # create a light source\n\n# Object Motion\nwhile True:\n    rate(365)  # set the animation speed\n    planet.a = - G * sun.m / planet.pos.mag ** n * planet.pos.norm()  # calculate the acceleration of the planet\n    planet.v += planet.a * dt  # update the velocity of the planet\n    planet.pos += planet.v * dt  # update the position of the planet\n    v_arrow.pos = planet.pos  # update the position of the velocity arrow\n    v_arrow.axis = planet.v * size / v0  # update the direction and length of the velocity arrow\n    a_arrow.pos = planet.pos  # update the position of the acceleration arrow\n    a_arrow.axis = planet.a * size  # update the direction and length of the acceleration arrow\n    t += dt  # update time",
      "mode": "fix_error",
      "timestamp": "2024-07-24 03:51:19",
      "serial_number": 3
    }
  ]
}
