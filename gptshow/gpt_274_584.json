{
  "session_id": 584,
  "log": [
    {
      "input": "## Circular Motion\n\nIf a small ball has a mass $m$, a velocity $v$, an angular velocity $\\omega$, and a turning radius of curvature $R$, then the required centripetal acceleration for turning is\n$$\na_c = \\frac{v^2}{R} = R \\omega^2\n$$\n\nFrom Newton's second law of motion, the centripetal force can be calculated as\n$$\nF_c = m a_c = m \\cdot \\frac{v^2}{R} = m \\cdot R \\omega^2\n$$\n\nIf you want to use VPython to simulate the ball performing uniform circular motion on a horizontal plane, we need to figure out how to calculate the magnitude and direction of the centripetal acceleration, and only simulate the uniform circular motion of the ball.\n\n## Horizontal Plane Circular Motion\n\n### Parameter Settings\n\nVariables defined here include size, v0, R, L, t, dt, and their purposes are already written in the comments of the respective lines.\n\n### Scene Settings\n\nA new feature used here is:\n\nscene.camera.pos = vec(0, L/2, L/2)\nscene.camera.axis = vec(0, -L/2, -L/2)\ncamera.pos is used to set the position of the observer, and camera.axis sets the direction the observer is facing.\n\nThe ball moves on the xz plane, starting from the right side of the screen at a distance R, with the initial velocity directed towards the -z axis, with a magnitude of v0.\n\narrow_v and arrow_a are arrows representing the velocity and acceleration of the ball.\n\n### Object Motion\nUse axis = ball.pos - vec(0, size, 0) to find the position vector of the ball relative to the axis of rotation.\n\nCalculate the ball's centripetal acceleration using ball.a = -(ball.v.mag2 / R) * axis.norm(). Here, mag2 is used to calculate the square of the magnitude of a vector, assuming the vector is named A, with syntax options:\n\nA.mag2 = mag2(A)\nwhere norm() is used to calculate a unit vector, assuming the vector's name is A, with syntax options:\n\nA.norm() = norm(A)\nFinally, update the ball's velocity and position, update the starting position, direction, and length of the arrows, and update the time.\n\n### Supplement: attach_arrow\nVPython provides the attach_arrow feature, which allows arrows to be attached to an object. The arrow's position changes with the object's movement, and its length and direction change according to the object's properties. If using the attach_arrow feature, lines 26 to 28 of the code can be changed to:\n\nball = sphere(pos=vec(R, size, 0), radius=size, color=color.red, make_trail=True, retain=100, v=vec(0, 0, -v0), a=vec(-v0**2/R, 0, 0))\narrow_v = attach_arrow(ball, \"v\", radius=0.2*size, shaftwidth=0.4*size, color=color.green)\narrow_a = attach_arrow(ball, \"a\", radius=0.2*size, shaftwidth=0.4*size, color=color.blue)\nSimultaneously, delete lines 39 to 42 of the code. This achieves the same animation effect without needing to update the arrows in the while loop, making the code more concise.\n\nCyber Input Variable Mapping Information:\n\n(1) Define and initialize a variable named Speed_I as a cyber input variable, set Speed_I=1\n\n(2) Speed_I is the initial velocity of the ball. When Speed_I changes to a new value, the initial velocity of the ball also changes to that value.\n(3) Do not import packages that are not supported by VPython such as numpy, math and time.",
      "output": "from vpython import *\n\n# Parameters\nsize = 0.5  # ball radius\nSpeed_I = 1  # initial velocity\nR = 3  # radius of circular path\nL = 10  # length of scene\nt = 0  # time\ndt = 0.001  # time step\n\n# Scene settings\nscene = canvas(title=\"Circular Motion\", width=800, height=800, center=vec(0, 0, 0), background=vec(0.5, 0.5, 0))\nscene.camera.pos = vec(0, L/2, L/2)\nscene.camera.axis = vec(0, -L/2, -L/2)\n\n# Objects\nball = sphere(pos=vec(R, size, 0), radius=size, color=color.red, make_trail=True, retain=100, v=vec(0, 0, -Speed_I), a=vec(-Speed_I**2/R, 0, 0))\narrow_v = arrow(pos=ball.pos, axis=ball.v, shaftwidth=0.2*size, color=color.green)\narrow_a = arrow(pos=ball.pos, axis=ball.a, shaftwidth=0.2*size, color=color.blue)\n\n# Circular motion\nwhile True:\n    rate(1/dt)\n    axis = ball.pos - vec(0, size, 0)\n    ball.a = -(ball.v.mag2 / R) * axis.norm()\n    ball.v += ball.a*dt\n    ball.pos += ball.v*dt\n    arrow_v.pos = ball.pos\n    arrow_v.axis = ball.v\n    arrow_a.pos = ball.pos\n    arrow_a.axis = ball.a\n    t += dt",
      "mode": "initial",
      "timestamp": "2024-07-24 01:46:03",
      "serial_number": 1
    }
  ]
}